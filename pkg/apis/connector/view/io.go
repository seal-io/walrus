package view

import (
	"context"
	"errors"
	"fmt"

	"github.com/drone/go-scm/scm"

	"github.com/seal-io/seal/pkg/apis/runtime"
	"github.com/seal-io/seal/pkg/dao/model"
	"github.com/seal-io/seal/pkg/dao/model/connector"
	"github.com/seal-io/seal/pkg/dao/model/predicate"
	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/platform"
	"github.com/seal-io/seal/pkg/platform/operator"
	"github.com/seal-io/seal/pkg/topic/datamessage"
	"github.com/seal-io/seal/pkg/vcs"
)

// Basic APIs.

type CreateRequest struct {
	*model.ConnectorCreateInput `json:",inline"`
}

func (r *CreateRequest) ValidateWith(ctx context.Context, input any) error {
	if r.Name == "" {
		return errors.New("invalid name: blank")
	}
	if r.Type == "" {
		return errors.New("invalid type: blank")
	}

	entity := r.Model()
	if err := validateConnector(ctx, entity); err != nil {
		return err
	}

	return nil
}

type CreateResponse = *model.ConnectorOutput

type DeleteRequest = GetRequest

type UpdateRequest struct {
	*model.ConnectorUpdateInput `uri:",inline" json:",inline"`

	Type string `json:"type"`
}

func (r *UpdateRequest) Model() *model.Connector {
	// NB(thxCode): update input disallow configuring connector's type,
	// however, we need this type to drive operator connectivity validating.
	// We can override the Model func to set the connector entity's type,
	// this type is not able to update to database as no setter generated by entc.
	entity := r.ConnectorUpdateInput.Model()
	entity.Type = r.Type
	return entity
}

func (r *UpdateRequest) ValidateWith(ctx context.Context, input any) error {
	if !r.ID.Valid(0) {
		return errors.New("invalid id: blank")
	}
	if r.Type == "" {
		return errors.New("invalid type: blank")
	}
	if r.ConfigData != nil {
		entity := r.Model()
		if err := validateConnector(ctx, entity); err != nil {
			return err
		}
	}
	return nil
}

type GetRequest struct {
	*model.ConnectorQueryInput `uri:",inline"`
}

func (r *GetRequest) Validate() error {
	if !r.ID.Valid(0) {
		return errors.New("invalid id: blank")
	}
	return nil
}

type GetResponse = *model.ConnectorOutput

type StreamResponse struct {
	Type       datamessage.EventType    `json:"type"`
	IDs        []types.ID               `json:"ids,omitempty"`
	Collection []*model.ConnectorOutput `json:"collection,omitempty"`
}
type StreamRequest struct {
	ID types.ID `uri:"id"`
}

func (r *StreamRequest) ValidateWith(ctx context.Context, input any) error {
	if !r.ID.Valid(0) {
		return errors.New("invalid id: blank")
	}

	modelClient := input.(model.ClientSet)
	exist, err := modelClient.Connectors().
		Query().
		Where(connector.IDEQ(r.ID)).
		Exist(ctx)
	if err != nil || !exist {
		return runtime.Errorw(err, "invalid id: not found")
	}

	return nil
}

// Batch APIs.

type CollectionDeleteRequest []*model.ConnectorQueryInput

func (r CollectionDeleteRequest) Validate() error {
	if len(r) == 0 {
		return errors.New("invalid input: empty")
	}
	for _, i := range r {
		if !i.ID.Valid(0) {
			return errors.New("invalid id: blank")
		}
	}
	return nil
}

type CollectionGetRequest struct {
	runtime.RequestCollection[predicate.Connector, connector.OrderOption] `query:",inline"`

	Category string `query:"category,omitempty"`
	Type     string `query:"type,omitempty"`
}

func (r *CollectionGetRequest) Validate() error {
	if r.Category != "" {
		switch r.Category {
		case types.ConnectorCategoryKubernetes, types.ConnectorCategoryCustom, types.ConnectorCategoryVersionControl:
		default:
			return fmt.Errorf("invalid category: %s", r.Category)
		}
	}

	return nil
}

type CollectionGetResponse = []*model.ConnectorOutput

type CollectionStreamRequest struct {
	runtime.RequestExtracting `query:",inline"`
}

// Extensional APIs.

type ApplyCostToolsRequest struct {
	_ struct{} `route:"POST=/apply-cost-tools"`

	ID types.ID `uri:"id"`
}

func (r *ApplyCostToolsRequest) ValidateWith(ctx context.Context, input any) error {
	modelClient := input.(model.ClientSet)

	if !r.ID.Valid(0) {
		return errors.New("invalid id: blank")
	}

	return validateConnectorType(ctx, modelClient, r.ID)
}

type SyncCostDataRequest struct {
	_ struct{} `route:"POST=/sync-cost-data"`

	ID types.ID `uri:"id"`
}

func (r *SyncCostDataRequest) ValidateWith(ctx context.Context, input any) error {
	modelClient := input.(model.ClientSet)

	if !r.ID.Valid(0) {
		return errors.New("invalid id: blank")
	}

	return validateConnectorType(ctx, modelClient, r.ID)
}

func validateConnectorType(ctx context.Context, modelClient model.ClientSet, id types.ID) error {
	conn, err := modelClient.Connectors().Query().
		Select(connector.FieldType).
		Where(connector.ID(id)).
		Only(ctx)
	if err != nil {
		return runtime.Errorw(err, "failed to get connector")
	}

	if conn.Type != types.ConnectorTypeK8s {
		return errors.New("invalid type: not support")
	}
	return nil
}

type GetRepositoriesRequest struct {
	_ struct{} `route:"GET=/repositories"`

	runtime.RequestCollection[predicate.Connector, connector.OrderOption] `query:",inline"`
	ID                                                                    types.ID `uri:"id"`
}

type GetRepositoriesResponse = []*scm.Repository

type GetBranchesRequest struct {
	_ struct{} `route:"GET=/repository-branches"`

	runtime.RequestCollection[predicate.Connector, connector.OrderOption] `query:",inline"`
	ID                                                                    types.ID `uri:"id"`
	Repository                                                            string   `query:"repository"`
}

type GetBranchesResponse = []*scm.Reference

func validateConnector(ctx context.Context, entity *model.Connector) error {
	switch entity.Category {
	case types.ConnectorCategoryKubernetes:
		op, err := platform.GetOperator(ctx, operator.CreateOptions{
			Connector: *entity,
		})
		if err != nil {
			return fmt.Errorf("invalid connector config: %w", err)
		}
		if err = op.IsConnected(ctx); err != nil {
			return fmt.Errorf("unreachable connector: %w", err)
		}
	case types.ConnectorCategoryVersionControl:
		vcsClient, err := vcs.NewClient(entity)
		if err != nil {
			return fmt.Errorf("invalid connector config: %w", err)
		}

		_, _, err = vcsClient.Users.Find(ctx)
		if err != nil {
			return fmt.Errorf("invalid connector: %w", err)
		}
	case types.ConnectorCategoryCustom:

	default:
		return errors.New("invalid connector category")
	}

	if entity.Category != types.ConnectorCategoryKubernetes && entity.EnableFinOps {
		return errors.New("invalid connector: finOps not supported")
	}

	return nil
}
