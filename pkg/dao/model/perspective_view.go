// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/seal-io/walrus/pkg/dao/model/perspective"
	"github.com/seal-io/walrus/pkg/dao/model/predicate"
	"github.com/seal-io/walrus/pkg/dao/types"
	"github.com/seal-io/walrus/pkg/dao/types/object"
)

// PerspectiveCreateInput holds the creation input of the Perspective entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type PerspectiveCreateInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// End time for the perspective.
	EndTime string `path:"-" query:"-" json:"endTime"`
	// Start time for the perspective.
	StartTime string `path:"-" query:"-" json:"startTime"`
	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// Is builtin perspective.
	Builtin bool `path:"-" query:"-" json:"builtin,omitempty"`
	// Indicated the perspective included cost queries, record the used query condition.
	CostQueries []types.QueryCondition `path:"-" query:"-" json:"costQueries,omitempty"`
}

// Model returns the Perspective entity for creating,
// after validating.
func (pci *PerspectiveCreateInput) Model() *Perspective {
	if pci == nil {
		return nil
	}

	_p := &Perspective{
		EndTime:     pci.EndTime,
		StartTime:   pci.StartTime,
		Name:        pci.Name,
		Description: pci.Description,
		Labels:      pci.Labels,
		Builtin:     pci.Builtin,
		CostQueries: pci.CostQueries,
	}

	return _p
}

// Validate checks the PerspectiveCreateInput entity.
func (pci *PerspectiveCreateInput) Validate() error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	return pci.ValidateWith(pci.inputConfig.Context, pci.inputConfig.Client, nil)
}

// ValidateWith checks the PerspectiveCreateInput entity with the given context and client set.
func (pci *PerspectiveCreateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// PerspectiveCreateInputs holds the creation input item of the Perspective entities.
type PerspectiveCreateInputsItem struct {
	// End time for the perspective.
	EndTime string `path:"-" query:"-" json:"endTime"`
	// Start time for the perspective.
	StartTime string `path:"-" query:"-" json:"startTime"`
	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// Is builtin perspective.
	Builtin bool `path:"-" query:"-" json:"builtin,omitempty"`
	// Indicated the perspective included cost queries, record the used query condition.
	CostQueries []types.QueryCondition `path:"-" query:"-" json:"costQueries,omitempty"`
}

// ValidateWith checks the PerspectiveCreateInputsItem entity with the given context and client set.
func (pci *PerspectiveCreateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// PerspectiveCreateInputs holds the creation input of the Perspective entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type PerspectiveCreateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*PerspectiveCreateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Perspective entities for creating,
// after validating.
func (pci *PerspectiveCreateInputs) Model() []*Perspective {
	if pci == nil || len(pci.Items) == 0 {
		return nil
	}

	_ps := make([]*Perspective, len(pci.Items))

	for i := range pci.Items {
		_p := &Perspective{
			EndTime:     pci.Items[i].EndTime,
			StartTime:   pci.Items[i].StartTime,
			Name:        pci.Items[i].Name,
			Description: pci.Items[i].Description,
			Labels:      pci.Items[i].Labels,
			Builtin:     pci.Items[i].Builtin,
			CostQueries: pci.Items[i].CostQueries,
		}

		_ps[i] = _p
	}

	return _ps
}

// Validate checks the PerspectiveCreateInputs entity .
func (pci *PerspectiveCreateInputs) Validate() error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	return pci.ValidateWith(pci.inputConfig.Context, pci.inputConfig.Client, nil)
}

// ValidateWith checks the PerspectiveCreateInputs entity with the given context and client set.
func (pci *PerspectiveCreateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	if len(pci.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range pci.Items {
		if pci.Items[i] == nil {
			continue
		}

		if err := pci.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// PerspectiveDeleteInput holds the deletion input of the Perspective entity,
// please tags with `path:",inline"` if embedding.
type PerspectiveDeleteInput struct {
	PerspectiveQueryInput `path:",inline"`
}

// PerspectiveDeleteInputs holds the deletion input item of the Perspective entities.
type PerspectiveDeleteInputsItem struct {
	// ID of the Perspective entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Perspective entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// PerspectiveDeleteInputs holds the deletion input of the Perspective entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type PerspectiveDeleteInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*PerspectiveDeleteInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Perspective entities for deleting,
// after validating.
func (pdi *PerspectiveDeleteInputs) Model() []*Perspective {
	if pdi == nil || len(pdi.Items) == 0 {
		return nil
	}

	_ps := make([]*Perspective, len(pdi.Items))
	for i := range pdi.Items {
		_ps[i] = &Perspective{
			ID: pdi.Items[i].ID,
		}
	}
	return _ps
}

// IDs returns the ID list of the Perspective entities for deleting,
// after validating.
func (pdi *PerspectiveDeleteInputs) IDs() []object.ID {
	if pdi == nil || len(pdi.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(pdi.Items))
	for i := range pdi.Items {
		ids[i] = pdi.Items[i].ID
	}
	return ids
}

// Validate checks the PerspectiveDeleteInputs entity.
func (pdi *PerspectiveDeleteInputs) Validate() error {
	if pdi == nil {
		return errors.New("nil receiver")
	}

	return pdi.ValidateWith(pdi.inputConfig.Context, pdi.inputConfig.Client, nil)
}

// ValidateWith checks the PerspectiveDeleteInputs entity with the given context and client set.
func (pdi *PerspectiveDeleteInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pdi == nil {
		return errors.New("nil receiver")
	}

	if len(pdi.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Perspectives().Query()

	ids := make([]object.ID, 0, len(pdi.Items))
	ors := make([]predicate.Perspective, 0, len(pdi.Items))

	for i := range pdi.Items {
		if pdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if pdi.Items[i].ID != "" {
			ids = append(ids, pdi.Items[i].ID)
			ors = append(ors, perspective.ID(pdi.Items[i].ID))
		} else if pdi.Items[i].Name != "" {
			ors = append(ors, perspective.And(
				perspective.Name(pdi.Items[i].Name)))
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	p := perspective.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = perspective.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			perspective.FieldID,
			perspective.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		pdi.Items[i].ID = es[i].ID
		pdi.Items[i].Name = es[i].Name
	}

	return nil
}

// PerspectiveQueryInput holds the query input of the Perspective entity,
// please tags with `path:",inline"` if embedding.
type PerspectiveQueryInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Refer holds the route path reference of the Perspective entity.
	Refer *object.Refer `path:"perspective,default=" query:"-" json:"-"`
	// ID of the Perspective entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Perspective entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// Model returns the Perspective entity for querying,
// after validating.
func (pqi *PerspectiveQueryInput) Model() *Perspective {
	if pqi == nil {
		return nil
	}

	return &Perspective{
		ID:   pqi.ID,
		Name: pqi.Name,
	}
}

// Validate checks the PerspectiveQueryInput entity.
func (pqi *PerspectiveQueryInput) Validate() error {
	if pqi == nil {
		return errors.New("nil receiver")
	}

	return pqi.ValidateWith(pqi.inputConfig.Context, pqi.inputConfig.Client, nil)
}

// ValidateWith checks the PerspectiveQueryInput entity with the given context and client set.
func (pqi *PerspectiveQueryInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pqi == nil {
		return errors.New("nil receiver")
	}

	if pqi.Refer != nil && *pqi.Refer == "" {
		return fmt.Errorf("model: %s : %w", perspective.Label, ErrBlankResourceRefer)
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Perspectives().Query()

	if pqi.Refer != nil {
		if pqi.Refer.IsID() {
			q.Where(
				perspective.ID(pqi.Refer.ID()))
		} else if refers := pqi.Refer.Split(1); len(refers) == 1 {
			q.Where(
				perspective.Name(refers[0].String()))
		} else {
			return errors.New("invalid identify refer of perspective")
		}
	} else if pqi.ID != "" {
		q.Where(
			perspective.ID(pqi.ID))
	} else if pqi.Name != "" {
		q.Where(
			perspective.Name(pqi.Name))
	} else {
		return errors.New("invalid identify of perspective")
	}

	q.Select(
		perspective.FieldID,
		perspective.FieldName,
	)

	var e *Perspective
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*Perspective)
		}
	}

	pqi.ID = e.ID
	pqi.Name = e.Name
	return nil
}

// PerspectiveQueryInputs holds the query input of the Perspective entities,
// please tags with `path:",inline" query:",inline"` if embedding.
type PerspectiveQueryInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`
}

// Validate checks the PerspectiveQueryInputs entity.
func (pqi *PerspectiveQueryInputs) Validate() error {
	if pqi == nil {
		return errors.New("nil receiver")
	}

	return pqi.ValidateWith(pqi.inputConfig.Context, pqi.inputConfig.Client, nil)
}

// ValidateWith checks the PerspectiveQueryInputs entity with the given context and client set.
func (pqi *PerspectiveQueryInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pqi == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// PerspectiveUpdateInput holds the modification input of the Perspective entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type PerspectiveUpdateInput struct {
	PerspectiveQueryInput `path:",inline" query:"-" json:"-"`

	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// Start time for the perspective.
	StartTime string `path:"-" query:"-" json:"startTime,omitempty"`
	// End time for the perspective.
	EndTime string `path:"-" query:"-" json:"endTime,omitempty"`
	// Is builtin perspective.
	Builtin bool `path:"-" query:"-" json:"builtin,omitempty"`
	// Indicated the perspective included cost queries, record the used query condition.
	CostQueries []types.QueryCondition `path:"-" query:"-" json:"costQueries,omitempty"`
}

// Model returns the Perspective entity for modifying,
// after validating.
func (pui *PerspectiveUpdateInput) Model() *Perspective {
	if pui == nil {
		return nil
	}

	_p := &Perspective{
		ID:          pui.ID,
		Name:        pui.Name,
		Description: pui.Description,
		Labels:      pui.Labels,
		StartTime:   pui.StartTime,
		EndTime:     pui.EndTime,
		Builtin:     pui.Builtin,
		CostQueries: pui.CostQueries,
	}

	return _p
}

// Validate checks the PerspectiveUpdateInput entity.
func (pui *PerspectiveUpdateInput) Validate() error {
	if pui == nil {
		return errors.New("nil receiver")
	}

	return pui.ValidateWith(pui.inputConfig.Context, pui.inputConfig.Client, nil)
}

// ValidateWith checks the PerspectiveUpdateInput entity with the given context and client set.
func (pui *PerspectiveUpdateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := pui.PerspectiveQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	return nil
}

// PerspectiveUpdateInputs holds the modification input item of the Perspective entities.
type PerspectiveUpdateInputsItem struct {
	// ID of the Perspective entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Perspective entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`

	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// Start time for the perspective.
	StartTime string `path:"-" query:"-" json:"startTime"`
	// End time for the perspective.
	EndTime string `path:"-" query:"-" json:"endTime"`
	// Is builtin perspective.
	Builtin bool `path:"-" query:"-" json:"builtin"`
	// Indicated the perspective included cost queries, record the used query condition.
	CostQueries []types.QueryCondition `path:"-" query:"-" json:"costQueries"`
}

// ValidateWith checks the PerspectiveUpdateInputsItem entity with the given context and client set.
func (pui *PerspectiveUpdateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pui == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// PerspectiveUpdateInputs holds the modification input of the Perspective entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type PerspectiveUpdateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*PerspectiveUpdateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Perspective entities for modifying,
// after validating.
func (pui *PerspectiveUpdateInputs) Model() []*Perspective {
	if pui == nil || len(pui.Items) == 0 {
		return nil
	}

	_ps := make([]*Perspective, len(pui.Items))

	for i := range pui.Items {
		_p := &Perspective{
			ID:          pui.Items[i].ID,
			Name:        pui.Items[i].Name,
			Description: pui.Items[i].Description,
			Labels:      pui.Items[i].Labels,
			StartTime:   pui.Items[i].StartTime,
			EndTime:     pui.Items[i].EndTime,
			Builtin:     pui.Items[i].Builtin,
			CostQueries: pui.Items[i].CostQueries,
		}

		_ps[i] = _p
	}

	return _ps
}

// IDs returns the ID list of the Perspective entities for modifying,
// after validating.
func (pui *PerspectiveUpdateInputs) IDs() []object.ID {
	if pui == nil || len(pui.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(pui.Items))
	for i := range pui.Items {
		ids[i] = pui.Items[i].ID
	}
	return ids
}

// Validate checks the PerspectiveUpdateInputs entity.
func (pui *PerspectiveUpdateInputs) Validate() error {
	if pui == nil {
		return errors.New("nil receiver")
	}

	return pui.ValidateWith(pui.inputConfig.Context, pui.inputConfig.Client, nil)
}

// ValidateWith checks the PerspectiveUpdateInputs entity with the given context and client set.
func (pui *PerspectiveUpdateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pui == nil {
		return errors.New("nil receiver")
	}

	if len(pui.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Perspectives().Query()

	ids := make([]object.ID, 0, len(pui.Items))
	ors := make([]predicate.Perspective, 0, len(pui.Items))

	for i := range pui.Items {
		if pui.Items[i] == nil {
			return errors.New("nil item")
		}

		if pui.Items[i].ID != "" {
			ids = append(ids, pui.Items[i].ID)
			ors = append(ors, perspective.ID(pui.Items[i].ID))
		} else if pui.Items[i].Name != "" {
			ors = append(ors, perspective.And(
				perspective.Name(pui.Items[i].Name)))
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	p := perspective.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = perspective.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			perspective.FieldID,
			perspective.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		pui.Items[i].ID = es[i].ID
		pui.Items[i].Name = es[i].Name
	}

	for i := range pui.Items {
		if pui.Items[i] == nil {
			continue
		}

		if err := pui.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// PerspectiveOutput holds the output of the Perspective entity.
type PerspectiveOutput struct {
	ID          object.ID              `json:"id,omitempty"`
	Name        string                 `json:"name,omitempty"`
	Description string                 `json:"description,omitempty"`
	Labels      map[string]string      `json:"labels,omitempty"`
	CreateTime  *time.Time             `json:"createTime,omitempty"`
	UpdateTime  *time.Time             `json:"updateTime,omitempty"`
	StartTime   string                 `json:"startTime,omitempty"`
	EndTime     string                 `json:"endTime,omitempty"`
	Builtin     bool                   `json:"builtin,omitempty"`
	CostQueries []types.QueryCondition `json:"costQueries,omitempty"`
}

// View returns the output of Perspective entity.
func (_p *Perspective) View() *PerspectiveOutput {
	return ExposePerspective(_p)
}

// View returns the output of Perspective entities.
func (_ps Perspectives) View() []*PerspectiveOutput {
	return ExposePerspectives(_ps)
}

// ExposePerspective converts the Perspective to PerspectiveOutput.
func ExposePerspective(_p *Perspective) *PerspectiveOutput {
	if _p == nil {
		return nil
	}

	po := &PerspectiveOutput{
		ID:          _p.ID,
		Name:        _p.Name,
		Description: _p.Description,
		Labels:      _p.Labels,
		CreateTime:  _p.CreateTime,
		UpdateTime:  _p.UpdateTime,
		StartTime:   _p.StartTime,
		EndTime:     _p.EndTime,
		Builtin:     _p.Builtin,
		CostQueries: _p.CostQueries,
	}

	return po
}

// ExposePerspectives converts the Perspective slice to PerspectiveOutput pointer slice.
func ExposePerspectives(_ps []*Perspective) []*PerspectiveOutput {
	if len(_ps) == 0 {
		return nil
	}

	pos := make([]*PerspectiveOutput, len(_ps))
	for i := range _ps {
		pos[i] = ExposePerspective(_ps[i])
	}
	return pos
}
