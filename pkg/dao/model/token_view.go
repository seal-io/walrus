// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/token"
	"github.com/seal-io/seal/pkg/dao/types/crypto"
	"github.com/seal-io/seal/pkg/dao/types/object"
)

// TokenCreateInput holds the creation input of the Token entity.
type TokenCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Value      crypto.String `uri:"-" query:"-" json:"value"`
	Name       string        `uri:"-" query:"-" json:"name"`
	Kind       string        `uri:"-" query:"-" json:"kind,omitempty"`
	Expiration *time.Time    `uri:"-" query:"-" json:"expiration,omitempty"`
}

// Model returns the Token entity for creating,
// after validating.
func (tci *TokenCreateInput) Model() *Token {
	if tci == nil {
		return nil
	}

	_t := &Token{
		Value:      tci.Value,
		Name:       tci.Name,
		Kind:       tci.Kind,
		Expiration: tci.Expiration,
	}

	return _t
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tci *TokenCreateInput) Load() error {
	if tci == nil {
		return errors.New("nil receiver")
	}

	return tci.LoadWith(tci.inputConfig.Context, tci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tci *TokenCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tci == nil {
		return errors.New("nil receiver")
	}

	return nil
}

// TokenCreateInputs holds the creation input item of the Token entities.
type TokenCreateInputsItem struct {
	Value      crypto.String `uri:"-" query:"-" json:"value"`
	Name       string        `uri:"-" query:"-" json:"name"`
	Kind       string        `uri:"-" query:"-" json:"kind,omitempty"`
	Expiration *time.Time    `uri:"-" query:"-" json:"expiration,omitempty"`
}

// TokenCreateInputs holds the creation input of the Token entities.
type TokenCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*TokenCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Token entities for creating,
// after validating.
func (tci *TokenCreateInputs) Model() []*Token {
	if tci == nil || len(tci.Items) == 0 {
		return nil
	}

	_ts := make([]*Token, len(tci.Items))

	for i := range tci.Items {
		_t := &Token{
			Value:      tci.Items[i].Value,
			Name:       tci.Items[i].Name,
			Kind:       tci.Items[i].Kind,
			Expiration: tci.Items[i].Expiration,
		}

		_ts[i] = _t
	}

	return _ts
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tci *TokenCreateInputs) Load() error {
	if tci == nil {
		return errors.New("nil receiver")
	}

	return tci.LoadWith(tci.inputConfig.Context, tci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tci *TokenCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tci == nil {
		return errors.New("nil receiver")
	}

	if len(tci.Items) == 0 {
		return errors.New("empty items")
	}

	return nil
}

// TokenDeleteInput holds the deletion input of the Token entity.
type TokenDeleteInput = TokenQueryInput

// TokenDeleteInputs holds the deletion input item of the Token entities.
type TokenDeleteInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`
}

// TokenDeleteInputs holds the deletion input of the Token entities.
type TokenDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*TokenDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Token entities for deleting,
// after validating.
func (tdi *TokenDeleteInputs) Model() []*Token {
	if tdi == nil || len(tdi.Items) == 0 {
		return nil
	}

	_ts := make([]*Token, len(tdi.Items))
	for i := range tdi.Items {
		_ts[i] = &Token{
			ID: tdi.Items[i].ID,
		}
	}
	return _ts
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tdi *TokenDeleteInputs) Load() error {
	if tdi == nil {
		return errors.New("nil receiver")
	}

	return tdi.LoadWith(tdi.inputConfig.Context, tdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tdi *TokenDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tdi == nil {
		return errors.New("nil receiver")
	}

	if len(tdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Tokens().Query()

	ids := make([]object.ID, 0, len(tdi.Items))

	for i := range tdi.Items {
		if tdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if tdi.Items[i].ID != "" {
			ids = append(ids, tdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(token.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// TokenQueryInput holds the query input of the Token entity.
type TokenQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Refer *object.Refer `uri:"token,default=\"\"" query:"-" json:"-"`
	ID    object.ID     `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the Token entity for querying,
// after validating.
func (tqi *TokenQueryInput) Model() *Token {
	if tqi == nil {
		return nil
	}

	return &Token{
		ID: tqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tqi *TokenQueryInput) Load() error {
	if tqi == nil {
		return errors.New("nil receiver")
	}

	return tqi.LoadWith(tqi.inputConfig.Context, tqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tqi *TokenQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tqi == nil {
		return errors.New("nil receiver")
	}

	if tqi.Refer != nil && *tqi.Refer == "" {
		return nil
	}

	q := cs.Tokens().Query()

	if tqi.Refer != nil {
		if tqi.Refer.IsID() {
			q.Where(
				token.ID(tqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of token")
		}
	} else if tqi.ID != "" {
		q.Where(
			token.ID(tqi.ID))
	} else {
		return errors.New("invalid identify of token")
	}

	tqi.ID, err = q.OnlyID(ctx)
	return err
}

// TokenQueryInputs holds the query input of the Token entities.
type TokenQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tqi *TokenQueryInputs) Load() error {
	if tqi == nil {
		return errors.New("nil receiver")
	}

	return tqi.LoadWith(tqi.inputConfig.Context, tqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tqi *TokenQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tqi == nil {
		return errors.New("nil receiver")
	}

	return err
}

// TokenUpdateInput holds the modification input of the Token entity.
type TokenUpdateInput struct {
	TokenQueryInput `uri:",inline" query:"-" json:",inline"`
}

// Model returns the Token entity for modifying,
// after validating.
func (tui *TokenUpdateInput) Model() *Token {
	if tui == nil {
		return nil
	}

	_t := &Token{
		ID: tui.ID,
	}

	return _t
}

// TokenUpdateInputs holds the modification input item of the Token entities.
type TokenUpdateInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`
}

// TokenUpdateInputs holds the modification input of the Token entities.
type TokenUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*TokenUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Token entities for modifying,
// after validating.
func (tui *TokenUpdateInputs) Model() []*Token {
	if tui == nil || len(tui.Items) == 0 {
		return nil
	}

	_ts := make([]*Token, len(tui.Items))

	for i := range tui.Items {
		_t := &Token{
			ID: tui.Items[i].ID,
		}

		_ts[i] = _t
	}

	return _ts
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tui *TokenUpdateInputs) Load() error {
	if tui == nil {
		return errors.New("nil receiver")
	}

	return tui.LoadWith(tui.inputConfig.Context, tui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tui *TokenUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tui == nil {
		return errors.New("nil receiver")
	}

	if len(tui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Tokens().Query()

	ids := make([]object.ID, 0, len(tui.Items))

	for i := range tui.Items {
		if tui.Items[i] == nil {
			return errors.New("nil item")
		}

		if tui.Items[i].ID != "" {
			ids = append(ids, tui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(token.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// TokenOutput holds the output of the Token entity.
type TokenOutput struct {
	ID          object.ID  `json:"id,omitempty"`
	CreateTime  *time.Time `json:"createTime,omitempty"`
	Kind        string     `json:"kind,omitempty"`
	Name        string     `json:"name,omitempty"`
	Expiration  *time.Time `json:"expiration,omitempty"`
	AccessToken string     `json:"accessToken,omitempty"`

	Subject *SubjectOutput `json:"subject,omitempty"`
}

// View returns the output of Token.
func (_t *Token) View() *TokenOutput {
	return ExposeToken(_t)
}

// View returns the output of Tokens.
func (_ts Tokens) View() []*TokenOutput {
	return ExposeTokens(_ts)
}

// ExposeToken converts the Token to TokenOutput.
func ExposeToken(_t *Token) *TokenOutput {
	if _t == nil {
		return nil
	}

	to := &TokenOutput{
		ID:          _t.ID,
		CreateTime:  _t.CreateTime,
		Kind:        _t.Kind,
		Name:        _t.Name,
		Expiration:  _t.Expiration,
		AccessToken: _t.AccessToken,
	}

	if _t.Edges.Subject != nil {
		to.Subject = ExposeSubject(_t.Edges.Subject)
	} else if _t.SubjectID != "" {
		to.Subject = &SubjectOutput{
			ID: _t.SubjectID,
		}
	}
	return to
}

// ExposeTokens converts the Token slice to TokenOutput pointer slice.
func ExposeTokens(_ts []*Token) []*TokenOutput {
	if len(_ts) == 0 {
		return nil
	}

	tos := make([]*TokenOutput, len(_ts))
	for i := range _ts {
		tos[i] = ExposeToken(_ts[i])
	}
	return tos
}
