// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/catalog"
	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/dao/types/object"
	"github.com/seal-io/seal/pkg/dao/types/status"
)

// CatalogCreateInput holds the creation input of the Catalog entity.
type CatalogCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Source      string            `uri:"-" query:"-" json:"source"`
	Type        string            `uri:"-" query:"-" json:"type"`
	Name        string            `uri:"-" query:"-" json:"name"`
	Description string            `uri:"-" query:"-" json:"description,omitempty"`
	Labels      map[string]string `uri:"-" query:"-" json:"labels,omitempty"`
}

// Model returns the Catalog entity for creating,
// after validating.
func (cci *CatalogCreateInput) Model() *Catalog {
	if cci == nil {
		return nil
	}

	_c := &Catalog{
		Source:      cci.Source,
		Type:        cci.Type,
		Name:        cci.Name,
		Description: cci.Description,
		Labels:      cci.Labels,
	}

	return _c
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cci *CatalogCreateInput) Load() error {
	if cci == nil {
		return errors.New("nil receiver")
	}

	return cci.LoadWith(cci.inputConfig.Context, cci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cci *CatalogCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cci == nil {
		return errors.New("nil receiver")
	}

	return nil
}

// CatalogCreateInputs holds the creation input item of the Catalog entities.
type CatalogCreateInputsItem struct {
	Source      string            `uri:"-" query:"-" json:"source"`
	Type        string            `uri:"-" query:"-" json:"type"`
	Name        string            `uri:"-" query:"-" json:"name"`
	Description string            `uri:"-" query:"-" json:"description,omitempty"`
	Labels      map[string]string `uri:"-" query:"-" json:"labels,omitempty"`
}

// CatalogCreateInputs holds the creation input of the Catalog entities.
type CatalogCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*CatalogCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Catalog entities for creating,
// after validating.
func (cci *CatalogCreateInputs) Model() []*Catalog {
	if cci == nil || len(cci.Items) == 0 {
		return nil
	}

	_cs := make([]*Catalog, len(cci.Items))

	for i := range cci.Items {
		_c := &Catalog{
			Source:      cci.Items[i].Source,
			Type:        cci.Items[i].Type,
			Name:        cci.Items[i].Name,
			Description: cci.Items[i].Description,
			Labels:      cci.Items[i].Labels,
		}

		_cs[i] = _c
	}

	return _cs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cci *CatalogCreateInputs) Load() error {
	if cci == nil {
		return errors.New("nil receiver")
	}

	return cci.LoadWith(cci.inputConfig.Context, cci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cci *CatalogCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cci == nil {
		return errors.New("nil receiver")
	}

	if len(cci.Items) == 0 {
		return errors.New("empty items")
	}

	return nil
}

// CatalogDeleteInput holds the deletion input of the Catalog entity.
type CatalogDeleteInput = CatalogQueryInput

// CatalogDeleteInputs holds the deletion input item of the Catalog entities.
type CatalogDeleteInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`
}

// CatalogDeleteInputs holds the deletion input of the Catalog entities.
type CatalogDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*CatalogDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Catalog entities for deleting,
// after validating.
func (cdi *CatalogDeleteInputs) Model() []*Catalog {
	if cdi == nil || len(cdi.Items) == 0 {
		return nil
	}

	_cs := make([]*Catalog, len(cdi.Items))
	for i := range cdi.Items {
		_cs[i] = &Catalog{
			ID: cdi.Items[i].ID,
		}
	}
	return _cs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cdi *CatalogDeleteInputs) Load() error {
	if cdi == nil {
		return errors.New("nil receiver")
	}

	return cdi.LoadWith(cdi.inputConfig.Context, cdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cdi *CatalogDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cdi == nil {
		return errors.New("nil receiver")
	}

	if len(cdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Catalogs().Query()

	ids := make([]object.ID, 0, len(cdi.Items))

	for i := range cdi.Items {
		if cdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if cdi.Items[i].ID != "" {
			ids = append(ids, cdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(catalog.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// CatalogQueryInput holds the query input of the Catalog entity.
type CatalogQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Refer *object.Refer `uri:"catalog,default=\"\"" query:"-" json:"-"`
	ID    object.ID     `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the Catalog entity for querying,
// after validating.
func (cqi *CatalogQueryInput) Model() *Catalog {
	if cqi == nil {
		return nil
	}

	return &Catalog{
		ID: cqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cqi *CatalogQueryInput) Load() error {
	if cqi == nil {
		return errors.New("nil receiver")
	}

	return cqi.LoadWith(cqi.inputConfig.Context, cqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cqi *CatalogQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cqi == nil {
		return errors.New("nil receiver")
	}

	if cqi.Refer != nil && *cqi.Refer == "" {
		return nil
	}

	q := cs.Catalogs().Query()

	if cqi.Refer != nil {
		if cqi.Refer.IsID() {
			q.Where(
				catalog.ID(cqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of catalog")
		}
	} else if cqi.ID != "" {
		q.Where(
			catalog.ID(cqi.ID))
	} else {
		return errors.New("invalid identify of catalog")
	}

	cqi.ID, err = q.OnlyID(ctx)
	return err
}

// CatalogQueryInputs holds the query input of the Catalog entities.
type CatalogQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cqi *CatalogQueryInputs) Load() error {
	if cqi == nil {
		return errors.New("nil receiver")
	}

	return cqi.LoadWith(cqi.inputConfig.Context, cqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cqi *CatalogQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cqi == nil {
		return errors.New("nil receiver")
	}

	return err
}

// CatalogUpdateInput holds the modification input of the Catalog entity.
type CatalogUpdateInput struct {
	CatalogQueryInput `uri:",inline" query:"-" json:",inline"`

	Name        string            `uri:"-" query:"-" json:"name,omitempty"`
	Description string            `uri:"-" query:"-" json:"description,omitempty"`
	Labels      map[string]string `uri:"-" query:"-" json:"labels,omitempty"`
	Source      string            `uri:"-" query:"-" json:"source,omitempty"`
}

// Model returns the Catalog entity for modifying,
// after validating.
func (cui *CatalogUpdateInput) Model() *Catalog {
	if cui == nil {
		return nil
	}

	_c := &Catalog{
		ID:          cui.ID,
		Name:        cui.Name,
		Description: cui.Description,
		Labels:      cui.Labels,
		Source:      cui.Source,
	}

	return _c
}

// CatalogUpdateInputs holds the modification input item of the Catalog entities.
type CatalogUpdateInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`

	Name        string            `uri:"-" query:"-" json:"name,omitempty"`
	Description string            `uri:"-" query:"-" json:"description,omitempty"`
	Labels      map[string]string `uri:"-" query:"-" json:"labels,omitempty"`
	Source      string            `uri:"-" query:"-" json:"source,omitempty"`
}

// CatalogUpdateInputs holds the modification input of the Catalog entities.
type CatalogUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*CatalogUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Catalog entities for modifying,
// after validating.
func (cui *CatalogUpdateInputs) Model() []*Catalog {
	if cui == nil || len(cui.Items) == 0 {
		return nil
	}

	_cs := make([]*Catalog, len(cui.Items))

	for i := range cui.Items {
		_c := &Catalog{
			ID:          cui.Items[i].ID,
			Name:        cui.Items[i].Name,
			Description: cui.Items[i].Description,
			Labels:      cui.Items[i].Labels,
			Source:      cui.Items[i].Source,
		}

		_cs[i] = _c
	}

	return _cs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cui *CatalogUpdateInputs) Load() error {
	if cui == nil {
		return errors.New("nil receiver")
	}

	return cui.LoadWith(cui.inputConfig.Context, cui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cui *CatalogUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cui == nil {
		return errors.New("nil receiver")
	}

	if len(cui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Catalogs().Query()

	ids := make([]object.ID, 0, len(cui.Items))

	for i := range cui.Items {
		if cui.Items[i] == nil {
			return errors.New("nil item")
		}

		if cui.Items[i].ID != "" {
			ids = append(ids, cui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(catalog.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// CatalogOutput holds the output of the Catalog entity.
type CatalogOutput struct {
	ID          object.ID          `json:"id,omitempty"`
	Name        string             `json:"name,omitempty"`
	Description string             `json:"description,omitempty"`
	Labels      map[string]string  `json:"labels,omitempty"`
	CreateTime  *time.Time         `json:"createTime,omitempty"`
	UpdateTime  *time.Time         `json:"updateTime,omitempty"`
	Status      status.Status      `json:"status,omitempty"`
	Type        string             `json:"type,omitempty"`
	Source      string             `json:"source,omitempty"`
	Sync        *types.CatalogSync `json:"sync,omitempty"`
}

// View returns the output of Catalog.
func (_c *Catalog) View() *CatalogOutput {
	return ExposeCatalog(_c)
}

// View returns the output of Catalogs.
func (_cs Catalogs) View() []*CatalogOutput {
	return ExposeCatalogs(_cs)
}

// ExposeCatalog converts the Catalog to CatalogOutput.
func ExposeCatalog(_c *Catalog) *CatalogOutput {
	if _c == nil {
		return nil
	}

	co := &CatalogOutput{
		ID:          _c.ID,
		Name:        _c.Name,
		Description: _c.Description,
		Labels:      _c.Labels,
		CreateTime:  _c.CreateTime,
		UpdateTime:  _c.UpdateTime,
		Status:      _c.Status,
		Type:        _c.Type,
		Source:      _c.Source,
		Sync:        _c.Sync,
	}

	return co
}

// ExposeCatalogs converts the Catalog slice to CatalogOutput pointer slice.
func ExposeCatalogs(_cs []*Catalog) []*CatalogOutput {
	if len(_cs) == 0 {
		return nil
	}

	cos := make([]*CatalogOutput, len(_cs))
	for i := range _cs {
		cos[i] = ExposeCatalog(_cs[i])
	}
	return cos
}
