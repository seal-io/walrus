// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/role"
	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/dao/types/object"
)

// RoleCreateInput holds the creation input of the Role entity.
type RoleCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Kind        string             `uri:"-" query:"-" json:"kind,omitempty"`
	Description string             `uri:"-" query:"-" json:"description,omitempty"`
	Policies    types.RolePolicies `uri:"-" query:"-" json:"policies,omitempty"`
}

// Model returns the Role entity for creating,
// after validating.
func (rci *RoleCreateInput) Model() *Role {
	if rci == nil {
		return nil
	}

	r := &Role{
		Kind:        rci.Kind,
		Description: rci.Description,
		Policies:    rci.Policies,
	}

	return r
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (rci *RoleCreateInput) Load() error {
	if rci == nil {
		return errors.New("nil receiver")
	}

	return rci.LoadWith(rci.inputConfig.Context, rci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (rci *RoleCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if rci == nil {
		return errors.New("nil receiver")
	}

	return nil
}

// RoleCreateInputs holds the creation input item of the Role entities.
type RoleCreateInputsItem struct {
	Kind        string             `uri:"-" query:"-" json:"kind,omitempty"`
	Description string             `uri:"-" query:"-" json:"description,omitempty"`
	Policies    types.RolePolicies `uri:"-" query:"-" json:"policies,omitempty"`
}

// RoleCreateInputs holds the creation input of the Role entities.
type RoleCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*RoleCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Role entities for creating,
// after validating.
func (rci *RoleCreateInputs) Model() []*Role {
	if rci == nil || len(rci.Items) == 0 {
		return nil
	}

	rs := make([]*Role, len(rci.Items))

	for i := range rci.Items {
		r := &Role{
			Kind:        rci.Items[i].Kind,
			Description: rci.Items[i].Description,
			Policies:    rci.Items[i].Policies,
		}

		rs[i] = r
	}

	return rs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (rci *RoleCreateInputs) Load() error {
	if rci == nil {
		return errors.New("nil receiver")
	}

	return rci.LoadWith(rci.inputConfig.Context, rci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (rci *RoleCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if rci == nil {
		return errors.New("nil receiver")
	}

	if len(rci.Items) == 0 {
		return errors.New("empty items")
	}

	return nil
}

// RoleDeleteInput holds the deletion input of the Role entity.
type RoleDeleteInput = RoleQueryInput

// RoleDeleteInputs holds the deletion input item of the Role entities.
type RoleDeleteInputsItem struct {
	ID string `uri:"-" query:"-" json:"id"`
}

// RoleDeleteInputs holds the deletion input of the Role entities.
type RoleDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*RoleDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Role entities for deleting,
// after validating.
func (rdi *RoleDeleteInputs) Model() []*Role {
	if rdi == nil || len(rdi.Items) == 0 {
		return nil
	}

	rs := make([]*Role, len(rdi.Items))
	for i := range rdi.Items {
		rs[i] = &Role{
			ID: rdi.Items[i].ID,
		}
	}
	return rs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (rdi *RoleDeleteInputs) Load() error {
	if rdi == nil {
		return errors.New("nil receiver")
	}

	return rdi.LoadWith(rdi.inputConfig.Context, rdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (rdi *RoleDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if rdi == nil {
		return errors.New("nil receiver")
	}

	if len(rdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Roles().Query()

	ids := make([]string, 0, len(rdi.Items))

	for i := range rdi.Items {
		if rdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if rdi.Items[i].ID != "" {
			ids = append(ids, rdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(role.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// RoleQueryInput holds the query input of the Role entity.
type RoleQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Refer *object.Refer `uri:"role,default=\"\"" query:"-" json:"-"`
	ID    string        `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the Role entity for querying,
// after validating.
func (rqi *RoleQueryInput) Model() *Role {
	if rqi == nil {
		return nil
	}

	return &Role{
		ID: rqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (rqi *RoleQueryInput) Load() error {
	if rqi == nil {
		return errors.New("nil receiver")
	}

	return rqi.LoadWith(rqi.inputConfig.Context, rqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (rqi *RoleQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if rqi == nil {
		return errors.New("nil receiver")
	}

	if rqi.Refer != nil && *rqi.Refer == "" {
		return nil
	}

	q := cs.Roles().Query()

	if rqi.Refer != nil {
		if rqi.Refer.IsString() {
			q.Where(
				role.ID(rqi.Refer.String()))
		} else {
			return errors.New("invalid identify refer of role")
		}
	} else if rqi.ID != "" {
		q.Where(
			role.ID(rqi.ID))
	} else {
		return errors.New("invalid identify of role")
	}

	rqi.ID, err = q.OnlyID(ctx)
	return err
}

// RoleQueryInputs holds the query input of the Role entities.
type RoleQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (rqi *RoleQueryInputs) Load() error {
	if rqi == nil {
		return errors.New("nil receiver")
	}

	return rqi.LoadWith(rqi.inputConfig.Context, rqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (rqi *RoleQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if rqi == nil {
		return errors.New("nil receiver")
	}

	return err
}

// RoleUpdateInput holds the modification input of the Role entity.
type RoleUpdateInput struct {
	RoleQueryInput `uri:",inline" query:"-" json:",inline"`

	Description string             `uri:"-" query:"-" json:"description,omitempty"`
	Policies    types.RolePolicies `uri:"-" query:"-" json:"policies,omitempty"`
}

// Model returns the Role entity for modifying,
// after validating.
func (rui *RoleUpdateInput) Model() *Role {
	if rui == nil {
		return nil
	}

	r := &Role{
		ID:          rui.ID,
		Description: rui.Description,
		Policies:    rui.Policies,
	}

	return r
}

// RoleUpdateInputs holds the modification input item of the Role entities.
type RoleUpdateInputsItem struct {
	ID string `uri:"-" query:"-" json:"id"`

	Description string             `uri:"-" query:"-" json:"description,omitempty"`
	Policies    types.RolePolicies `uri:"-" query:"-" json:"policies,omitempty"`
}

// RoleUpdateInputs holds the modification input of the Role entities.
type RoleUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*RoleUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Role entities for modifying,
// after validating.
func (rui *RoleUpdateInputs) Model() []*Role {
	if rui == nil || len(rui.Items) == 0 {
		return nil
	}

	rs := make([]*Role, len(rui.Items))

	for i := range rui.Items {
		r := &Role{
			ID:          rui.Items[i].ID,
			Description: rui.Items[i].Description,
			Policies:    rui.Items[i].Policies,
		}

		rs[i] = r
	}

	return rs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (rui *RoleUpdateInputs) Load() error {
	if rui == nil {
		return errors.New("nil receiver")
	}

	return rui.LoadWith(rui.inputConfig.Context, rui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (rui *RoleUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if rui == nil {
		return errors.New("nil receiver")
	}

	if len(rui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Roles().Query()

	ids := make([]string, 0, len(rui.Items))

	for i := range rui.Items {
		if rui.Items[i] == nil {
			return errors.New("nil item")
		}

		if rui.Items[i].ID != "" {
			ids = append(ids, rui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(role.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// RoleOutput holds the output of the Role entity.
type RoleOutput struct {
	ID          string             `json:"id,omitempty"`
	CreateTime  *time.Time         `json:"createTime,omitempty"`
	UpdateTime  *time.Time         `json:"updateTime,omitempty"`
	Kind        string             `json:"kind,omitempty"`
	Description string             `json:"description,omitempty"`
	Policies    types.RolePolicies `json:"policies,omitempty"`
	Builtin     bool               `json:"builtin,omitempty"`
}

// View returns the output of Role.
func (r *Role) View() *RoleOutput {
	return ExposeRole(r)
}

// View returns the output of Roles.
func (rs Roles) View() []*RoleOutput {
	return ExposeRoles(rs)
}

// ExposeRole converts the Role to RoleOutput.
func ExposeRole(r *Role) *RoleOutput {
	if r == nil {
		return nil
	}

	ro := &RoleOutput{
		ID:          r.ID,
		CreateTime:  r.CreateTime,
		UpdateTime:  r.UpdateTime,
		Kind:        r.Kind,
		Description: r.Description,
		Policies:    r.Policies,
		Builtin:     r.Builtin,
	}

	return ro
}

// ExposeRoles converts the Role slice to RoleOutput pointer slice.
func ExposeRoles(rs []*Role) []*RoleOutput {
	if len(rs) == 0 {
		return nil
	}

	ros := make([]*RoleOutput, len(rs))
	for i := range rs {
		ros[i] = ExposeRole(rs[i])
	}
	return ros
}
