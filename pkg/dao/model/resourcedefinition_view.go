// SPDX-FileCopyrightText: 2024 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/seal-io/walrus/pkg/dao/model/predicate"
	"github.com/seal-io/walrus/pkg/dao/model/resourcedefinition"
	"github.com/seal-io/walrus/pkg/dao/types"
	"github.com/seal-io/walrus/pkg/dao/types/object"
	"github.com/seal-io/walrus/utils/json"
)

// ResourceDefinitionCreateInput holds the creation input of the ResourceDefinition entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceDefinitionCreateInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Type of the resources generated from the resource definition.
	Type string `path:"-" query:"-" json:"type,cli-table-column"`
	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// UI schema of the resource definition.
	UiSchema *types.UISchema `path:"-" query:"-" json:"uiSchema,omitempty"`

	// MatchingRules specifies full inserting the new ResourceDefinitionMatchingRule entities of the ResourceDefinition entity.
	MatchingRules []*ResourceDefinitionMatchingRuleCreateInput `uri:"-" query:"-" json:"matchingRules,omitempty"`
}

// Model returns the ResourceDefinition entity for creating,
// after validating.
func (rdci *ResourceDefinitionCreateInput) Model() *ResourceDefinition {
	if rdci == nil {
		return nil
	}

	_rd := &ResourceDefinition{
		Type:        rdci.Type,
		Name:        rdci.Name,
		Description: rdci.Description,
		Labels:      rdci.Labels,
		UiSchema:    rdci.UiSchema,
	}

	if rdci.MatchingRules != nil {
		// Empty slice is used for clearing the edge.
		_rd.Edges.MatchingRules = make([]*ResourceDefinitionMatchingRule, 0, len(rdci.MatchingRules))
	}
	for j := range rdci.MatchingRules {
		if rdci.MatchingRules[j] == nil {
			continue
		}
		_rd.Edges.MatchingRules = append(_rd.Edges.MatchingRules,
			rdci.MatchingRules[j].Model())
	}
	return _rd
}

// Validate checks the ResourceDefinitionCreateInput entity.
func (rdci *ResourceDefinitionCreateInput) Validate() error {
	if rdci == nil {
		return errors.New("nil receiver")
	}

	return rdci.ValidateWith(rdci.inputConfig.Context, rdci.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceDefinitionCreateInput entity with the given context and client set.
func (rdci *ResourceDefinitionCreateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rdci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range rdci.MatchingRules {
		if rdci.MatchingRules[i] == nil {
			continue
		}

		if err := rdci.MatchingRules[i].ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rdci.MatchingRules[i] = nil
			}
		}
	}

	return nil
}

// ResourceDefinitionCreateInputs holds the creation input item of the ResourceDefinition entities.
type ResourceDefinitionCreateInputsItem struct {
	// Type of the resources generated from the resource definition.
	Type string `path:"-" query:"-" json:"type,cli-table-column"`
	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// UI schema of the resource definition.
	UiSchema *types.UISchema `path:"-" query:"-" json:"uiSchema,omitempty"`

	// MatchingRules specifies full inserting the new ResourceDefinitionMatchingRule entities.
	MatchingRules []*ResourceDefinitionMatchingRuleCreateInput `uri:"-" query:"-" json:"matchingRules,omitempty"`
}

// ValidateWith checks the ResourceDefinitionCreateInputsItem entity with the given context and client set.
func (rdci *ResourceDefinitionCreateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rdci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range rdci.MatchingRules {
		if rdci.MatchingRules[i] == nil {
			continue
		}

		if err := rdci.MatchingRules[i].ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rdci.MatchingRules[i] = nil
			}
		}
	}

	return nil
}

// ResourceDefinitionCreateInputs holds the creation input of the ResourceDefinition entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceDefinitionCreateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceDefinitionCreateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceDefinition entities for creating,
// after validating.
func (rdci *ResourceDefinitionCreateInputs) Model() []*ResourceDefinition {
	if rdci == nil || len(rdci.Items) == 0 {
		return nil
	}

	_rds := make([]*ResourceDefinition, len(rdci.Items))

	for i := range rdci.Items {
		_rd := &ResourceDefinition{
			Type:        rdci.Items[i].Type,
			Name:        rdci.Items[i].Name,
			Description: rdci.Items[i].Description,
			Labels:      rdci.Items[i].Labels,
			UiSchema:    rdci.Items[i].UiSchema,
		}

		if rdci.Items[i].MatchingRules != nil {
			// Empty slice is used for clearing the edge.
			_rd.Edges.MatchingRules = make([]*ResourceDefinitionMatchingRule, 0, len(rdci.Items[i].MatchingRules))
		}
		for j := range rdci.Items[i].MatchingRules {
			if rdci.Items[i].MatchingRules[j] == nil {
				continue
			}
			_rd.Edges.MatchingRules = append(_rd.Edges.MatchingRules,
				rdci.Items[i].MatchingRules[j].Model())
		}

		_rds[i] = _rd
	}

	return _rds
}

// Validate checks the ResourceDefinitionCreateInputs entity .
func (rdci *ResourceDefinitionCreateInputs) Validate() error {
	if rdci == nil {
		return errors.New("nil receiver")
	}

	return rdci.ValidateWith(rdci.inputConfig.Context, rdci.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceDefinitionCreateInputs entity with the given context and client set.
func (rdci *ResourceDefinitionCreateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rdci == nil {
		return errors.New("nil receiver")
	}

	if len(rdci.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range rdci.Items {
		if rdci.Items[i] == nil {
			continue
		}

		if err := rdci.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ResourceDefinitionDeleteInput holds the deletion input of the ResourceDefinition entity,
// please tags with `path:",inline"` if embedding.
type ResourceDefinitionDeleteInput struct {
	ResourceDefinitionQueryInput `path:",inline"`
}

// ResourceDefinitionDeleteInputs holds the deletion input item of the ResourceDefinition entities.
type ResourceDefinitionDeleteInputsItem struct {
	// ID of the ResourceDefinition entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the ResourceDefinition entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// ResourceDefinitionDeleteInputs holds the deletion input of the ResourceDefinition entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceDefinitionDeleteInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceDefinitionDeleteInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceDefinition entities for deleting,
// after validating.
func (rddi *ResourceDefinitionDeleteInputs) Model() []*ResourceDefinition {
	if rddi == nil || len(rddi.Items) == 0 {
		return nil
	}

	_rds := make([]*ResourceDefinition, len(rddi.Items))
	for i := range rddi.Items {
		_rds[i] = &ResourceDefinition{
			ID: rddi.Items[i].ID,
		}
	}
	return _rds
}

// IDs returns the ID list of the ResourceDefinition entities for deleting,
// after validating.
func (rddi *ResourceDefinitionDeleteInputs) IDs() []object.ID {
	if rddi == nil || len(rddi.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(rddi.Items))
	for i := range rddi.Items {
		ids[i] = rddi.Items[i].ID
	}
	return ids
}

// Validate checks the ResourceDefinitionDeleteInputs entity.
func (rddi *ResourceDefinitionDeleteInputs) Validate() error {
	if rddi == nil {
		return errors.New("nil receiver")
	}

	return rddi.ValidateWith(rddi.inputConfig.Context, rddi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceDefinitionDeleteInputs entity with the given context and client set.
func (rddi *ResourceDefinitionDeleteInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rddi == nil {
		return errors.New("nil receiver")
	}

	if len(rddi.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceDefinitions().Query()

	ids := make([]object.ID, 0, len(rddi.Items))
	ors := make([]predicate.ResourceDefinition, 0, len(rddi.Items))
	indexers := make(map[any][]int)

	for i := range rddi.Items {
		if rddi.Items[i] == nil {
			return errors.New("nil item")
		}

		if rddi.Items[i].ID != "" {
			ids = append(ids, rddi.Items[i].ID)
			ors = append(ors, resourcedefinition.ID(rddi.Items[i].ID))
			indexers[rddi.Items[i].ID] = append(indexers[rddi.Items[i].ID], i)
		} else if rddi.Items[i].Name != "" {
			ors = append(ors, resourcedefinition.And(
				resourcedefinition.Name(rddi.Items[i].Name)))
			indexerKey := fmt.Sprint("/", rddi.Items[i].Name)
			indexers[indexerKey] = append(indexers[indexerKey], i)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	p := resourcedefinition.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = resourcedefinition.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			resourcedefinition.FieldID,
			resourcedefinition.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		indexer := indexers[es[i].ID]
		if indexer == nil {
			indexerKey := fmt.Sprint("/", es[i].Name)
			indexer = indexers[indexerKey]
		}
		for _, j := range indexer {
			rddi.Items[j].ID = es[i].ID
			rddi.Items[j].Name = es[i].Name
		}
	}

	return nil
}

// ResourceDefinitionPatchInput holds the patch input of the ResourceDefinition entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceDefinitionPatchInput struct {
	ResourceDefinitionQueryInput `path:",inline" query:"-" json:"-"`

	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name,omitempty"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// Annotations holds the value of the "annotations" field.
	Annotations map[string]string `path:"-" query:"-" json:"annotations,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime *time.Time `path:"-" query:"-" json:"createTime,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime *time.Time `path:"-" query:"-" json:"updateTime,omitempty"`
	// Type of the resources generated from the resource definition.
	Type string `path:"-" query:"-" json:"type,omitempty"`
	// Generated schema of the resource definition.
	Schema types.Schema `path:"-" query:"-" json:"schema,omitempty"`
	// UI schema of the resource definition.
	UiSchema *types.UISchema `path:"-" query:"-" json:"uiSchema,omitempty"`
	// Indicate whether the resource definition is builtin, decided when creating.
	Builtin bool `path:"-" query:"-" json:"builtin,omitempty"`

	// MatchingRules indicates replacing the stale ResourceDefinitionMatchingRule entities.
	MatchingRules []*ResourceDefinitionMatchingRuleCreateInput `uri:"-" query:"-" json:"matchingRules,omitempty"`

	patchedEntity *ResourceDefinition `path:"-" query:"-" json:"-"`
}

// PatchModel returns the ResourceDefinition partition entity for patching.
func (rdpi *ResourceDefinitionPatchInput) PatchModel() *ResourceDefinition {
	if rdpi == nil {
		return nil
	}

	_rd := &ResourceDefinition{
		Name:        rdpi.Name,
		Description: rdpi.Description,
		Labels:      rdpi.Labels,
		Annotations: rdpi.Annotations,
		CreateTime:  rdpi.CreateTime,
		UpdateTime:  rdpi.UpdateTime,
		Type:        rdpi.Type,
		Schema:      rdpi.Schema,
		UiSchema:    rdpi.UiSchema,
		Builtin:     rdpi.Builtin,
	}

	if rdpi.MatchingRules != nil {
		// Empty slice is used for clearing the edge.
		_rd.Edges.MatchingRules = make([]*ResourceDefinitionMatchingRule, 0, len(rdpi.MatchingRules))
	}
	for j := range rdpi.MatchingRules {
		if rdpi.MatchingRules[j] == nil {
			continue
		}
		_rd.Edges.MatchingRules = append(_rd.Edges.MatchingRules,
			rdpi.MatchingRules[j].Model())
	}
	return _rd
}

// Model returns the ResourceDefinition patched entity,
// after validating.
func (rdpi *ResourceDefinitionPatchInput) Model() *ResourceDefinition {
	if rdpi == nil {
		return nil
	}

	return rdpi.patchedEntity
}

// Validate checks the ResourceDefinitionPatchInput entity.
func (rdpi *ResourceDefinitionPatchInput) Validate() error {
	if rdpi == nil {
		return errors.New("nil receiver")
	}

	return rdpi.ValidateWith(rdpi.inputConfig.Context, rdpi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceDefinitionPatchInput entity with the given context and client set.
func (rdpi *ResourceDefinitionPatchInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := rdpi.ResourceDefinitionQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	q := cs.ResourceDefinitions().Query()

	for i := range rdpi.MatchingRules {
		if rdpi.MatchingRules[i] == nil {
			continue
		}

		if err := rdpi.MatchingRules[i].ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rdpi.MatchingRules[i] = nil
			}
		}
	}

	if rdpi.Refer != nil {
		if rdpi.Refer.IsID() {
			q.Where(
				resourcedefinition.ID(rdpi.Refer.ID()))
		} else if refers := rdpi.Refer.Split(1); len(refers) == 1 {
			q.Where(
				resourcedefinition.Name(refers[0].String()))
		} else {
			return errors.New("invalid identify refer of resourcedefinition")
		}
	} else if rdpi.ID != "" {
		q.Where(
			resourcedefinition.ID(rdpi.ID))
	} else if rdpi.Name != "" {
		q.Where(
			resourcedefinition.Name(rdpi.Name))
	} else {
		return errors.New("invalid identify of resourcedefinition")
	}

	q.Select(
		resourcedefinition.WithoutFields(
			resourcedefinition.FieldAnnotations,
			resourcedefinition.FieldCreateTime,
			resourcedefinition.FieldUpdateTime,
			resourcedefinition.FieldSchema,
			resourcedefinition.FieldBuiltin,
		)...,
	)

	var e *ResourceDefinition
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*ResourceDefinition)
		}
	}

	_pm := rdpi.PatchModel()

	_po, err := json.PatchObject(*e, *_pm)
	if err != nil {
		return err
	}

	_obj := _po.(*ResourceDefinition)

	if e.Name != _obj.Name {
		return errors.New("field name is immutable")
	}
	if !reflect.DeepEqual(e.CreateTime, _obj.CreateTime) {
		return errors.New("field createTime is immutable")
	}
	if e.Type != _obj.Type {
		return errors.New("field type is immutable")
	}
	if e.Builtin != _obj.Builtin {
		return errors.New("field builtin is immutable")
	}

	rdpi.patchedEntity = _obj
	return nil
}

// ResourceDefinitionQueryInput holds the query input of the ResourceDefinition entity,
// please tags with `path:",inline"` if embedding.
type ResourceDefinitionQueryInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Refer holds the route path reference of the ResourceDefinition entity.
	Refer *object.Refer `path:"resourcedefinition,default=" query:"-" json:"-"`
	// ID of the ResourceDefinition entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the ResourceDefinition entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// Model returns the ResourceDefinition entity for querying,
// after validating.
func (rdqi *ResourceDefinitionQueryInput) Model() *ResourceDefinition {
	if rdqi == nil {
		return nil
	}

	return &ResourceDefinition{
		ID:   rdqi.ID,
		Name: rdqi.Name,
	}
}

// Validate checks the ResourceDefinitionQueryInput entity.
func (rdqi *ResourceDefinitionQueryInput) Validate() error {
	if rdqi == nil {
		return errors.New("nil receiver")
	}

	return rdqi.ValidateWith(rdqi.inputConfig.Context, rdqi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceDefinitionQueryInput entity with the given context and client set.
func (rdqi *ResourceDefinitionQueryInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rdqi == nil {
		return errors.New("nil receiver")
	}

	if rdqi.Refer != nil && *rdqi.Refer == "" {
		return fmt.Errorf("model: %s : %w", resourcedefinition.Label, ErrBlankResourceRefer)
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceDefinitions().Query()

	if rdqi.Refer != nil {
		if rdqi.Refer.IsID() {
			q.Where(
				resourcedefinition.ID(rdqi.Refer.ID()))
		} else if refers := rdqi.Refer.Split(1); len(refers) == 1 {
			q.Where(
				resourcedefinition.Name(refers[0].String()))
		} else {
			return errors.New("invalid identify refer of resourcedefinition")
		}
	} else if rdqi.ID != "" {
		q.Where(
			resourcedefinition.ID(rdqi.ID))
	} else if rdqi.Name != "" {
		q.Where(
			resourcedefinition.Name(rdqi.Name))
	} else {
		return errors.New("invalid identify of resourcedefinition")
	}

	q.Select(
		resourcedefinition.FieldID,
		resourcedefinition.FieldName,
	)

	var e *ResourceDefinition
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*ResourceDefinition)
		}
	}

	rdqi.ID = e.ID
	rdqi.Name = e.Name
	return nil
}

// ResourceDefinitionQueryInputs holds the query input of the ResourceDefinition entities,
// please tags with `path:",inline" query:",inline"` if embedding.
type ResourceDefinitionQueryInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`
}

// Validate checks the ResourceDefinitionQueryInputs entity.
func (rdqi *ResourceDefinitionQueryInputs) Validate() error {
	if rdqi == nil {
		return errors.New("nil receiver")
	}

	return rdqi.ValidateWith(rdqi.inputConfig.Context, rdqi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceDefinitionQueryInputs entity with the given context and client set.
func (rdqi *ResourceDefinitionQueryInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rdqi == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// ResourceDefinitionUpdateInput holds the modification input of the ResourceDefinition entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceDefinitionUpdateInput struct {
	ResourceDefinitionQueryInput `path:",inline" query:"-" json:"-"`

	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// UI schema of the resource definition.
	UiSchema *types.UISchema `path:"-" query:"-" json:"uiSchema,omitempty"`

	// MatchingRules indicates replacing the stale ResourceDefinitionMatchingRule entities.
	MatchingRules []*ResourceDefinitionMatchingRuleCreateInput `uri:"-" query:"-" json:"matchingRules,omitempty"`
}

// Model returns the ResourceDefinition entity for modifying,
// after validating.
func (rdui *ResourceDefinitionUpdateInput) Model() *ResourceDefinition {
	if rdui == nil {
		return nil
	}

	_rd := &ResourceDefinition{
		ID:          rdui.ID,
		Name:        rdui.Name,
		Description: rdui.Description,
		Labels:      rdui.Labels,
		UiSchema:    rdui.UiSchema,
	}

	if rdui.MatchingRules != nil {
		// Empty slice is used for clearing the edge.
		_rd.Edges.MatchingRules = make([]*ResourceDefinitionMatchingRule, 0, len(rdui.MatchingRules))
	}
	for j := range rdui.MatchingRules {
		if rdui.MatchingRules[j] == nil {
			continue
		}
		_rd.Edges.MatchingRules = append(_rd.Edges.MatchingRules,
			rdui.MatchingRules[j].Model())
	}
	return _rd
}

// Validate checks the ResourceDefinitionUpdateInput entity.
func (rdui *ResourceDefinitionUpdateInput) Validate() error {
	if rdui == nil {
		return errors.New("nil receiver")
	}

	return rdui.ValidateWith(rdui.inputConfig.Context, rdui.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceDefinitionUpdateInput entity with the given context and client set.
func (rdui *ResourceDefinitionUpdateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := rdui.ResourceDefinitionQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	for i := range rdui.MatchingRules {
		if rdui.MatchingRules[i] == nil {
			continue
		}

		if err := rdui.MatchingRules[i].ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rdui.MatchingRules[i] = nil
			}
		}
	}

	return nil
}

// ResourceDefinitionUpdateInputs holds the modification input item of the ResourceDefinition entities.
type ResourceDefinitionUpdateInputsItem struct {
	// ID of the ResourceDefinition entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the ResourceDefinition entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`

	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// UI schema of the resource definition.
	UiSchema *types.UISchema `path:"-" query:"-" json:"uiSchema,omitempty"`

	// MatchingRules indicates replacing the stale ResourceDefinitionMatchingRule entities.
	MatchingRules []*ResourceDefinitionMatchingRuleCreateInput `uri:"-" query:"-" json:"matchingRules,omitempty"`
}

// ValidateWith checks the ResourceDefinitionUpdateInputsItem entity with the given context and client set.
func (rdui *ResourceDefinitionUpdateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rdui == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range rdui.MatchingRules {
		if rdui.MatchingRules[i] == nil {
			continue
		}

		if err := rdui.MatchingRules[i].ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rdui.MatchingRules[i] = nil
			}
		}
	}

	return nil
}

// ResourceDefinitionUpdateInputs holds the modification input of the ResourceDefinition entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceDefinitionUpdateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceDefinitionUpdateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceDefinition entities for modifying,
// after validating.
func (rdui *ResourceDefinitionUpdateInputs) Model() []*ResourceDefinition {
	if rdui == nil || len(rdui.Items) == 0 {
		return nil
	}

	_rds := make([]*ResourceDefinition, len(rdui.Items))

	for i := range rdui.Items {
		_rd := &ResourceDefinition{
			ID:          rdui.Items[i].ID,
			Name:        rdui.Items[i].Name,
			Description: rdui.Items[i].Description,
			Labels:      rdui.Items[i].Labels,
			UiSchema:    rdui.Items[i].UiSchema,
		}

		if rdui.Items[i].MatchingRules != nil {
			// Empty slice is used for clearing the edge.
			_rd.Edges.MatchingRules = make([]*ResourceDefinitionMatchingRule, 0, len(rdui.Items[i].MatchingRules))
		}
		for j := range rdui.Items[i].MatchingRules {
			if rdui.Items[i].MatchingRules[j] == nil {
				continue
			}
			_rd.Edges.MatchingRules = append(_rd.Edges.MatchingRules,
				rdui.Items[i].MatchingRules[j].Model())
		}

		_rds[i] = _rd
	}

	return _rds
}

// IDs returns the ID list of the ResourceDefinition entities for modifying,
// after validating.
func (rdui *ResourceDefinitionUpdateInputs) IDs() []object.ID {
	if rdui == nil || len(rdui.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(rdui.Items))
	for i := range rdui.Items {
		ids[i] = rdui.Items[i].ID
	}
	return ids
}

// Validate checks the ResourceDefinitionUpdateInputs entity.
func (rdui *ResourceDefinitionUpdateInputs) Validate() error {
	if rdui == nil {
		return errors.New("nil receiver")
	}

	return rdui.ValidateWith(rdui.inputConfig.Context, rdui.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceDefinitionUpdateInputs entity with the given context and client set.
func (rdui *ResourceDefinitionUpdateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rdui == nil {
		return errors.New("nil receiver")
	}

	if len(rdui.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceDefinitions().Query()

	ids := make([]object.ID, 0, len(rdui.Items))
	ors := make([]predicate.ResourceDefinition, 0, len(rdui.Items))
	indexers := make(map[any][]int)

	for i := range rdui.Items {
		if rdui.Items[i] == nil {
			return errors.New("nil item")
		}

		if rdui.Items[i].ID != "" {
			ids = append(ids, rdui.Items[i].ID)
			ors = append(ors, resourcedefinition.ID(rdui.Items[i].ID))
			indexers[rdui.Items[i].ID] = append(indexers[rdui.Items[i].ID], i)
		} else if rdui.Items[i].Name != "" {
			ors = append(ors, resourcedefinition.And(
				resourcedefinition.Name(rdui.Items[i].Name)))
			indexerKey := fmt.Sprint("/", rdui.Items[i].Name)
			indexers[indexerKey] = append(indexers[indexerKey], i)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	p := resourcedefinition.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = resourcedefinition.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			resourcedefinition.FieldID,
			resourcedefinition.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		indexer := indexers[es[i].ID]
		if indexer == nil {
			indexerKey := fmt.Sprint("/", es[i].Name)
			indexer = indexers[indexerKey]
		}
		for _, j := range indexer {
			rdui.Items[j].ID = es[i].ID
			rdui.Items[j].Name = es[i].Name
		}
	}

	for i := range rdui.Items {
		if err := rdui.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ResourceDefinitionOutput holds the output of the ResourceDefinition entity.
type ResourceDefinitionOutput struct {
	ID          object.ID         `json:"id,omitempty"`
	Name        string            `json:"name,omitempty"`
	Description string            `json:"description,omitempty"`
	Labels      map[string]string `json:"labels,omitempty"`
	CreateTime  *time.Time        `json:"createTime,omitempty"`
	UpdateTime  *time.Time        `json:"updateTime,omitempty"`
	Type        string            `json:"type,cli-table-column,omitempty"`
	Schema      types.Schema      `json:"schema,omitempty"`
	UiSchema    *types.UISchema   `json:"uiSchema,omitempty"`
	Builtin     bool              `json:"builtin,cli-table-column,omitempty"`

	MatchingRules []*ResourceDefinitionMatchingRuleOutput `json:"matchingRules,omitempty"`
}

// View returns the output of ResourceDefinition entity.
func (_rd *ResourceDefinition) View() *ResourceDefinitionOutput {
	return ExposeResourceDefinition(_rd)
}

// View returns the output of ResourceDefinition entities.
func (_rds ResourceDefinitions) View() []*ResourceDefinitionOutput {
	return ExposeResourceDefinitions(_rds)
}

// ExposeResourceDefinition converts the ResourceDefinition to ResourceDefinitionOutput.
func ExposeResourceDefinition(_rd *ResourceDefinition) *ResourceDefinitionOutput {
	if _rd == nil {
		return nil
	}

	rdo := &ResourceDefinitionOutput{
		ID:          _rd.ID,
		Name:        _rd.Name,
		Description: _rd.Description,
		Labels:      _rd.Labels,
		CreateTime:  _rd.CreateTime,
		UpdateTime:  _rd.UpdateTime,
		Type:        _rd.Type,
		Schema:      _rd.Schema,
		UiSchema:    _rd.UiSchema,
		Builtin:     _rd.Builtin,
	}

	if _rd.Edges.MatchingRules != nil {
		rdo.MatchingRules = ExposeResourceDefinitionMatchingRules(_rd.Edges.MatchingRules)
	}
	return rdo
}

// ExposeResourceDefinitions converts the ResourceDefinition slice to ResourceDefinitionOutput pointer slice.
func ExposeResourceDefinitions(_rds []*ResourceDefinition) []*ResourceDefinitionOutput {
	if len(_rds) == 0 {
		return nil
	}

	rdos := make([]*ResourceDefinitionOutput, len(_rds))
	for i := range _rds {
		rdos[i] = ExposeResourceDefinition(_rds[i])
	}
	return rdos
}
