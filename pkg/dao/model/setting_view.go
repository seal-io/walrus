// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/seal-io/walrus/pkg/dao/model/predicate"
	"github.com/seal-io/walrus/pkg/dao/model/setting"
	"github.com/seal-io/walrus/pkg/dao/types/crypto"
	"github.com/seal-io/walrus/pkg/dao/types/object"
)

// SettingCreateInput holds the creation input of the Setting entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type SettingCreateInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// The value of system setting, store in string.
	Value crypto.String `path:"-" query:"-" json:"value"`
}

// Model returns the Setting entity for creating,
// after validating.
func (sci *SettingCreateInput) Model() *Setting {
	if sci == nil {
		return nil
	}

	_s := &Setting{
		Value: sci.Value,
	}

	return _s
}

// Validate checks the SettingCreateInput entity.
func (sci *SettingCreateInput) Validate() error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	return sci.ValidateWith(sci.inputConfig.Context, sci.inputConfig.Client, nil)
}

// ValidateWith checks the SettingCreateInput entity with the given context and client set.
func (sci *SettingCreateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// SettingCreateInputs holds the creation input item of the Setting entities.
type SettingCreateInputsItem struct {
	// The value of system setting, store in string.
	Value crypto.String `path:"-" query:"-" json:"value"`
}

// ValidateWith checks the SettingCreateInputsItem entity with the given context and client set.
func (sci *SettingCreateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// SettingCreateInputs holds the creation input of the Setting entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type SettingCreateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*SettingCreateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Setting entities for creating,
// after validating.
func (sci *SettingCreateInputs) Model() []*Setting {
	if sci == nil || len(sci.Items) == 0 {
		return nil
	}

	_ss := make([]*Setting, len(sci.Items))

	for i := range sci.Items {
		_s := &Setting{
			Value: sci.Items[i].Value,
		}

		_ss[i] = _s
	}

	return _ss
}

// Validate checks the SettingCreateInputs entity .
func (sci *SettingCreateInputs) Validate() error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	return sci.ValidateWith(sci.inputConfig.Context, sci.inputConfig.Client, nil)
}

// ValidateWith checks the SettingCreateInputs entity with the given context and client set.
func (sci *SettingCreateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	if len(sci.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range sci.Items {
		if sci.Items[i] == nil {
			continue
		}

		if err := sci.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// SettingDeleteInput holds the deletion input of the Setting entity,
// please tags with `path:",inline"` if embedding.
type SettingDeleteInput struct {
	SettingQueryInput `path:",inline"`
}

// SettingDeleteInputs holds the deletion input item of the Setting entities.
type SettingDeleteInputsItem struct {
	// ID of the Setting entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Setting entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// SettingDeleteInputs holds the deletion input of the Setting entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type SettingDeleteInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*SettingDeleteInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Setting entities for deleting,
// after validating.
func (sdi *SettingDeleteInputs) Model() []*Setting {
	if sdi == nil || len(sdi.Items) == 0 {
		return nil
	}

	_ss := make([]*Setting, len(sdi.Items))
	for i := range sdi.Items {
		_ss[i] = &Setting{
			ID: sdi.Items[i].ID,
		}
	}
	return _ss
}

// IDs returns the ID list of the Setting entities for deleting,
// after validating.
func (sdi *SettingDeleteInputs) IDs() []object.ID {
	if sdi == nil || len(sdi.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(sdi.Items))
	for i := range sdi.Items {
		ids[i] = sdi.Items[i].ID
	}
	return ids
}

// Validate checks the SettingDeleteInputs entity.
func (sdi *SettingDeleteInputs) Validate() error {
	if sdi == nil {
		return errors.New("nil receiver")
	}

	return sdi.ValidateWith(sdi.inputConfig.Context, sdi.inputConfig.Client, nil)
}

// ValidateWith checks the SettingDeleteInputs entity with the given context and client set.
func (sdi *SettingDeleteInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if sdi == nil {
		return errors.New("nil receiver")
	}

	if len(sdi.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Settings().Query()

	ids := make([]object.ID, 0, len(sdi.Items))
	ors := make([]predicate.Setting, 0, len(sdi.Items))
	indexers := make(map[any][]int)

	for i := range sdi.Items {
		if sdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if sdi.Items[i].ID != "" {
			ids = append(ids, sdi.Items[i].ID)
			ors = append(ors, setting.ID(sdi.Items[i].ID))
			indexers[sdi.Items[i].ID] = append(indexers[sdi.Items[i].ID], i)
		} else if sdi.Items[i].Name != "" {
			ors = append(ors, setting.And(
				setting.Name(sdi.Items[i].Name)))
			indexerKey := fmt.Sprint("/", sdi.Items[i].Name)
			indexers[indexerKey] = append(indexers[indexerKey], i)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	p := setting.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = setting.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			setting.FieldID,
			setting.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		indexer := indexers[es[i].ID]
		if indexer == nil {
			indexerKey := fmt.Sprint("/", es[i].Name)
			indexer = indexers[indexerKey]
		}
		for _, j := range indexer {
			sdi.Items[j].ID = es[i].ID
			sdi.Items[j].Name = es[i].Name
		}
	}

	return nil
}

// SettingQueryInput holds the query input of the Setting entity,
// please tags with `path:",inline"` if embedding.
type SettingQueryInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Refer holds the route path reference of the Setting entity.
	Refer *object.Refer `path:"setting,default=" query:"-" json:"-"`
	// ID of the Setting entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Setting entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// Model returns the Setting entity for querying,
// after validating.
func (sqi *SettingQueryInput) Model() *Setting {
	if sqi == nil {
		return nil
	}

	return &Setting{
		ID:   sqi.ID,
		Name: sqi.Name,
	}
}

// Validate checks the SettingQueryInput entity.
func (sqi *SettingQueryInput) Validate() error {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	return sqi.ValidateWith(sqi.inputConfig.Context, sqi.inputConfig.Client, nil)
}

// ValidateWith checks the SettingQueryInput entity with the given context and client set.
func (sqi *SettingQueryInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	if sqi.Refer != nil && *sqi.Refer == "" {
		return fmt.Errorf("model: %s : %w", setting.Label, ErrBlankResourceRefer)
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Settings().Query()

	if sqi.Refer != nil {
		if sqi.Refer.IsID() {
			q.Where(
				setting.ID(sqi.Refer.ID()))
		} else if refers := sqi.Refer.Split(1); len(refers) == 1 {
			q.Where(
				setting.Name(refers[0].String()))
		} else {
			return errors.New("invalid identify refer of setting")
		}
	} else if sqi.ID != "" {
		q.Where(
			setting.ID(sqi.ID))
	} else if sqi.Name != "" {
		q.Where(
			setting.Name(sqi.Name))
	} else {
		return errors.New("invalid identify of setting")
	}

	q.Select(
		setting.FieldID,
		setting.FieldName,
	)

	var e *Setting
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*Setting)
		}
	}

	sqi.ID = e.ID
	sqi.Name = e.Name
	return nil
}

// SettingQueryInputs holds the query input of the Setting entities,
// please tags with `path:",inline" query:",inline"` if embedding.
type SettingQueryInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`
}

// Validate checks the SettingQueryInputs entity.
func (sqi *SettingQueryInputs) Validate() error {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	return sqi.ValidateWith(sqi.inputConfig.Context, sqi.inputConfig.Client, nil)
}

// ValidateWith checks the SettingQueryInputs entity with the given context and client set.
func (sqi *SettingQueryInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// SettingUpdateInput holds the modification input of the Setting entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type SettingUpdateInput struct {
	SettingQueryInput `path:",inline" query:"-" json:"-"`

	// The value of system setting, store in string.
	Value crypto.String `path:"-" query:"-" json:"value,omitempty"`
}

// Model returns the Setting entity for modifying,
// after validating.
func (sui *SettingUpdateInput) Model() *Setting {
	if sui == nil {
		return nil
	}

	_s := &Setting{
		ID:    sui.ID,
		Name:  sui.Name,
		Value: sui.Value,
	}

	return _s
}

// Validate checks the SettingUpdateInput entity.
func (sui *SettingUpdateInput) Validate() error {
	if sui == nil {
		return errors.New("nil receiver")
	}

	return sui.ValidateWith(sui.inputConfig.Context, sui.inputConfig.Client, nil)
}

// ValidateWith checks the SettingUpdateInput entity with the given context and client set.
func (sui *SettingUpdateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := sui.SettingQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	return nil
}

// SettingUpdateInputs holds the modification input item of the Setting entities.
type SettingUpdateInputsItem struct {
	// ID of the Setting entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Setting entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`

	// The value of system setting, store in string.
	Value crypto.String `path:"-" query:"-" json:"value"`
}

// ValidateWith checks the SettingUpdateInputsItem entity with the given context and client set.
func (sui *SettingUpdateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if sui == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// SettingUpdateInputs holds the modification input of the Setting entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type SettingUpdateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*SettingUpdateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Setting entities for modifying,
// after validating.
func (sui *SettingUpdateInputs) Model() []*Setting {
	if sui == nil || len(sui.Items) == 0 {
		return nil
	}

	_ss := make([]*Setting, len(sui.Items))

	for i := range sui.Items {
		_s := &Setting{
			ID:    sui.Items[i].ID,
			Name:  sui.Items[i].Name,
			Value: sui.Items[i].Value,
		}

		_ss[i] = _s
	}

	return _ss
}

// IDs returns the ID list of the Setting entities for modifying,
// after validating.
func (sui *SettingUpdateInputs) IDs() []object.ID {
	if sui == nil || len(sui.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(sui.Items))
	for i := range sui.Items {
		ids[i] = sui.Items[i].ID
	}
	return ids
}

// Validate checks the SettingUpdateInputs entity.
func (sui *SettingUpdateInputs) Validate() error {
	if sui == nil {
		return errors.New("nil receiver")
	}

	return sui.ValidateWith(sui.inputConfig.Context, sui.inputConfig.Client, nil)
}

// ValidateWith checks the SettingUpdateInputs entity with the given context and client set.
func (sui *SettingUpdateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if sui == nil {
		return errors.New("nil receiver")
	}

	if len(sui.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Settings().Query()

	ids := make([]object.ID, 0, len(sui.Items))
	ors := make([]predicate.Setting, 0, len(sui.Items))
	indexers := make(map[any][]int)

	for i := range sui.Items {
		if sui.Items[i] == nil {
			return errors.New("nil item")
		}

		if sui.Items[i].ID != "" {
			ids = append(ids, sui.Items[i].ID)
			ors = append(ors, setting.ID(sui.Items[i].ID))
			indexers[sui.Items[i].ID] = append(indexers[sui.Items[i].ID], i)
		} else if sui.Items[i].Name != "" {
			ors = append(ors, setting.And(
				setting.Name(sui.Items[i].Name)))
			indexerKey := fmt.Sprint("/", sui.Items[i].Name)
			indexers[indexerKey] = append(indexers[indexerKey], i)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	p := setting.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = setting.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			setting.FieldID,
			setting.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		indexer := indexers[es[i].ID]
		if indexer == nil {
			indexerKey := fmt.Sprint("/", es[i].Name)
			indexer = indexers[indexerKey]
		}
		for _, j := range indexer {
			sui.Items[j].ID = es[i].ID
			sui.Items[j].Name = es[i].Name
		}
	}

	for i := range sui.Items {
		if err := sui.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// SettingOutput holds the output of the Setting entity.
type SettingOutput struct {
	ID         object.ID     `json:"id,omitempty"`
	CreateTime *time.Time    `json:"createTime,omitempty"`
	UpdateTime *time.Time    `json:"updateTime,omitempty"`
	Name       string        `json:"name,omitempty"`
	Value      crypto.String `json:"value,omitempty"`
	Hidden     *bool         `json:"hidden,omitempty"`
	Editable   *bool         `json:"editable,omitempty"`
	Sensitive  *bool         `json:"sensitive,omitempty"`
	Configured bool          `json:"configured,omitempty"`
}

// View returns the output of Setting entity.
func (_s *Setting) View() *SettingOutput {
	return ExposeSetting(_s)
}

// View returns the output of Setting entities.
func (_ss Settings) View() []*SettingOutput {
	return ExposeSettings(_ss)
}

// ExposeSetting converts the Setting to SettingOutput.
func ExposeSetting(_s *Setting) *SettingOutput {
	if _s == nil {
		return nil
	}

	so := &SettingOutput{
		ID:         _s.ID,
		CreateTime: _s.CreateTime,
		UpdateTime: _s.UpdateTime,
		Name:       _s.Name,
		Value:      _s.Value,
		Hidden:     _s.Hidden,
		Editable:   _s.Editable,
		Sensitive:  _s.Sensitive,
		Configured: _s.Configured,
	}

	return so
}

// ExposeSettings converts the Setting slice to SettingOutput pointer slice.
func ExposeSettings(_ss []*Setting) []*SettingOutput {
	if len(_ss) == 0 {
		return nil
	}

	sos := make([]*SettingOutput, len(_ss))
	for i := range _ss {
		sos[i] = ExposeSetting(_ss[i])
	}
	return sos
}
