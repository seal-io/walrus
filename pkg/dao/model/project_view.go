// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/seal-io/walrus/pkg/dao/model/predicate"
	"github.com/seal-io/walrus/pkg/dao/model/project"
	"github.com/seal-io/walrus/pkg/dao/schema/intercept"
	"github.com/seal-io/walrus/pkg/dao/types/object"
	"github.com/seal-io/walrus/utils/json"
)

// ProjectCreateInput holds the creation input of the Project entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ProjectCreateInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
}

// Model returns the Project entity for creating,
// after validating.
func (pci *ProjectCreateInput) Model() *Project {
	if pci == nil {
		return nil
	}

	_p := &Project{
		Name:        pci.Name,
		Description: pci.Description,
		Labels:      pci.Labels,
	}

	return _p
}

// Validate checks the ProjectCreateInput entity.
func (pci *ProjectCreateInput) Validate() error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	return pci.ValidateWith(pci.inputConfig.Context, pci.inputConfig.Client, nil)
}

// ValidateWith checks the ProjectCreateInput entity with the given context and client set.
func (pci *ProjectCreateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// ProjectCreateInputs holds the creation input item of the Project entities.
type ProjectCreateInputsItem struct {
	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
}

// ValidateWith checks the ProjectCreateInputsItem entity with the given context and client set.
func (pci *ProjectCreateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// ProjectCreateInputs holds the creation input of the Project entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ProjectCreateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ProjectCreateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Project entities for creating,
// after validating.
func (pci *ProjectCreateInputs) Model() []*Project {
	if pci == nil || len(pci.Items) == 0 {
		return nil
	}

	_ps := make([]*Project, len(pci.Items))

	for i := range pci.Items {
		_p := &Project{
			Name:        pci.Items[i].Name,
			Description: pci.Items[i].Description,
			Labels:      pci.Items[i].Labels,
		}

		_ps[i] = _p
	}

	return _ps
}

// Validate checks the ProjectCreateInputs entity .
func (pci *ProjectCreateInputs) Validate() error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	return pci.ValidateWith(pci.inputConfig.Context, pci.inputConfig.Client, nil)
}

// ValidateWith checks the ProjectCreateInputs entity with the given context and client set.
func (pci *ProjectCreateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pci == nil {
		return errors.New("nil receiver")
	}

	if len(pci.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range pci.Items {
		if pci.Items[i] == nil {
			continue
		}

		if err := pci.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ProjectDeleteInput holds the deletion input of the Project entity,
// please tags with `path:",inline"` if embedding.
type ProjectDeleteInput struct {
	ProjectQueryInput `path:",inline"`
}

// ProjectDeleteInputs holds the deletion input item of the Project entities.
type ProjectDeleteInputsItem struct {
	// ID of the Project entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Project entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// ProjectDeleteInputs holds the deletion input of the Project entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ProjectDeleteInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ProjectDeleteInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Project entities for deleting,
// after validating.
func (pdi *ProjectDeleteInputs) Model() []*Project {
	if pdi == nil || len(pdi.Items) == 0 {
		return nil
	}

	_ps := make([]*Project, len(pdi.Items))
	for i := range pdi.Items {
		_ps[i] = &Project{
			ID: pdi.Items[i].ID,
		}
	}
	return _ps
}

// IDs returns the ID list of the Project entities for deleting,
// after validating.
func (pdi *ProjectDeleteInputs) IDs() []object.ID {
	if pdi == nil || len(pdi.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(pdi.Items))
	for i := range pdi.Items {
		ids[i] = pdi.Items[i].ID
	}
	return ids
}

// Validate checks the ProjectDeleteInputs entity.
func (pdi *ProjectDeleteInputs) Validate() error {
	if pdi == nil {
		return errors.New("nil receiver")
	}

	return pdi.ValidateWith(pdi.inputConfig.Context, pdi.inputConfig.Client, nil)
}

// ValidateWith checks the ProjectDeleteInputs entity with the given context and client set.
func (pdi *ProjectDeleteInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pdi == nil {
		return errors.New("nil receiver")
	}

	if len(pdi.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Projects().Query()

	ids := make([]object.ID, 0, len(pdi.Items))
	ors := make([]predicate.Project, 0, len(pdi.Items))
	indexers := make(map[any][]int)

	for i := range pdi.Items {
		if pdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if pdi.Items[i].ID != "" {
			ids = append(ids, pdi.Items[i].ID)
			ors = append(ors, project.ID(pdi.Items[i].ID))
			indexers[pdi.Items[i].ID] = append(indexers[pdi.Items[i].ID], i)
		} else if pdi.Items[i].Name != "" {
			ors = append(ors, project.And(
				project.Name(pdi.Items[i].Name)))
			indexerKey := fmt.Sprint("/", pdi.Items[i].Name)
			indexers[indexerKey] = append(indexers[indexerKey], i)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	ctx = valueContext(ctx, intercept.WithProjectInterceptor)

	p := project.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = project.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			project.FieldID,
			project.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		indexer := indexers[es[i].ID]
		if indexer == nil {
			indexerKey := fmt.Sprint("/", es[i].Name)
			indexer = indexers[indexerKey]
		}
		for _, j := range indexer {
			pdi.Items[j].ID = es[i].ID
			pdi.Items[j].Name = es[i].Name
		}
	}

	return nil
}

// ProjectPatchInput holds the patch input of the Project entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ProjectPatchInput struct {
	ProjectQueryInput `path:",inline" query:"-" json:"-"`

	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name,omitempty"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
	// Annotations holds the value of the "annotations" field.
	Annotations map[string]string `path:"-" query:"-" json:"annotations,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime *time.Time `path:"-" query:"-" json:"createTime,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime *time.Time `path:"-" query:"-" json:"updateTime,omitempty"`

	patchedEntity *Project `path:"-" query:"-" json:"-"`
}

// PatchModel returns the Project partition entity for patching.
func (ppi *ProjectPatchInput) PatchModel() *Project {
	if ppi == nil {
		return nil
	}

	_p := &Project{
		Name:        ppi.Name,
		Description: ppi.Description,
		Labels:      ppi.Labels,
		Annotations: ppi.Annotations,
		CreateTime:  ppi.CreateTime,
		UpdateTime:  ppi.UpdateTime,
	}

	return _p
}

// Model returns the Project patched entity,
// after validating.
func (ppi *ProjectPatchInput) Model() *Project {
	if ppi == nil {
		return nil
	}

	return ppi.patchedEntity
}

// Validate checks the ProjectPatchInput entity.
func (ppi *ProjectPatchInput) Validate() error {
	if ppi == nil {
		return errors.New("nil receiver")
	}

	return ppi.ValidateWith(ppi.inputConfig.Context, ppi.inputConfig.Client, nil)
}

// ValidateWith checks the ProjectPatchInput entity with the given context and client set.
func (ppi *ProjectPatchInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := ppi.ProjectQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	q := cs.Projects().Query()

	if ppi.Refer != nil {
		if ppi.Refer.IsID() {
			q.Where(
				project.ID(ppi.Refer.ID()))
		} else if refers := ppi.Refer.Split(1); len(refers) == 1 {
			q.Where(
				project.Name(refers[0].String()))
		} else {
			return errors.New("invalid identify refer of project")
		}
	} else if ppi.ID != "" {
		q.Where(
			project.ID(ppi.ID))
	} else if ppi.Name != "" {
		q.Where(
			project.Name(ppi.Name))
	} else {
		return errors.New("invalid identify of project")
	}

	ctx = valueContext(ctx, intercept.WithProjectInterceptor)

	q.Select(
		project.WithoutFields(
			project.FieldAnnotations,
			project.FieldCreateTime,
			project.FieldUpdateTime,
		)...,
	)

	var e *Project
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*Project)
		}
	}

	_pm := ppi.PatchModel()

	_po, err := json.PatchObject(*e, *_pm)
	if err != nil {
		return err
	}

	_obj := _po.(*Project)

	if e.Name != _obj.Name {
		return errors.New("field name is immutable")
	}
	if !reflect.DeepEqual(e.CreateTime, _obj.CreateTime) {
		return errors.New("field createTime is immutable")
	}

	ppi.patchedEntity = _obj
	return nil
}

// ProjectQueryInput holds the query input of the Project entity,
// please tags with `path:",inline"` if embedding.
type ProjectQueryInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Refer holds the route path reference of the Project entity.
	Refer *object.Refer `path:"project,default=" query:"-" json:"-"`
	// ID of the Project entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Project entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// Model returns the Project entity for querying,
// after validating.
func (pqi *ProjectQueryInput) Model() *Project {
	if pqi == nil {
		return nil
	}

	return &Project{
		ID:   pqi.ID,
		Name: pqi.Name,
	}
}

// Validate checks the ProjectQueryInput entity.
func (pqi *ProjectQueryInput) Validate() error {
	if pqi == nil {
		return errors.New("nil receiver")
	}

	return pqi.ValidateWith(pqi.inputConfig.Context, pqi.inputConfig.Client, nil)
}

// ValidateWith checks the ProjectQueryInput entity with the given context and client set.
func (pqi *ProjectQueryInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pqi == nil {
		return errors.New("nil receiver")
	}

	if pqi.Refer != nil && *pqi.Refer == "" {
		return fmt.Errorf("model: %s : %w", project.Label, ErrBlankResourceRefer)
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Projects().Query()

	if pqi.Refer != nil {
		if pqi.Refer.IsID() {
			q.Where(
				project.ID(pqi.Refer.ID()))
		} else if refers := pqi.Refer.Split(1); len(refers) == 1 {
			q.Where(
				project.Name(refers[0].String()))
		} else {
			return errors.New("invalid identify refer of project")
		}
	} else if pqi.ID != "" {
		q.Where(
			project.ID(pqi.ID))
	} else if pqi.Name != "" {
		q.Where(
			project.Name(pqi.Name))
	} else {
		return errors.New("invalid identify of project")
	}

	ctx = valueContext(ctx, intercept.WithProjectInterceptor)

	q.Select(
		project.FieldID,
		project.FieldName,
	)

	var e *Project
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*Project)
		}
	}

	pqi.ID = e.ID
	pqi.Name = e.Name
	return nil
}

// ProjectQueryInputs holds the query input of the Project entities,
// please tags with `path:",inline" query:",inline"` if embedding.
type ProjectQueryInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`
}

// Validate checks the ProjectQueryInputs entity.
func (pqi *ProjectQueryInputs) Validate() error {
	if pqi == nil {
		return errors.New("nil receiver")
	}

	return pqi.ValidateWith(pqi.inputConfig.Context, pqi.inputConfig.Client, nil)
}

// ValidateWith checks the ProjectQueryInputs entity with the given context and client set.
func (pqi *ProjectQueryInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pqi == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// ProjectUpdateInput holds the modification input of the Project entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ProjectUpdateInput struct {
	ProjectQueryInput `path:",inline" query:"-" json:"-"`

	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
}

// Model returns the Project entity for modifying,
// after validating.
func (pui *ProjectUpdateInput) Model() *Project {
	if pui == nil {
		return nil
	}

	_p := &Project{
		ID:          pui.ID,
		Name:        pui.Name,
		Description: pui.Description,
		Labels:      pui.Labels,
	}

	return _p
}

// Validate checks the ProjectUpdateInput entity.
func (pui *ProjectUpdateInput) Validate() error {
	if pui == nil {
		return errors.New("nil receiver")
	}

	return pui.ValidateWith(pui.inputConfig.Context, pui.inputConfig.Client, nil)
}

// ValidateWith checks the ProjectUpdateInput entity with the given context and client set.
func (pui *ProjectUpdateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := pui.ProjectQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	return nil
}

// ProjectUpdateInputs holds the modification input item of the Project entities.
type ProjectUpdateInputsItem struct {
	// ID of the Project entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Project entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`

	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
}

// ValidateWith checks the ProjectUpdateInputsItem entity with the given context and client set.
func (pui *ProjectUpdateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pui == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// ProjectUpdateInputs holds the modification input of the Project entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ProjectUpdateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ProjectUpdateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Project entities for modifying,
// after validating.
func (pui *ProjectUpdateInputs) Model() []*Project {
	if pui == nil || len(pui.Items) == 0 {
		return nil
	}

	_ps := make([]*Project, len(pui.Items))

	for i := range pui.Items {
		_p := &Project{
			ID:          pui.Items[i].ID,
			Name:        pui.Items[i].Name,
			Description: pui.Items[i].Description,
			Labels:      pui.Items[i].Labels,
		}

		_ps[i] = _p
	}

	return _ps
}

// IDs returns the ID list of the Project entities for modifying,
// after validating.
func (pui *ProjectUpdateInputs) IDs() []object.ID {
	if pui == nil || len(pui.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(pui.Items))
	for i := range pui.Items {
		ids[i] = pui.Items[i].ID
	}
	return ids
}

// Validate checks the ProjectUpdateInputs entity.
func (pui *ProjectUpdateInputs) Validate() error {
	if pui == nil {
		return errors.New("nil receiver")
	}

	return pui.ValidateWith(pui.inputConfig.Context, pui.inputConfig.Client, nil)
}

// ValidateWith checks the ProjectUpdateInputs entity with the given context and client set.
func (pui *ProjectUpdateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if pui == nil {
		return errors.New("nil receiver")
	}

	if len(pui.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Projects().Query()

	ids := make([]object.ID, 0, len(pui.Items))
	ors := make([]predicate.Project, 0, len(pui.Items))
	indexers := make(map[any][]int)

	for i := range pui.Items {
		if pui.Items[i] == nil {
			return errors.New("nil item")
		}

		if pui.Items[i].ID != "" {
			ids = append(ids, pui.Items[i].ID)
			ors = append(ors, project.ID(pui.Items[i].ID))
			indexers[pui.Items[i].ID] = append(indexers[pui.Items[i].ID], i)
		} else if pui.Items[i].Name != "" {
			ors = append(ors, project.And(
				project.Name(pui.Items[i].Name)))
			indexerKey := fmt.Sprint("/", pui.Items[i].Name)
			indexers[indexerKey] = append(indexers[indexerKey], i)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	ctx = valueContext(ctx, intercept.WithProjectInterceptor)

	p := project.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = project.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			project.FieldID,
			project.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		indexer := indexers[es[i].ID]
		if indexer == nil {
			indexerKey := fmt.Sprint("/", es[i].Name)
			indexer = indexers[indexerKey]
		}
		for _, j := range indexer {
			pui.Items[j].ID = es[i].ID
			pui.Items[j].Name = es[i].Name
		}
	}

	for i := range pui.Items {
		if err := pui.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ProjectOutput holds the output of the Project entity.
type ProjectOutput struct {
	ID          object.ID         `json:"id,omitempty"`
	Name        string            `json:"name,omitempty"`
	Description string            `json:"description,omitempty"`
	Labels      map[string]string `json:"labels,omitempty"`
	CreateTime  *time.Time        `json:"createTime,omitempty"`
	UpdateTime  *time.Time        `json:"updateTime,omitempty"`
}

// View returns the output of Project entity.
func (_p *Project) View() *ProjectOutput {
	return ExposeProject(_p)
}

// View returns the output of Project entities.
func (_ps Projects) View() []*ProjectOutput {
	return ExposeProjects(_ps)
}

// ExposeProject converts the Project to ProjectOutput.
func ExposeProject(_p *Project) *ProjectOutput {
	if _p == nil {
		return nil
	}

	po := &ProjectOutput{
		ID:          _p.ID,
		Name:        _p.Name,
		Description: _p.Description,
		Labels:      _p.Labels,
		CreateTime:  _p.CreateTime,
		UpdateTime:  _p.UpdateTime,
	}

	return po
}

// ExposeProjects converts the Project slice to ProjectOutput pointer slice.
func ExposeProjects(_ps []*Project) []*ProjectOutput {
	if len(_ps) == 0 {
		return nil
	}

	pos := make([]*ProjectOutput, len(_ps))
	for i := range _ps {
		pos[i] = ExposeProject(_ps[i])
	}
	return pos
}
