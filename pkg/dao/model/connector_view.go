// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/connector"
	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/dao/types/crypto"
	"github.com/seal-io/seal/pkg/dao/types/object"
	"github.com/seal-io/seal/pkg/dao/types/status"
)

// ConnectorCreateInput holds the creation input of the Connector entity.
type ConnectorCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project *ProjectQueryInput `uri:",inline" query:"-" json:"project,omitempty"`

	Category            string                     `uri:"-" query:"-" json:"category"`
	EnableFinOps        bool                       `uri:"-" query:"-" json:"enableFinOps"`
	ConfigVersion       string                     `uri:"-" query:"-" json:"configVersion"`
	Type                string                     `uri:"-" query:"-" json:"type"`
	Name                string                     `uri:"-" query:"-" json:"name"`
	Description         string                     `uri:"-" query:"-" json:"description,omitempty"`
	Labels              map[string]string          `uri:"-" query:"-" json:"labels,omitempty"`
	ConfigData          crypto.Properties          `uri:"-" query:"-" json:"configData,omitempty"`
	FinOpsCustomPricing *types.FinOpsCustomPricing `uri:"-" query:"-" json:"finOpsCustomPricing,omitempty"`
}

// Model returns the Connector entity for creating,
// after validating.
func (cci *ConnectorCreateInput) Model() *Connector {
	if cci == nil {
		return nil
	}

	_c := &Connector{
		Category:            cci.Category,
		EnableFinOps:        cci.EnableFinOps,
		ConfigVersion:       cci.ConfigVersion,
		Type:                cci.Type,
		Name:                cci.Name,
		Description:         cci.Description,
		Labels:              cci.Labels,
		ConfigData:          cci.ConfigData,
		FinOpsCustomPricing: cci.FinOpsCustomPricing,
	}

	if cci.Project != nil {
		_c.ProjectID = cci.Project.ID
	}

	return _c
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cci *ConnectorCreateInput) Load() error {
	if cci == nil {
		return errors.New("nil receiver")
	}

	return cci.LoadWith(cci.inputConfig.Context, cci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cci *ConnectorCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cci == nil {
		return errors.New("nil receiver")
	}

	if cci.Project != nil {
		err = cci.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return nil
}

// ConnectorCreateInputs holds the creation input item of the Connector entities.
type ConnectorCreateInputsItem struct {
	Category            string                     `uri:"-" query:"-" json:"category"`
	EnableFinOps        bool                       `uri:"-" query:"-" json:"enableFinOps"`
	ConfigVersion       string                     `uri:"-" query:"-" json:"configVersion"`
	Type                string                     `uri:"-" query:"-" json:"type"`
	Name                string                     `uri:"-" query:"-" json:"name"`
	Description         string                     `uri:"-" query:"-" json:"description,omitempty"`
	Labels              map[string]string          `uri:"-" query:"-" json:"labels,omitempty"`
	ConfigData          crypto.Properties          `uri:"-" query:"-" json:"configData,omitempty"`
	FinOpsCustomPricing *types.FinOpsCustomPricing `uri:"-" query:"-" json:"finOpsCustomPricing,omitempty"`
}

// ConnectorCreateInputs holds the creation input of the Connector entities.
type ConnectorCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project *ProjectQueryInput `uri:",inline" query:"-" json:"project,omitempty"`

	Items []*ConnectorCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Connector entities for creating,
// after validating.
func (cci *ConnectorCreateInputs) Model() []*Connector {
	if cci == nil || len(cci.Items) == 0 {
		return nil
	}

	_cs := make([]*Connector, len(cci.Items))

	for i := range cci.Items {
		_c := &Connector{
			Category:            cci.Items[i].Category,
			EnableFinOps:        cci.Items[i].EnableFinOps,
			ConfigVersion:       cci.Items[i].ConfigVersion,
			Type:                cci.Items[i].Type,
			Name:                cci.Items[i].Name,
			Description:         cci.Items[i].Description,
			Labels:              cci.Items[i].Labels,
			ConfigData:          cci.Items[i].ConfigData,
			FinOpsCustomPricing: cci.Items[i].FinOpsCustomPricing,
		}

		if cci.Project != nil {
			_c.ProjectID = cci.Project.ID
		}

		_cs[i] = _c
	}

	return _cs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cci *ConnectorCreateInputs) Load() error {
	if cci == nil {
		return errors.New("nil receiver")
	}

	return cci.LoadWith(cci.inputConfig.Context, cci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cci *ConnectorCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cci == nil {
		return errors.New("nil receiver")
	}

	if len(cci.Items) == 0 {
		return errors.New("empty items")
	}

	if cci.Project != nil {
		err = cci.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectorDeleteInput holds the deletion input of the Connector entity.
type ConnectorDeleteInput = ConnectorQueryInput

// ConnectorDeleteInputs holds the deletion input item of the Connector entities.
type ConnectorDeleteInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`
}

// ConnectorDeleteInputs holds the deletion input of the Connector entities.
type ConnectorDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project *ProjectQueryInput `uri:",inline" query:"-" json:"project,omitempty"`

	Items []*ConnectorDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Connector entities for deleting,
// after validating.
func (cdi *ConnectorDeleteInputs) Model() []*Connector {
	if cdi == nil || len(cdi.Items) == 0 {
		return nil
	}

	_cs := make([]*Connector, len(cdi.Items))
	for i := range cdi.Items {
		_cs[i] = &Connector{
			ID: cdi.Items[i].ID,
		}
	}
	return _cs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cdi *ConnectorDeleteInputs) Load() error {
	if cdi == nil {
		return errors.New("nil receiver")
	}

	return cdi.LoadWith(cdi.inputConfig.Context, cdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cdi *ConnectorDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cdi == nil {
		return errors.New("nil receiver")
	}

	if len(cdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Connectors().Query()

	if cdi.Project != nil {
		err = cdi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			connector.ProjectID(cdi.Project.ID))
	}

	ids := make([]object.ID, 0, len(cdi.Items))

	for i := range cdi.Items {
		if cdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if cdi.Items[i].ID != "" {
			ids = append(ids, cdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(connector.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ConnectorQueryInput holds the query input of the Connector entity.
type ConnectorQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project *ProjectQueryInput `uri:",inline" query:"-" json:"project,omitempty"`

	Refer *object.Refer `uri:"connector,default=\"\"" query:"-" json:"-"`
	ID    object.ID     `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the Connector entity for querying,
// after validating.
func (cqi *ConnectorQueryInput) Model() *Connector {
	if cqi == nil {
		return nil
	}

	return &Connector{
		ID: cqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cqi *ConnectorQueryInput) Load() error {
	if cqi == nil {
		return errors.New("nil receiver")
	}

	return cqi.LoadWith(cqi.inputConfig.Context, cqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cqi *ConnectorQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cqi == nil {
		return errors.New("nil receiver")
	}

	if cqi.Refer != nil && *cqi.Refer == "" {
		return nil
	}

	q := cs.Connectors().Query()

	if cqi.Project != nil {
		err = cqi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			connector.ProjectID(cqi.Project.ID))
	} else {
		q.Where(
			connector.ProjectIDIsNil())
	}

	if cqi.Refer != nil {
		if cqi.Refer.IsID() {
			q.Where(
				connector.ID(cqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of connector")
		}
	} else if cqi.ID != "" {
		q.Where(
			connector.ID(cqi.ID))
	} else {
		return errors.New("invalid identify of connector")
	}

	cqi.ID, err = q.OnlyID(ctx)
	return err
}

// ConnectorQueryInputs holds the query input of the Connector entities.
type ConnectorQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project *ProjectQueryInput `uri:",inline" query:"-" json:"project,omitempty"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cqi *ConnectorQueryInputs) Load() error {
	if cqi == nil {
		return errors.New("nil receiver")
	}

	return cqi.LoadWith(cqi.inputConfig.Context, cqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cqi *ConnectorQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cqi == nil {
		return errors.New("nil receiver")
	}

	if cqi.Project != nil {
		err = cqi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return err
}

// ConnectorUpdateInput holds the modification input of the Connector entity.
type ConnectorUpdateInput struct {
	ConnectorQueryInput `uri:",inline" query:"-" json:",inline"`

	Name                string                     `uri:"-" query:"-" json:"name,omitempty"`
	Description         string                     `uri:"-" query:"-" json:"description,omitempty"`
	Labels              map[string]string          `uri:"-" query:"-" json:"labels,omitempty"`
	Type                string                     `uri:"-" query:"-" json:"type,omitempty"`
	ConfigVersion       string                     `uri:"-" query:"-" json:"configVersion,omitempty"`
	ConfigData          crypto.Properties          `uri:"-" query:"-" json:"configData,omitempty"`
	EnableFinOps        bool                       `uri:"-" query:"-" json:"enableFinOps,omitempty"`
	FinOpsCustomPricing *types.FinOpsCustomPricing `uri:"-" query:"-" json:"finOpsCustomPricing,omitempty"`
	Category            string                     `uri:"-" query:"-" json:"category,omitempty"`
}

// Model returns the Connector entity for modifying,
// after validating.
func (cui *ConnectorUpdateInput) Model() *Connector {
	if cui == nil {
		return nil
	}

	_c := &Connector{
		ID:                  cui.ID,
		Name:                cui.Name,
		Description:         cui.Description,
		Labels:              cui.Labels,
		Type:                cui.Type,
		ConfigVersion:       cui.ConfigVersion,
		ConfigData:          cui.ConfigData,
		EnableFinOps:        cui.EnableFinOps,
		FinOpsCustomPricing: cui.FinOpsCustomPricing,
		Category:            cui.Category,
	}

	return _c
}

// ConnectorUpdateInputs holds the modification input item of the Connector entities.
type ConnectorUpdateInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`

	Name                string                     `uri:"-" query:"-" json:"name,omitempty"`
	Description         string                     `uri:"-" query:"-" json:"description,omitempty"`
	Labels              map[string]string          `uri:"-" query:"-" json:"labels,omitempty"`
	Type                string                     `uri:"-" query:"-" json:"type,omitempty"`
	ConfigVersion       string                     `uri:"-" query:"-" json:"configVersion,omitempty"`
	ConfigData          crypto.Properties          `uri:"-" query:"-" json:"configData,omitempty"`
	EnableFinOps        bool                       `uri:"-" query:"-" json:"enableFinOps,omitempty"`
	FinOpsCustomPricing *types.FinOpsCustomPricing `uri:"-" query:"-" json:"finOpsCustomPricing,omitempty"`
	Category            string                     `uri:"-" query:"-" json:"category,omitempty"`
}

// ConnectorUpdateInputs holds the modification input of the Connector entities.
type ConnectorUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project *ProjectQueryInput `uri:",inline" query:"-" json:"project,omitempty"`

	Items []*ConnectorUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Connector entities for modifying,
// after validating.
func (cui *ConnectorUpdateInputs) Model() []*Connector {
	if cui == nil || len(cui.Items) == 0 {
		return nil
	}

	_cs := make([]*Connector, len(cui.Items))

	for i := range cui.Items {
		_c := &Connector{
			ID:                  cui.Items[i].ID,
			Name:                cui.Items[i].Name,
			Description:         cui.Items[i].Description,
			Labels:              cui.Items[i].Labels,
			Type:                cui.Items[i].Type,
			ConfigVersion:       cui.Items[i].ConfigVersion,
			ConfigData:          cui.Items[i].ConfigData,
			EnableFinOps:        cui.Items[i].EnableFinOps,
			FinOpsCustomPricing: cui.Items[i].FinOpsCustomPricing,
			Category:            cui.Items[i].Category,
		}

		_cs[i] = _c
	}

	return _cs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (cui *ConnectorUpdateInputs) Load() error {
	if cui == nil {
		return errors.New("nil receiver")
	}

	return cui.LoadWith(cui.inputConfig.Context, cui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (cui *ConnectorUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if cui == nil {
		return errors.New("nil receiver")
	}

	if len(cui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Connectors().Query()

	if cui.Project != nil {
		err = cui.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			connector.ProjectID(cui.Project.ID))
	}

	ids := make([]object.ID, 0, len(cui.Items))

	for i := range cui.Items {
		if cui.Items[i] == nil {
			return errors.New("nil item")
		}

		if cui.Items[i].ID != "" {
			ids = append(ids, cui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(connector.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ConnectorOutput holds the output of the Connector entity.
type ConnectorOutput struct {
	ID                  object.ID                  `json:"id,omitempty"`
	Name                string                     `json:"name,omitempty"`
	Description         string                     `json:"description,omitempty"`
	Labels              map[string]string          `json:"labels,omitempty"`
	CreateTime          *time.Time                 `json:"createTime,omitempty"`
	UpdateTime          *time.Time                 `json:"updateTime,omitempty"`
	Status              status.Status              `json:"status,omitempty"`
	Type                string                     `json:"type,omitempty"`
	ConfigVersion       string                     `json:"configVersion,omitempty"`
	ConfigData          crypto.Properties          `json:"configData,omitempty"`
	EnableFinOps        bool                       `json:"enableFinOps,omitempty"`
	FinOpsCustomPricing *types.FinOpsCustomPricing `json:"finOpsCustomPricing,omitempty"`
	Category            string                     `json:"category,omitempty"`

	Project *ProjectOutput `json:"project,omitempty"`
}

// View returns the output of Connector.
func (_c *Connector) View() *ConnectorOutput {
	return ExposeConnector(_c)
}

// View returns the output of Connectors.
func (_cs Connectors) View() []*ConnectorOutput {
	return ExposeConnectors(_cs)
}

// ExposeConnector converts the Connector to ConnectorOutput.
func ExposeConnector(_c *Connector) *ConnectorOutput {
	if _c == nil {
		return nil
	}

	co := &ConnectorOutput{
		ID:                  _c.ID,
		Name:                _c.Name,
		Description:         _c.Description,
		Labels:              _c.Labels,
		CreateTime:          _c.CreateTime,
		UpdateTime:          _c.UpdateTime,
		Status:              _c.Status,
		Type:                _c.Type,
		ConfigVersion:       _c.ConfigVersion,
		ConfigData:          _c.ConfigData,
		EnableFinOps:        _c.EnableFinOps,
		FinOpsCustomPricing: _c.FinOpsCustomPricing,
		Category:            _c.Category,
	}

	if _c.Edges.Project != nil {
		co.Project = ExposeProject(_c.Edges.Project)
	} else if _c.ProjectID != "" {
		co.Project = &ProjectOutput{
			ID: _c.ProjectID,
		}
	}
	return co
}

// ExposeConnectors converts the Connector slice to ConnectorOutput pointer slice.
func ExposeConnectors(_cs []*Connector) []*ConnectorOutput {
	if len(_cs) == 0 {
		return nil
	}

	cos := make([]*ConnectorOutput, len(_cs))
	for i := range _cs {
		cos[i] = ExposeConnector(_cs[i])
	}
	return cos
}
