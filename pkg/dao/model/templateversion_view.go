// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/templateversion"
	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/dao/types/object"
)

// TemplateVersionCreateInput holds the creation input of the TemplateVersion entity.
type TemplateVersionCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Template *TemplateQueryInput `uri:",inline" query:"-" json:"template"`

	Source  string                `uri:"-" query:"-" json:"source"`
	Version string                `uri:"-" query:"-" json:"version"`
	Schema  *types.TemplateSchema `uri:"-" query:"-" json:"schema,omitempty"`
}

// Model returns the TemplateVersion entity for creating,
// after validating.
func (tvci *TemplateVersionCreateInput) Model() *TemplateVersion {
	if tvci == nil {
		return nil
	}

	tv := &TemplateVersion{
		Source:  tvci.Source,
		Version: tvci.Version,
		Schema:  tvci.Schema,
	}

	if tvci.Template != nil {
		tv.TemplateID = tvci.Template.ID
	}

	return tv
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tvci *TemplateVersionCreateInput) Load() error {
	if tvci == nil {
		return errors.New("nil receiver")
	}

	return tvci.LoadWith(tvci.inputConfig.Context, tvci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tvci *TemplateVersionCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tvci == nil {
		return errors.New("nil receiver")
	}

	if tvci.Template != nil {
		err = tvci.Template.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return nil
}

// TemplateVersionCreateInputs holds the creation input item of the TemplateVersion entities.
type TemplateVersionCreateInputsItem struct {
	Source  string                `uri:"-" query:"-" json:"source"`
	Version string                `uri:"-" query:"-" json:"version"`
	Schema  *types.TemplateSchema `uri:"-" query:"-" json:"schema,omitempty"`
}

// TemplateVersionCreateInputs holds the creation input of the TemplateVersion entities.
type TemplateVersionCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Template *TemplateQueryInput `uri:",inline" query:"-" json:"template"`

	Items []*TemplateVersionCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the TemplateVersion entities for creating,
// after validating.
func (tvci *TemplateVersionCreateInputs) Model() []*TemplateVersion {
	if tvci == nil || len(tvci.Items) == 0 {
		return nil
	}

	tvs := make([]*TemplateVersion, len(tvci.Items))

	for i := range tvci.Items {
		tv := &TemplateVersion{
			Source:  tvci.Items[i].Source,
			Version: tvci.Items[i].Version,
			Schema:  tvci.Items[i].Schema,
		}

		if tvci.Template != nil {
			tv.TemplateID = tvci.Template.ID
		}

		tvs[i] = tv
	}

	return tvs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tvci *TemplateVersionCreateInputs) Load() error {
	if tvci == nil {
		return errors.New("nil receiver")
	}

	return tvci.LoadWith(tvci.inputConfig.Context, tvci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tvci *TemplateVersionCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tvci == nil {
		return errors.New("nil receiver")
	}

	if len(tvci.Items) == 0 {
		return errors.New("empty items")
	}

	if tvci.Template != nil {
		err = tvci.Template.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	return nil
}

// TemplateVersionDeleteInput holds the deletion input of the TemplateVersion entity.
type TemplateVersionDeleteInput = TemplateVersionQueryInput

// TemplateVersionDeleteInputs holds the deletion input item of the TemplateVersion entities.
type TemplateVersionDeleteInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`
}

// TemplateVersionDeleteInputs holds the deletion input of the TemplateVersion entities.
type TemplateVersionDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Template *TemplateQueryInput `uri:",inline" query:"-" json:"template"`

	Items []*TemplateVersionDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the TemplateVersion entities for deleting,
// after validating.
func (tvdi *TemplateVersionDeleteInputs) Model() []*TemplateVersion {
	if tvdi == nil || len(tvdi.Items) == 0 {
		return nil
	}

	tvs := make([]*TemplateVersion, len(tvdi.Items))
	for i := range tvdi.Items {
		tvs[i] = &TemplateVersion{
			ID: tvdi.Items[i].ID,
		}
	}
	return tvs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tvdi *TemplateVersionDeleteInputs) Load() error {
	if tvdi == nil {
		return errors.New("nil receiver")
	}

	return tvdi.LoadWith(tvdi.inputConfig.Context, tvdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tvdi *TemplateVersionDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tvdi == nil {
		return errors.New("nil receiver")
	}

	if len(tvdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.TemplateVersions().Query()

	if tvdi.Template != nil {
		err = tvdi.Template.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			templateversion.TemplateID(tvdi.Template.ID))
	}

	ids := make([]object.ID, 0, len(tvdi.Items))

	for i := range tvdi.Items {
		if tvdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if tvdi.Items[i].ID != "" {
			ids = append(ids, tvdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(templateversion.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// TemplateVersionQueryInput holds the query input of the TemplateVersion entity.
type TemplateVersionQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Template *TemplateQueryInput `uri:",inline" query:"-" json:"-"`

	Refer *object.Refer `uri:"templateversion,default=\"\"" query:"-" json:"-"`
	ID    object.ID     `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the TemplateVersion entity for querying,
// after validating.
func (tvqi *TemplateVersionQueryInput) Model() *TemplateVersion {
	if tvqi == nil {
		return nil
	}

	return &TemplateVersion{
		ID: tvqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tvqi *TemplateVersionQueryInput) Load() error {
	if tvqi == nil {
		return errors.New("nil receiver")
	}

	return tvqi.LoadWith(tvqi.inputConfig.Context, tvqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tvqi *TemplateVersionQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tvqi == nil {
		return errors.New("nil receiver")
	}

	if tvqi.Refer != nil && *tvqi.Refer == "" {
		return nil
	}

	q := cs.TemplateVersions().Query()

	if tvqi.Template != nil {
		err = tvqi.Template.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			templateversion.TemplateID(tvqi.Template.ID))
	}

	if tvqi.Refer != nil {
		if tvqi.Refer.IsID() {
			q.Where(
				templateversion.ID(tvqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of templateversion")
		}
	} else if tvqi.ID != "" {
		q.Where(
			templateversion.ID(tvqi.ID))
	} else {
		return errors.New("invalid identify of templateversion")
	}

	tvqi.ID, err = q.OnlyID(ctx)
	return err
}

// TemplateVersionQueryInputs holds the query input of the TemplateVersion entities.
type TemplateVersionQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Template *TemplateQueryInput `uri:",inline" query:"-" json:"template"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tvqi *TemplateVersionQueryInputs) Load() error {
	if tvqi == nil {
		return errors.New("nil receiver")
	}

	return tvqi.LoadWith(tvqi.inputConfig.Context, tvqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tvqi *TemplateVersionQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tvqi == nil {
		return errors.New("nil receiver")
	}

	if tvqi.Template != nil {
		err = tvqi.Template.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return err
}

// TemplateVersionUpdateInput holds the modification input of the TemplateVersion entity.
type TemplateVersionUpdateInput struct {
	TemplateVersionQueryInput `uri:",inline" query:"-" json:",inline"`

	Schema *types.TemplateSchema `uri:"-" query:"-" json:"schema,omitempty"`
}

// Model returns the TemplateVersion entity for modifying,
// after validating.
func (tvui *TemplateVersionUpdateInput) Model() *TemplateVersion {
	if tvui == nil {
		return nil
	}

	tv := &TemplateVersion{
		ID:     tvui.ID,
		Schema: tvui.Schema,
	}

	return tv
}

// TemplateVersionUpdateInputs holds the modification input item of the TemplateVersion entities.
type TemplateVersionUpdateInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`

	Schema *types.TemplateSchema `uri:"-" query:"-" json:"schema,omitempty"`
}

// TemplateVersionUpdateInputs holds the modification input of the TemplateVersion entities.
type TemplateVersionUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Template *TemplateQueryInput `uri:",inline" query:"-" json:"template"`

	Items []*TemplateVersionUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the TemplateVersion entities for modifying,
// after validating.
func (tvui *TemplateVersionUpdateInputs) Model() []*TemplateVersion {
	if tvui == nil || len(tvui.Items) == 0 {
		return nil
	}

	tvs := make([]*TemplateVersion, len(tvui.Items))

	for i := range tvui.Items {
		tv := &TemplateVersion{
			ID:     tvui.Items[i].ID,
			Schema: tvui.Items[i].Schema,
		}

		tvs[i] = tv
	}

	return tvs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (tvui *TemplateVersionUpdateInputs) Load() error {
	if tvui == nil {
		return errors.New("nil receiver")
	}

	return tvui.LoadWith(tvui.inputConfig.Context, tvui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (tvui *TemplateVersionUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if tvui == nil {
		return errors.New("nil receiver")
	}

	if len(tvui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.TemplateVersions().Query()

	if tvui.Template != nil {
		err = tvui.Template.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			templateversion.TemplateID(tvui.Template.ID))
	}

	ids := make([]object.ID, 0, len(tvui.Items))

	for i := range tvui.Items {
		if tvui.Items[i] == nil {
			return errors.New("nil item")
		}

		if tvui.Items[i].ID != "" {
			ids = append(ids, tvui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(templateversion.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// TemplateVersionOutput holds the output of the TemplateVersion entity.
type TemplateVersionOutput struct {
	ID         object.ID             `json:"id,omitempty"`
	CreateTime *time.Time            `json:"createTime,omitempty"`
	UpdateTime *time.Time            `json:"updateTime,omitempty"`
	Version    string                `json:"version,omitempty"`
	Source     string                `json:"source,omitempty"`
	Schema     *types.TemplateSchema `json:"schema,omitempty"`

	Template *TemplateOutput `json:"template,omitempty"`
}

// View returns the output of TemplateVersion.
func (tv *TemplateVersion) View() *TemplateVersionOutput {
	return ExposeTemplateVersion(tv)
}

// View returns the output of TemplateVersions.
func (tvs TemplateVersions) View() []*TemplateVersionOutput {
	return ExposeTemplateVersions(tvs)
}

// ExposeTemplateVersion converts the TemplateVersion to TemplateVersionOutput.
func ExposeTemplateVersion(tv *TemplateVersion) *TemplateVersionOutput {
	if tv == nil {
		return nil
	}

	tvo := &TemplateVersionOutput{
		ID:         tv.ID,
		CreateTime: tv.CreateTime,
		UpdateTime: tv.UpdateTime,
		Version:    tv.Version,
		Source:     tv.Source,
		Schema:     tv.Schema,
	}

	if tv.Edges.Template != nil {
		tvo.Template = ExposeTemplate(tv.Edges.Template)
	} else if tv.TemplateID != "" {
		tvo.Template = &TemplateOutput{
			ID: tv.TemplateID,
		}
	}
	return tvo
}

// ExposeTemplateVersions converts the TemplateVersion slice to TemplateVersionOutput pointer slice.
func ExposeTemplateVersions(tvs []*TemplateVersion) []*TemplateVersionOutput {
	if len(tvs) == 0 {
		return nil
	}

	tvos := make([]*TemplateVersionOutput, len(tvs))
	for i := range tvs {
		tvos[i] = ExposeTemplateVersion(tvs[i])
	}
	return tvos
}
