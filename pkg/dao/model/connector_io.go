// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "ent". DO NOT EDIT.

package model

import (
	"time"

	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/dao/types/crypto"
	"github.com/seal-io/seal/pkg/dao/types/oid"
	"github.com/seal-io/seal/pkg/dao/types/status"
)

// ConnectorQueryInput is the input for the Connector query.
type ConnectorQueryInput struct {
	// ID holds the value of the "id" field.
	ID oid.ID `uri:"id,omitempty" json:"id,omitempty"`
}

// Model converts the ConnectorQueryInput to Connector.
func (in ConnectorQueryInput) Model() *Connector {
	return &Connector{
		ID: in.ID,
	}
}

// ConnectorCreateInput is the input for the Connector creation.
type ConnectorCreateInput struct {
	// Name holds the value of the "name" field.
	Name string `json:"name"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `json:"labels,omitempty"`
	// Type of the connector.
	Type string `json:"type"`
	// Connector config version.
	ConfigVersion string `json:"configVersion"`
	// Connector config data.
	ConfigData crypto.Properties `json:"configData,omitempty"`
	// Config whether enable finOps, will install prometheus and opencost while enable.
	EnableFinOps bool `json:"enableFinOps,omitempty"`
	// Custom pricing user defined.
	FinOpsCustomPricing *types.FinOpsCustomPricing `json:"finOpsCustomPricing,omitempty"`
	// Category of the connector.
	Category string `json:"category"`
	// Project to which the connector belongs.
	Project *ProjectQueryInput `json:"project,omitempty"`
}

// Model converts the ConnectorCreateInput to Connector.
func (in ConnectorCreateInput) Model() *Connector {
	var entity = &Connector{
		Name:                in.Name,
		Description:         in.Description,
		Labels:              in.Labels,
		Type:                in.Type,
		ConfigVersion:       in.ConfigVersion,
		ConfigData:          in.ConfigData,
		EnableFinOps:        in.EnableFinOps,
		FinOpsCustomPricing: in.FinOpsCustomPricing,
		Category:            in.Category,
	}
	if in.Project != nil {
		entity.ProjectID = in.Project.ID
	}
	return entity
}

// ConnectorUpdateInput is the input for the Connector modification.
type ConnectorUpdateInput struct {
	// ID holds the value of the "id" field.
	ID oid.ID `uri:"id" json:"-"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `json:"labels,omitempty"`
	// Connector config version.
	ConfigVersion string `json:"configVersion,omitempty"`
	// Connector config data.
	ConfigData crypto.Properties `json:"configData,omitempty"`
	// Config whether enable finOps, will install prometheus and opencost while enable.
	EnableFinOps bool `json:"enableFinOps,omitempty"`
	// Custom pricing user defined.
	FinOpsCustomPricing *types.FinOpsCustomPricing `json:"finOpsCustomPricing,omitempty"`
	// Category of the connector.
	Category string `json:"category,omitempty"`
}

// Model converts the ConnectorUpdateInput to Connector.
func (in ConnectorUpdateInput) Model() *Connector {
	var entity = &Connector{
		ID:                  in.ID,
		Name:                in.Name,
		Description:         in.Description,
		Labels:              in.Labels,
		ConfigVersion:       in.ConfigVersion,
		ConfigData:          in.ConfigData,
		EnableFinOps:        in.EnableFinOps,
		FinOpsCustomPricing: in.FinOpsCustomPricing,
		Category:            in.Category,
	}
	return entity
}

// ConnectorOutput is the output for the Connector.
type ConnectorOutput struct {
	// ID holds the value of the "id" field.
	ID oid.ID `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `json:"labels,omitempty"`
	// CreateTime holds the value of the "createTime" field.
	CreateTime *time.Time `json:"createTime,omitempty"`
	// UpdateTime holds the value of the "updateTime" field.
	UpdateTime *time.Time `json:"updateTime,omitempty"`
	// Status holds the value of the "status" field.
	Status status.Status `json:"status,omitempty"`
	// Type of the connector.
	Type string `json:"type,omitempty"`
	// Connector config version.
	ConfigVersion string `json:"configVersion,omitempty"`
	// Connector config data.
	ConfigData crypto.Properties `json:"configData,omitempty"`
	// Config whether enable finOps, will install prometheus and opencost while enable.
	EnableFinOps bool `json:"enableFinOps,omitempty"`
	// Custom pricing user defined.
	FinOpsCustomPricing *types.FinOpsCustomPricing `json:"finOpsCustomPricing,omitempty"`
	// Category of the connector.
	Category string `json:"category,omitempty"`
	// Project to which the connector belongs.
	Project *ProjectOutput `json:"project,omitempty"`
}

// ExposeConnector converts the Connector to ConnectorOutput.
func ExposeConnector(in *Connector) *ConnectorOutput {
	if in == nil {
		return nil
	}
	var entity = &ConnectorOutput{
		ID:                  in.ID,
		Name:                in.Name,
		Description:         in.Description,
		Labels:              in.Labels,
		CreateTime:          in.CreateTime,
		UpdateTime:          in.UpdateTime,
		Status:              in.Status,
		Type:                in.Type,
		ConfigVersion:       in.ConfigVersion,
		ConfigData:          in.ConfigData,
		EnableFinOps:        in.EnableFinOps,
		FinOpsCustomPricing: in.FinOpsCustomPricing,
		Category:            in.Category,
		Project:             ExposeProject(in.Edges.Project),
	}
	if in.ProjectID != "" {
		if entity.Project == nil {
			entity.Project = &ProjectOutput{}
		}
		entity.Project.ID = in.ProjectID
	}
	return entity
}

// ExposeConnectors converts the Connector slice to ConnectorOutput pointer slice.
func ExposeConnectors(in []*Connector) []*ConnectorOutput {
	var out = make([]*ConnectorOutput, 0, len(in))
	for i := 0; i < len(in); i++ {
		var o = ExposeConnector(in[i])
		if o == nil {
			continue
		}
		out = append(out, o)
	}
	if len(out) == 0 {
		return nil
	}
	return out
}
