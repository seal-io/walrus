// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/predicate"
	"github.com/seal-io/seal/pkg/dao/model/variable"
	"github.com/seal-io/seal/pkg/dao/types/crypto"
	"github.com/seal-io/seal/pkg/dao/types/object"
)

// VariableCreateInput holds the creation input of the Variable entity.
type VariableCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project,omitempty"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment,omitempty"`

	Value       crypto.String `uri:"-" query:"-" json:"value"`
	Name        string        `uri:"-" query:"-" json:"name"`
	Sensitive   bool          `uri:"-" query:"-" json:"sensitive,omitempty"`
	Description string        `uri:"-" query:"-" json:"description,omitempty"`
}

// Model returns the Variable entity for creating,
// after validating.
func (vci *VariableCreateInput) Model() *Variable {
	if vci == nil {
		return nil
	}

	v := &Variable{
		Value:       vci.Value,
		Name:        vci.Name,
		Sensitive:   vci.Sensitive,
		Description: vci.Description,
	}

	if vci.Project != nil {
		v.ProjectID = vci.Project.ID
	}
	if vci.Environment != nil {
		v.EnvironmentID = vci.Environment.ID
	}

	return v
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (vci *VariableCreateInput) Load() error {
	if vci == nil {
		return errors.New("nil receiver")
	}

	return vci.LoadWith(vci.inputConfig.Context, vci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (vci *VariableCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if vci == nil {
		return errors.New("nil receiver")
	}

	if vci.Project != nil {
		err = vci.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	if vci.Environment != nil {
		err = vci.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return nil
}

// VariableCreateInputs holds the creation input item of the Variable entities.
type VariableCreateInputsItem struct {
	Value       crypto.String `uri:"-" query:"-" json:"value"`
	Name        string        `uri:"-" query:"-" json:"name"`
	Sensitive   bool          `uri:"-" query:"-" json:"sensitive,omitempty"`
	Description string        `uri:"-" query:"-" json:"description,omitempty"`
}

// VariableCreateInputs holds the creation input of the Variable entities.
type VariableCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project,omitempty"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment,omitempty"`

	Items []*VariableCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Variable entities for creating,
// after validating.
func (vci *VariableCreateInputs) Model() []*Variable {
	if vci == nil || len(vci.Items) == 0 {
		return nil
	}

	vs := make([]*Variable, len(vci.Items))

	for i := range vci.Items {
		v := &Variable{
			Value:       vci.Items[i].Value,
			Name:        vci.Items[i].Name,
			Sensitive:   vci.Items[i].Sensitive,
			Description: vci.Items[i].Description,
		}

		if vci.Project != nil {
			v.ProjectID = vci.Project.ID
		}
		if vci.Environment != nil {
			v.EnvironmentID = vci.Environment.ID
		}

		vs[i] = v
	}

	return vs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (vci *VariableCreateInputs) Load() error {
	if vci == nil {
		return errors.New("nil receiver")
	}

	return vci.LoadWith(vci.inputConfig.Context, vci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (vci *VariableCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if vci == nil {
		return errors.New("nil receiver")
	}

	if len(vci.Items) == 0 {
		return errors.New("empty items")
	}

	if vci.Project != nil {
		err = vci.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	if vci.Environment != nil {
		err = vci.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	return nil
}

// VariableDeleteInput holds the deletion input of the Variable entity.
type VariableDeleteInput = VariableQueryInput

// VariableDeleteInputs holds the deletion input item of the Variable entities.
type VariableDeleteInputsItem struct {
	ID   object.ID `uri:"-" query:"-" json:"id,omitempty"`
	Name string    `uri:"-" query:"-" json:"name,omitempty"`
}

// VariableDeleteInputs holds the deletion input of the Variable entities.
type VariableDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project,omitempty"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment,omitempty"`

	Items []*VariableDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Variable entities for deleting,
// after validating.
func (vdi *VariableDeleteInputs) Model() []*Variable {
	if vdi == nil || len(vdi.Items) == 0 {
		return nil
	}

	vs := make([]*Variable, len(vdi.Items))
	for i := range vdi.Items {
		vs[i] = &Variable{
			ID: vdi.Items[i].ID,
		}
	}
	return vs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (vdi *VariableDeleteInputs) Load() error {
	if vdi == nil {
		return errors.New("nil receiver")
	}

	return vdi.LoadWith(vdi.inputConfig.Context, vdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (vdi *VariableDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if vdi == nil {
		return errors.New("nil receiver")
	}

	if len(vdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Variables().Query()

	if vdi.Project != nil {
		err = vdi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			variable.ProjectID(vdi.Project.ID))
	}

	if vdi.Environment != nil {
		err = vdi.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			variable.EnvironmentID(vdi.Environment.ID))
	}

	ids := make([]object.ID, 0, len(vdi.Items))
	ors := make([]predicate.Variable, 0, len(vdi.Items))

	for i := range vdi.Items {
		if vdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if vdi.Items[i].ID != "" {
			ids = append(ids, vdi.Items[i].ID)
			ors = append(ors, variable.ID(vdi.Items[i].ID))
		} else if vdi.Items[i].Name != "" {
			ors = append(ors, variable.And(
				variable.Name(vdi.Items[i].Name)))
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)
	if idsLen != cap(ids) {
		ids, err = q.Where(variable.Or(ors...)).
			IDs(ctx)
		if err != nil {
			return err
		}

		if len(ids) != idsLen {
			return errors.New("found unrecognized item")
		}

		for i := range ids {
			vdi.Items[i].ID = ids[i]
		}

		return nil
	}

	idsCnt, err := q.Where(variable.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// VariableQueryInput holds the query input of the Variable entity.
type VariableQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project,omitempty"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment,omitempty"`

	Refer *object.Refer `uri:"variable,default=\"\"" query:"-" json:"-"`
	ID    object.ID     `uri:"id" query:"-" json:"id,omitempty"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
	Name  string        `uri:"-" query:"-" json:"name,omitempty"`
}

// Model returns the Variable entity for querying,
// after validating.
func (vqi *VariableQueryInput) Model() *Variable {
	if vqi == nil {
		return nil
	}

	return &Variable{
		ID: vqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (vqi *VariableQueryInput) Load() error {
	if vqi == nil {
		return errors.New("nil receiver")
	}

	return vqi.LoadWith(vqi.inputConfig.Context, vqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (vqi *VariableQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if vqi == nil {
		return errors.New("nil receiver")
	}

	if vqi.Refer != nil && *vqi.Refer == "" {
		return nil
	}

	q := cs.Variables().Query()

	if vqi.Project != nil {
		err = vqi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			variable.ProjectID(vqi.Project.ID))
	} else {
		q.Where(
			variable.ProjectIDIsNil())
	}

	if vqi.Environment != nil {
		err = vqi.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			variable.EnvironmentID(vqi.Environment.ID))
	} else {
		q.Where(
			variable.EnvironmentIDIsNil())
	}

	if vqi.Refer != nil {
		if vqi.Refer.IsID() {
			q.Where(
				variable.ID(vqi.Refer.ID()))
		} else if refers := vqi.Refer.Split(1); len(refers) == 1 {
			q.Where(
				variable.Name(refers[0].String()))
		} else {
			return errors.New("invalid identify refer of variable")
		}
	} else if vqi.ID != "" {
		q.Where(
			variable.ID(vqi.ID))
	} else if vqi.Name != "" {
		q.Where(
			variable.Name(vqi.Name))
	} else {
		return errors.New("invalid identify of variable")
	}

	vqi.ID, err = q.OnlyID(ctx)
	return err
}

// VariableQueryInputs holds the query input of the Variable entities.
type VariableQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project,omitempty"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment,omitempty"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (vqi *VariableQueryInputs) Load() error {
	if vqi == nil {
		return errors.New("nil receiver")
	}

	return vqi.LoadWith(vqi.inputConfig.Context, vqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (vqi *VariableQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if vqi == nil {
		return errors.New("nil receiver")
	}

	if vqi.Project != nil {
		err = vqi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	if vqi.Environment != nil {
		err = vqi.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return err
}

// VariableUpdateInput holds the modification input of the Variable entity.
type VariableUpdateInput struct {
	VariableQueryInput `uri:",inline" query:"-" json:",inline"`

	Value       crypto.String `uri:"-" query:"-" json:"value,omitempty"`
	Sensitive   bool          `uri:"-" query:"-" json:"sensitive,omitempty"`
	Description string        `uri:"-" query:"-" json:"description,omitempty"`
}

// Model returns the Variable entity for modifying,
// after validating.
func (vui *VariableUpdateInput) Model() *Variable {
	if vui == nil {
		return nil
	}

	v := &Variable{
		ID:          vui.ID,
		Value:       vui.Value,
		Sensitive:   vui.Sensitive,
		Description: vui.Description,
	}

	return v
}

// VariableUpdateInputs holds the modification input item of the Variable entities.
type VariableUpdateInputsItem struct {
	ID   object.ID `uri:"-" query:"-" json:"id,omitempty"`
	Name string    `uri:"-" query:"-" json:"name,omitempty"`

	Value       crypto.String `uri:"-" query:"-" json:"value,omitempty"`
	Sensitive   bool          `uri:"-" query:"-" json:"sensitive,omitempty"`
	Description string        `uri:"-" query:"-" json:"description,omitempty"`
}

// VariableUpdateInputs holds the modification input of the Variable entities.
type VariableUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project,omitempty"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment,omitempty"`

	Items []*VariableUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Variable entities for modifying,
// after validating.
func (vui *VariableUpdateInputs) Model() []*Variable {
	if vui == nil || len(vui.Items) == 0 {
		return nil
	}

	vs := make([]*Variable, len(vui.Items))

	for i := range vui.Items {
		v := &Variable{
			ID:          vui.Items[i].ID,
			Value:       vui.Items[i].Value,
			Sensitive:   vui.Items[i].Sensitive,
			Description: vui.Items[i].Description,
		}

		vs[i] = v
	}

	return vs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (vui *VariableUpdateInputs) Load() error {
	if vui == nil {
		return errors.New("nil receiver")
	}

	return vui.LoadWith(vui.inputConfig.Context, vui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (vui *VariableUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if vui == nil {
		return errors.New("nil receiver")
	}

	if len(vui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Variables().Query()

	if vui.Project != nil {
		err = vui.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			variable.ProjectID(vui.Project.ID))
	}

	if vui.Environment != nil {
		err = vui.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			variable.EnvironmentID(vui.Environment.ID))
	}

	ids := make([]object.ID, 0, len(vui.Items))
	ors := make([]predicate.Variable, 0, len(vui.Items))

	for i := range vui.Items {
		if vui.Items[i] == nil {
			return errors.New("nil item")
		}

		if vui.Items[i].ID != "" {
			ids = append(ids, vui.Items[i].ID)
			ors = append(ors, variable.ID(vui.Items[i].ID))
		} else if vui.Items[i].Name != "" {
			ors = append(ors, variable.And(
				variable.Name(vui.Items[i].Name)))
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)
	if idsLen != cap(ids) {
		ids, err = q.Where(variable.Or(ors...)).
			IDs(ctx)
		if err != nil {
			return err
		}

		if len(ids) != idsLen {
			return errors.New("found unrecognized item")
		}

		for i := range ids {
			vui.Items[i].ID = ids[i]
		}

		return nil
	}

	idsCnt, err := q.Where(variable.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// VariableOutput holds the output of the Variable entity.
type VariableOutput struct {
	ID          object.ID     `json:"id,omitempty"`
	CreateTime  *time.Time    `json:"createTime,omitempty"`
	UpdateTime  *time.Time    `json:"updateTime,omitempty"`
	Name        string        `json:"name,omitempty"`
	Value       crypto.String `json:"value,omitempty"`
	Sensitive   bool          `json:"sensitive,omitempty"`
	Description string        `json:"description,omitempty"`

	Project     *ProjectOutput     `json:"project,omitempty"`
	Environment *EnvironmentOutput `json:"environment,omitempty"`
}

// View returns the output of Variable.
func (v *Variable) View() *VariableOutput {
	return ExposeVariable(v)
}

// View returns the output of Variables.
func (vs Variables) View() []*VariableOutput {
	return ExposeVariables(vs)
}

// ExposeVariable converts the Variable to VariableOutput.
func ExposeVariable(v *Variable) *VariableOutput {
	if v == nil {
		return nil
	}

	vo := &VariableOutput{
		ID:          v.ID,
		CreateTime:  v.CreateTime,
		UpdateTime:  v.UpdateTime,
		Name:        v.Name,
		Value:       v.Value,
		Sensitive:   v.Sensitive,
		Description: v.Description,
	}

	if v.Edges.Project != nil {
		vo.Project = ExposeProject(v.Edges.Project)
	} else if v.ProjectID != "" {
		vo.Project = &ProjectOutput{
			ID: v.ProjectID,
		}
	}
	if v.Edges.Environment != nil {
		vo.Environment = ExposeEnvironment(v.Edges.Environment)
	} else if v.EnvironmentID != "" {
		vo.Environment = &EnvironmentOutput{
			ID: v.EnvironmentID,
		}
	}
	return vo
}

// ExposeVariables converts the Variable slice to VariableOutput pointer slice.
func ExposeVariables(vs []*Variable) []*VariableOutput {
	if len(vs) == 0 {
		return nil
	}

	vos := make([]*VariableOutput, len(vs))
	for i := range vs {
		vos[i] = ExposeVariable(vs[i])
	}
	return vos
}
