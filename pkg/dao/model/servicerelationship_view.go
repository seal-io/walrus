// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/servicerelationship"
	"github.com/seal-io/seal/pkg/dao/types/object"
)

// ServiceRelationshipCreateInput holds the creation input of the ServiceRelationship entity.
type ServiceRelationshipCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Dependency *ServiceQueryInput `uri:"-" query:"-" json:"dependency,omitempty"`
}

// Model returns the ServiceRelationship entity for creating,
// after validating.
func (srci *ServiceRelationshipCreateInput) Model() *ServiceRelationship {
	if srci == nil {
		return nil
	}

	_sr := &ServiceRelationship{}

	if srci.Dependency != nil {
		_sr.DependencyID = srci.Dependency.ID
	}
	return _sr
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srci *ServiceRelationshipCreateInput) Load() error {
	if srci == nil {
		return errors.New("nil receiver")
	}

	return srci.LoadWith(srci.inputConfig.Context, srci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srci *ServiceRelationshipCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srci == nil {
		return errors.New("nil receiver")
	}

	if srci.Dependency != nil {
		err = srci.Dependency.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceRelationshipCreateInputs holds the creation input item of the ServiceRelationship entities.
type ServiceRelationshipCreateInputsItem struct {
	Dependency *ServiceQueryInput `uri:"-" query:"-" json:"dependency,omitempty"`
}

// ServiceRelationshipCreateInputs holds the creation input of the ServiceRelationship entities.
type ServiceRelationshipCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*ServiceRelationshipCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ServiceRelationship entities for creating,
// after validating.
func (srci *ServiceRelationshipCreateInputs) Model() []*ServiceRelationship {
	if srci == nil || len(srci.Items) == 0 {
		return nil
	}

	_srs := make([]*ServiceRelationship, len(srci.Items))

	for i := range srci.Items {
		_sr := &ServiceRelationship{}

		if srci.Items[i].Dependency != nil {
			_sr.DependencyID = srci.Items[i].Dependency.ID
		}

		_srs[i] = _sr
	}

	return _srs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srci *ServiceRelationshipCreateInputs) Load() error {
	if srci == nil {
		return errors.New("nil receiver")
	}

	return srci.LoadWith(srci.inputConfig.Context, srci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srci *ServiceRelationshipCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srci == nil {
		return errors.New("nil receiver")
	}

	if len(srci.Items) == 0 {
		return errors.New("empty items")
	}

	return nil
}

// ServiceRelationshipDeleteInput holds the deletion input of the ServiceRelationship entity.
type ServiceRelationshipDeleteInput = ServiceRelationshipQueryInput

// ServiceRelationshipDeleteInputs holds the deletion input item of the ServiceRelationship entities.
type ServiceRelationshipDeleteInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`
}

// ServiceRelationshipDeleteInputs holds the deletion input of the ServiceRelationship entities.
type ServiceRelationshipDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*ServiceRelationshipDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ServiceRelationship entities for deleting,
// after validating.
func (srdi *ServiceRelationshipDeleteInputs) Model() []*ServiceRelationship {
	if srdi == nil || len(srdi.Items) == 0 {
		return nil
	}

	_srs := make([]*ServiceRelationship, len(srdi.Items))
	for i := range srdi.Items {
		_srs[i] = &ServiceRelationship{
			ID: srdi.Items[i].ID,
		}
	}
	return _srs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srdi *ServiceRelationshipDeleteInputs) Load() error {
	if srdi == nil {
		return errors.New("nil receiver")
	}

	return srdi.LoadWith(srdi.inputConfig.Context, srdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srdi *ServiceRelationshipDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srdi == nil {
		return errors.New("nil receiver")
	}

	if len(srdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.ServiceRelationships().Query()

	ids := make([]object.ID, 0, len(srdi.Items))

	for i := range srdi.Items {
		if srdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if srdi.Items[i].ID != "" {
			ids = append(ids, srdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(servicerelationship.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ServiceRelationshipQueryInput holds the query input of the ServiceRelationship entity.
type ServiceRelationshipQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Refer *object.Refer `uri:"servicerelationship,default=\"\"" query:"-" json:"-"`
	ID    object.ID     `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the ServiceRelationship entity for querying,
// after validating.
func (srqi *ServiceRelationshipQueryInput) Model() *ServiceRelationship {
	if srqi == nil {
		return nil
	}

	return &ServiceRelationship{
		ID: srqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srqi *ServiceRelationshipQueryInput) Load() error {
	if srqi == nil {
		return errors.New("nil receiver")
	}

	return srqi.LoadWith(srqi.inputConfig.Context, srqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srqi *ServiceRelationshipQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srqi == nil {
		return errors.New("nil receiver")
	}

	if srqi.Refer != nil && *srqi.Refer == "" {
		return nil
	}

	q := cs.ServiceRelationships().Query()

	if srqi.Refer != nil {
		if srqi.Refer.IsID() {
			q.Where(
				servicerelationship.ID(srqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of servicerelationship")
		}
	} else if srqi.ID != "" {
		q.Where(
			servicerelationship.ID(srqi.ID))
	} else {
		return errors.New("invalid identify of servicerelationship")
	}

	srqi.ID, err = q.OnlyID(ctx)
	return err
}

// ServiceRelationshipQueryInputs holds the query input of the ServiceRelationship entities.
type ServiceRelationshipQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srqi *ServiceRelationshipQueryInputs) Load() error {
	if srqi == nil {
		return errors.New("nil receiver")
	}

	return srqi.LoadWith(srqi.inputConfig.Context, srqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srqi *ServiceRelationshipQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srqi == nil {
		return errors.New("nil receiver")
	}

	return err
}

// ServiceRelationshipUpdateInput holds the modification input of the ServiceRelationship entity.
type ServiceRelationshipUpdateInput struct {
	ServiceRelationshipQueryInput `uri:",inline" query:"-" json:",inline"`

	Dependency *ServiceQueryInput `uri:"-" query:"-" json:"dependency,omitempty"`
}

// Model returns the ServiceRelationship entity for modifying,
// after validating.
func (srui *ServiceRelationshipUpdateInput) Model() *ServiceRelationship {
	if srui == nil {
		return nil
	}

	_sr := &ServiceRelationship{
		ID: srui.ID,
	}

	if srui.Dependency != nil {
		_sr.DependencyID = srui.Dependency.ID
	}
	return _sr
}

// ServiceRelationshipUpdateInputs holds the modification input item of the ServiceRelationship entities.
type ServiceRelationshipUpdateInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`

	Dependency *ServiceQueryInput `uri:"-" query:"-" json:"dependency,omitempty"`
}

// ServiceRelationshipUpdateInputs holds the modification input of the ServiceRelationship entities.
type ServiceRelationshipUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*ServiceRelationshipUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ServiceRelationship entities for modifying,
// after validating.
func (srui *ServiceRelationshipUpdateInputs) Model() []*ServiceRelationship {
	if srui == nil || len(srui.Items) == 0 {
		return nil
	}

	_srs := make([]*ServiceRelationship, len(srui.Items))

	for i := range srui.Items {
		_sr := &ServiceRelationship{
			ID: srui.Items[i].ID,
		}

		if srui.Items[i].Dependency != nil {
			_sr.DependencyID = srui.Items[i].Dependency.ID
		}

		_srs[i] = _sr
	}

	return _srs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srui *ServiceRelationshipUpdateInputs) Load() error {
	if srui == nil {
		return errors.New("nil receiver")
	}

	return srui.LoadWith(srui.inputConfig.Context, srui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srui *ServiceRelationshipUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srui == nil {
		return errors.New("nil receiver")
	}

	if len(srui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.ServiceRelationships().Query()

	ids := make([]object.ID, 0, len(srui.Items))

	for i := range srui.Items {
		if srui.Items[i] == nil {
			return errors.New("nil item")
		}

		if srui.Items[i].ID != "" {
			ids = append(ids, srui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(servicerelationship.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ServiceRelationshipOutput holds the output of the ServiceRelationship entity.
type ServiceRelationshipOutput struct {
	ID         object.ID   `json:"id,omitempty"`
	CreateTime *time.Time  `json:"createTime,omitempty"`
	Path       []object.ID `json:"path,omitempty"`
	Type       string      `json:"type,omitempty"`

	Dependency *ServiceOutput `json:"dependency,omitempty"`
}

// View returns the output of ServiceRelationship.
func (_sr *ServiceRelationship) View() *ServiceRelationshipOutput {
	return ExposeServiceRelationship(_sr)
}

// View returns the output of ServiceRelationships.
func (_srs ServiceRelationships) View() []*ServiceRelationshipOutput {
	return ExposeServiceRelationships(_srs)
}

// ExposeServiceRelationship converts the ServiceRelationship to ServiceRelationshipOutput.
func ExposeServiceRelationship(_sr *ServiceRelationship) *ServiceRelationshipOutput {
	if _sr == nil {
		return nil
	}

	sro := &ServiceRelationshipOutput{
		ID:         _sr.ID,
		CreateTime: _sr.CreateTime,
		Path:       _sr.Path,
		Type:       _sr.Type,
	}

	if _sr.Edges.Dependency != nil {
		sro.Dependency = ExposeService(_sr.Edges.Dependency)
	} else if _sr.DependencyID != "" {
		sro.Dependency = &ServiceOutput{
			ID: _sr.DependencyID,
		}
	}
	return sro
}

// ExposeServiceRelationships converts the ServiceRelationship slice to ServiceRelationshipOutput pointer slice.
func ExposeServiceRelationships(_srs []*ServiceRelationship) []*ServiceRelationshipOutput {
	if len(_srs) == 0 {
		return nil
	}

	sros := make([]*ServiceRelationshipOutput, len(_srs))
	for i := range _srs {
		sros[i] = ExposeServiceRelationship(_srs[i])
	}
	return sros
}
