// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/clustercost"
	"github.com/seal-io/seal/pkg/dao/types/object"
)

// ClusterCostCreateInput holds the creation input of the ClusterCost entity.
type ClusterCostCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	ClusterName    string    `uri:"-" query:"-" json:"clusterName"`
	Minutes        float64   `uri:"-" query:"-" json:"minutes"`
	EndTime        time.Time `uri:"-" query:"-" json:"endTime"`
	StartTime      time.Time `uri:"-" query:"-" json:"startTime"`
	TotalCost      float64   `uri:"-" query:"-" json:"totalCost,omitempty"`
	Currency       int       `uri:"-" query:"-" json:"currency,omitempty"`
	AllocationCost float64   `uri:"-" query:"-" json:"allocationCost,omitempty"`
	IdleCost       float64   `uri:"-" query:"-" json:"idleCost,omitempty"`
	ManagementCost float64   `uri:"-" query:"-" json:"managementCost,omitempty"`
}

// Model returns the ClusterCost entity for creating,
// after validating.
func (ccci *ClusterCostCreateInput) Model() *ClusterCost {
	if ccci == nil {
		return nil
	}

	cc := &ClusterCost{
		ClusterName:    ccci.ClusterName,
		Minutes:        ccci.Minutes,
		EndTime:        ccci.EndTime,
		StartTime:      ccci.StartTime,
		TotalCost:      ccci.TotalCost,
		Currency:       ccci.Currency,
		AllocationCost: ccci.AllocationCost,
		IdleCost:       ccci.IdleCost,
		ManagementCost: ccci.ManagementCost,
	}

	return cc
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (ccci *ClusterCostCreateInput) Load() error {
	if ccci == nil {
		return errors.New("nil receiver")
	}

	return ccci.LoadWith(ccci.inputConfig.Context, ccci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (ccci *ClusterCostCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if ccci == nil {
		return errors.New("nil receiver")
	}

	return nil
}

// ClusterCostCreateInputs holds the creation input item of the ClusterCost entities.
type ClusterCostCreateInputsItem struct {
	ClusterName    string    `uri:"-" query:"-" json:"clusterName"`
	Minutes        float64   `uri:"-" query:"-" json:"minutes"`
	EndTime        time.Time `uri:"-" query:"-" json:"endTime"`
	StartTime      time.Time `uri:"-" query:"-" json:"startTime"`
	TotalCost      float64   `uri:"-" query:"-" json:"totalCost,omitempty"`
	Currency       int       `uri:"-" query:"-" json:"currency,omitempty"`
	AllocationCost float64   `uri:"-" query:"-" json:"allocationCost,omitempty"`
	IdleCost       float64   `uri:"-" query:"-" json:"idleCost,omitempty"`
	ManagementCost float64   `uri:"-" query:"-" json:"managementCost,omitempty"`
}

// ClusterCostCreateInputs holds the creation input of the ClusterCost entities.
type ClusterCostCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*ClusterCostCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ClusterCost entities for creating,
// after validating.
func (ccci *ClusterCostCreateInputs) Model() []*ClusterCost {
	if ccci == nil || len(ccci.Items) == 0 {
		return nil
	}

	ccs := make([]*ClusterCost, len(ccci.Items))

	for i := range ccci.Items {
		cc := &ClusterCost{
			ClusterName:    ccci.Items[i].ClusterName,
			Minutes:        ccci.Items[i].Minutes,
			EndTime:        ccci.Items[i].EndTime,
			StartTime:      ccci.Items[i].StartTime,
			TotalCost:      ccci.Items[i].TotalCost,
			Currency:       ccci.Items[i].Currency,
			AllocationCost: ccci.Items[i].AllocationCost,
			IdleCost:       ccci.Items[i].IdleCost,
			ManagementCost: ccci.Items[i].ManagementCost,
		}

		ccs[i] = cc
	}

	return ccs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (ccci *ClusterCostCreateInputs) Load() error {
	if ccci == nil {
		return errors.New("nil receiver")
	}

	return ccci.LoadWith(ccci.inputConfig.Context, ccci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (ccci *ClusterCostCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if ccci == nil {
		return errors.New("nil receiver")
	}

	if len(ccci.Items) == 0 {
		return errors.New("empty items")
	}

	return nil
}

// ClusterCostDeleteInput holds the deletion input of the ClusterCost entity.
type ClusterCostDeleteInput = ClusterCostQueryInput

// ClusterCostDeleteInputs holds the deletion input item of the ClusterCost entities.
type ClusterCostDeleteInputsItem struct {
	ID int `uri:"-" query:"-" json:"id"`
}

// ClusterCostDeleteInputs holds the deletion input of the ClusterCost entities.
type ClusterCostDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*ClusterCostDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ClusterCost entities for deleting,
// after validating.
func (ccdi *ClusterCostDeleteInputs) Model() []*ClusterCost {
	if ccdi == nil || len(ccdi.Items) == 0 {
		return nil
	}

	ccs := make([]*ClusterCost, len(ccdi.Items))
	for i := range ccdi.Items {
		ccs[i] = &ClusterCost{
			ID: ccdi.Items[i].ID,
		}
	}
	return ccs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (ccdi *ClusterCostDeleteInputs) Load() error {
	if ccdi == nil {
		return errors.New("nil receiver")
	}

	return ccdi.LoadWith(ccdi.inputConfig.Context, ccdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (ccdi *ClusterCostDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if ccdi == nil {
		return errors.New("nil receiver")
	}

	if len(ccdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.ClusterCosts().Query()

	ids := make([]int, 0, len(ccdi.Items))

	for i := range ccdi.Items {
		if ccdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if ccdi.Items[i].ID != 0 {
			ids = append(ids, ccdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(clustercost.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ClusterCostQueryInput holds the query input of the ClusterCost entity.
type ClusterCostQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Refer *object.Refer `uri:"clustercost,default=\"\"" query:"-" json:"-"`
	ID    int           `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the ClusterCost entity for querying,
// after validating.
func (ccqi *ClusterCostQueryInput) Model() *ClusterCost {
	if ccqi == nil {
		return nil
	}

	return &ClusterCost{
		ID: ccqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (ccqi *ClusterCostQueryInput) Load() error {
	if ccqi == nil {
		return errors.New("nil receiver")
	}

	return ccqi.LoadWith(ccqi.inputConfig.Context, ccqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (ccqi *ClusterCostQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if ccqi == nil {
		return errors.New("nil receiver")
	}

	if ccqi.Refer != nil && *ccqi.Refer == "" {
		return nil
	}

	q := cs.ClusterCosts().Query()

	if ccqi.Refer != nil {
		if ccqi.Refer.IsNumeric() {
			q.Where(
				clustercost.ID(ccqi.Refer.Int()))
		} else {
			return errors.New("invalid identify refer of clustercost")
		}
	} else if ccqi.ID != 0 {
		q.Where(
			clustercost.ID(ccqi.ID))
	} else {
		return errors.New("invalid identify of clustercost")
	}

	ccqi.ID, err = q.OnlyID(ctx)
	return err
}

// ClusterCostQueryInputs holds the query input of the ClusterCost entities.
type ClusterCostQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (ccqi *ClusterCostQueryInputs) Load() error {
	if ccqi == nil {
		return errors.New("nil receiver")
	}

	return ccqi.LoadWith(ccqi.inputConfig.Context, ccqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (ccqi *ClusterCostQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if ccqi == nil {
		return errors.New("nil receiver")
	}

	return err
}

// ClusterCostUpdateInput holds the modification input of the ClusterCost entity.
type ClusterCostUpdateInput struct {
	ClusterCostQueryInput `uri:",inline" query:"-" json:",inline"`

	TotalCost      float64 `uri:"-" query:"-" json:"totalCost,omitempty"`
	Currency       int     `uri:"-" query:"-" json:"currency,omitempty"`
	AllocationCost float64 `uri:"-" query:"-" json:"allocationCost,omitempty"`
	IdleCost       float64 `uri:"-" query:"-" json:"idleCost,omitempty"`
	ManagementCost float64 `uri:"-" query:"-" json:"managementCost,omitempty"`
}

// Model returns the ClusterCost entity for modifying,
// after validating.
func (ccui *ClusterCostUpdateInput) Model() *ClusterCost {
	if ccui == nil {
		return nil
	}

	cc := &ClusterCost{
		ID:             ccui.ID,
		TotalCost:      ccui.TotalCost,
		Currency:       ccui.Currency,
		AllocationCost: ccui.AllocationCost,
		IdleCost:       ccui.IdleCost,
		ManagementCost: ccui.ManagementCost,
	}

	return cc
}

// ClusterCostUpdateInputs holds the modification input item of the ClusterCost entities.
type ClusterCostUpdateInputsItem struct {
	ID int `uri:"-" query:"-" json:"id"`

	TotalCost      float64 `uri:"-" query:"-" json:"totalCost,omitempty"`
	Currency       int     `uri:"-" query:"-" json:"currency,omitempty"`
	AllocationCost float64 `uri:"-" query:"-" json:"allocationCost,omitempty"`
	IdleCost       float64 `uri:"-" query:"-" json:"idleCost,omitempty"`
	ManagementCost float64 `uri:"-" query:"-" json:"managementCost,omitempty"`
}

// ClusterCostUpdateInputs holds the modification input of the ClusterCost entities.
type ClusterCostUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*ClusterCostUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ClusterCost entities for modifying,
// after validating.
func (ccui *ClusterCostUpdateInputs) Model() []*ClusterCost {
	if ccui == nil || len(ccui.Items) == 0 {
		return nil
	}

	ccs := make([]*ClusterCost, len(ccui.Items))

	for i := range ccui.Items {
		cc := &ClusterCost{
			ID:             ccui.Items[i].ID,
			TotalCost:      ccui.Items[i].TotalCost,
			Currency:       ccui.Items[i].Currency,
			AllocationCost: ccui.Items[i].AllocationCost,
			IdleCost:       ccui.Items[i].IdleCost,
			ManagementCost: ccui.Items[i].ManagementCost,
		}

		ccs[i] = cc
	}

	return ccs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (ccui *ClusterCostUpdateInputs) Load() error {
	if ccui == nil {
		return errors.New("nil receiver")
	}

	return ccui.LoadWith(ccui.inputConfig.Context, ccui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (ccui *ClusterCostUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if ccui == nil {
		return errors.New("nil receiver")
	}

	if len(ccui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.ClusterCosts().Query()

	ids := make([]int, 0, len(ccui.Items))

	for i := range ccui.Items {
		if ccui.Items[i] == nil {
			return errors.New("nil item")
		}

		if ccui.Items[i].ID != 0 {
			ids = append(ids, ccui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(clustercost.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ClusterCostOutput holds the output of the ClusterCost entity.
type ClusterCostOutput struct {
	ID             int       `json:"id,omitempty"`
	StartTime      time.Time `json:"startTime,omitempty"`
	EndTime        time.Time `json:"endTime,omitempty"`
	Minutes        float64   `json:"minutes,omitempty"`
	ClusterName    string    `json:"clusterName,omitempty"`
	TotalCost      float64   `json:"totalCost,omitempty"`
	Currency       int       `json:"currency,omitempty"`
	AllocationCost float64   `json:"allocationCost,omitempty"`
	IdleCost       float64   `json:"idleCost,omitempty"`
	ManagementCost float64   `json:"managementCost,omitempty"`
}

// View returns the output of ClusterCost.
func (cc *ClusterCost) View() *ClusterCostOutput {
	return ExposeClusterCost(cc)
}

// View returns the output of ClusterCosts.
func (ccs ClusterCosts) View() []*ClusterCostOutput {
	return ExposeClusterCosts(ccs)
}

// ExposeClusterCost converts the ClusterCost to ClusterCostOutput.
func ExposeClusterCost(cc *ClusterCost) *ClusterCostOutput {
	if cc == nil {
		return nil
	}

	cco := &ClusterCostOutput{
		ID:             cc.ID,
		StartTime:      cc.StartTime,
		EndTime:        cc.EndTime,
		Minutes:        cc.Minutes,
		ClusterName:    cc.ClusterName,
		TotalCost:      cc.TotalCost,
		Currency:       cc.Currency,
		AllocationCost: cc.AllocationCost,
		IdleCost:       cc.IdleCost,
		ManagementCost: cc.ManagementCost,
	}

	return cco
}

// ExposeClusterCosts converts the ClusterCost slice to ClusterCostOutput pointer slice.
func ExposeClusterCosts(ccs []*ClusterCost) []*ClusterCostOutput {
	if len(ccs) == 0 {
		return nil
	}

	ccos := make([]*ClusterCostOutput, len(ccs))
	for i := range ccs {
		ccos[i] = ExposeClusterCost(ccs[i])
	}
	return ccos
}
