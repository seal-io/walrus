// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/service"
	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/dao/types/object"
	"github.com/seal-io/seal/pkg/dao/types/property"
	"github.com/seal-io/seal/pkg/dao/types/status"
)

// ServiceCreateInput holds the creation input of the Service entity.
type ServiceCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment"`

	Template    types.TemplateVersionRef `uri:"-" query:"-" json:"template"`
	Name        string                   `uri:"-" query:"-" json:"name"`
	Description string                   `uri:"-" query:"-" json:"description,omitempty"`
	Labels      map[string]string        `uri:"-" query:"-" json:"labels,omitempty"`
	Attributes  property.Values          `uri:"-" query:"-" json:"attributes,omitempty"`
}

// Model returns the Service entity for creating,
// after validating.
func (sci *ServiceCreateInput) Model() *Service {
	if sci == nil {
		return nil
	}

	s := &Service{
		Template:    sci.Template,
		Name:        sci.Name,
		Description: sci.Description,
		Labels:      sci.Labels,
		Attributes:  sci.Attributes,
	}

	if sci.Project != nil {
		s.ProjectID = sci.Project.ID
	}
	if sci.Environment != nil {
		s.EnvironmentID = sci.Environment.ID
	}

	return s
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sci *ServiceCreateInput) Load() error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	return sci.LoadWith(sci.inputConfig.Context, sci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sci *ServiceCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sci == nil {
		return errors.New("nil receiver")
	}

	if sci.Project != nil {
		err = sci.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	if sci.Environment != nil {
		err = sci.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return nil
}

// ServiceCreateInputs holds the creation input item of the Service entities.
type ServiceCreateInputsItem struct {
	Template    types.TemplateVersionRef `uri:"-" query:"-" json:"template"`
	Name        string                   `uri:"-" query:"-" json:"name"`
	Description string                   `uri:"-" query:"-" json:"description,omitempty"`
	Labels      map[string]string        `uri:"-" query:"-" json:"labels,omitempty"`
	Attributes  property.Values          `uri:"-" query:"-" json:"attributes,omitempty"`
}

// ServiceCreateInputs holds the creation input of the Service entities.
type ServiceCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment"`

	Items []*ServiceCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Service entities for creating,
// after validating.
func (sci *ServiceCreateInputs) Model() []*Service {
	if sci == nil || len(sci.Items) == 0 {
		return nil
	}

	ss := make([]*Service, len(sci.Items))

	for i := range sci.Items {
		s := &Service{
			Template:    sci.Items[i].Template,
			Name:        sci.Items[i].Name,
			Description: sci.Items[i].Description,
			Labels:      sci.Items[i].Labels,
			Attributes:  sci.Items[i].Attributes,
		}

		if sci.Project != nil {
			s.ProjectID = sci.Project.ID
		}
		if sci.Environment != nil {
			s.EnvironmentID = sci.Environment.ID
		}

		ss[i] = s
	}

	return ss
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sci *ServiceCreateInputs) Load() error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	return sci.LoadWith(sci.inputConfig.Context, sci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sci *ServiceCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sci == nil {
		return errors.New("nil receiver")
	}

	if len(sci.Items) == 0 {
		return errors.New("empty items")
	}

	if sci.Project != nil {
		err = sci.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	if sci.Environment != nil {
		err = sci.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceDeleteInput holds the deletion input of the Service entity.
type ServiceDeleteInput = ServiceQueryInput

// ServiceDeleteInputs holds the deletion input item of the Service entities.
type ServiceDeleteInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`
}

// ServiceDeleteInputs holds the deletion input of the Service entities.
type ServiceDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment"`

	Items []*ServiceDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Service entities for deleting,
// after validating.
func (sdi *ServiceDeleteInputs) Model() []*Service {
	if sdi == nil || len(sdi.Items) == 0 {
		return nil
	}

	ss := make([]*Service, len(sdi.Items))
	for i := range sdi.Items {
		ss[i] = &Service{
			ID: sdi.Items[i].ID,
		}
	}
	return ss
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sdi *ServiceDeleteInputs) Load() error {
	if sdi == nil {
		return errors.New("nil receiver")
	}

	return sdi.LoadWith(sdi.inputConfig.Context, sdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sdi *ServiceDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sdi == nil {
		return errors.New("nil receiver")
	}

	if len(sdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Services().Query()

	if sdi.Project != nil {
		err = sdi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			service.ProjectID(sdi.Project.ID))
	}

	if sdi.Environment != nil {
		err = sdi.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			service.EnvironmentID(sdi.Environment.ID))
	}

	ids := make([]object.ID, 0, len(sdi.Items))

	for i := range sdi.Items {
		if sdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if sdi.Items[i].ID != "" {
			ids = append(ids, sdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(service.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ServiceQueryInput holds the query input of the Service entity.
type ServiceQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"-"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"-"`

	Refer *object.Refer `uri:"service,default=\"\"" query:"-" json:"-"`
	ID    object.ID     `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the Service entity for querying,
// after validating.
func (sqi *ServiceQueryInput) Model() *Service {
	if sqi == nil {
		return nil
	}

	return &Service{
		ID: sqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sqi *ServiceQueryInput) Load() error {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	return sqi.LoadWith(sqi.inputConfig.Context, sqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sqi *ServiceQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	if sqi.Refer != nil && *sqi.Refer == "" {
		return nil
	}

	q := cs.Services().Query()

	if sqi.Project != nil {
		err = sqi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			service.ProjectID(sqi.Project.ID))
	}

	if sqi.Environment != nil {
		err = sqi.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			service.EnvironmentID(sqi.Environment.ID))
	}

	if sqi.Refer != nil {
		if sqi.Refer.IsID() {
			q.Where(
				service.ID(sqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of service")
		}
	} else if sqi.ID != "" {
		q.Where(
			service.ID(sqi.ID))
	} else {
		return errors.New("invalid identify of service")
	}

	sqi.ID, err = q.OnlyID(ctx)
	return err
}

// ServiceQueryInputs holds the query input of the Service entities.
type ServiceQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sqi *ServiceQueryInputs) Load() error {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	return sqi.LoadWith(sqi.inputConfig.Context, sqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sqi *ServiceQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	if sqi.Project != nil {
		err = sqi.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	if sqi.Environment != nil {
		err = sqi.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return err
}

// ServiceUpdateInput holds the modification input of the Service entity.
type ServiceUpdateInput struct {
	ServiceQueryInput `uri:",inline" query:"-" json:",inline"`

	Name        string                   `uri:"-" query:"-" json:"name,omitempty"`
	Description string                   `uri:"-" query:"-" json:"description,omitempty"`
	Labels      map[string]string        `uri:"-" query:"-" json:"labels,omitempty"`
	Template    types.TemplateVersionRef `uri:"-" query:"-" json:"template,omitempty"`
	Attributes  property.Values          `uri:"-" query:"-" json:"attributes,omitempty"`
}

// Model returns the Service entity for modifying,
// after validating.
func (sui *ServiceUpdateInput) Model() *Service {
	if sui == nil {
		return nil
	}

	s := &Service{
		ID:          sui.ID,
		Name:        sui.Name,
		Description: sui.Description,
		Labels:      sui.Labels,
		Template:    sui.Template,
		Attributes:  sui.Attributes,
	}

	return s
}

// ServiceUpdateInputs holds the modification input item of the Service entities.
type ServiceUpdateInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`

	Name        string                   `uri:"-" query:"-" json:"name,omitempty"`
	Description string                   `uri:"-" query:"-" json:"description,omitempty"`
	Labels      map[string]string        `uri:"-" query:"-" json:"labels,omitempty"`
	Template    types.TemplateVersionRef `uri:"-" query:"-" json:"template,omitempty"`
	Attributes  property.Values          `uri:"-" query:"-" json:"attributes,omitempty"`
}

// ServiceUpdateInputs holds the modification input of the Service entities.
type ServiceUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Project     *ProjectQueryInput     `uri:",inline" query:"-" json:"project"`
	Environment *EnvironmentQueryInput `uri:",inline" query:"-" json:"environment"`

	Items []*ServiceUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Service entities for modifying,
// after validating.
func (sui *ServiceUpdateInputs) Model() []*Service {
	if sui == nil || len(sui.Items) == 0 {
		return nil
	}

	ss := make([]*Service, len(sui.Items))

	for i := range sui.Items {
		s := &Service{
			ID:          sui.Items[i].ID,
			Name:        sui.Items[i].Name,
			Description: sui.Items[i].Description,
			Labels:      sui.Items[i].Labels,
			Template:    sui.Items[i].Template,
			Attributes:  sui.Items[i].Attributes,
		}

		ss[i] = s
	}

	return ss
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sui *ServiceUpdateInputs) Load() error {
	if sui == nil {
		return errors.New("nil receiver")
	}

	return sui.LoadWith(sui.inputConfig.Context, sui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sui *ServiceUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sui == nil {
		return errors.New("nil receiver")
	}

	if len(sui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Services().Query()

	if sui.Project != nil {
		err = sui.Project.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			service.ProjectID(sui.Project.ID))
	}

	if sui.Environment != nil {
		err = sui.Environment.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			service.EnvironmentID(sui.Environment.ID))
	}

	ids := make([]object.ID, 0, len(sui.Items))

	for i := range sui.Items {
		if sui.Items[i] == nil {
			return errors.New("nil item")
		}

		if sui.Items[i].ID != "" {
			ids = append(ids, sui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(service.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ServiceOutput holds the output of the Service entity.
type ServiceOutput struct {
	ID          object.ID                `json:"id,omitempty"`
	Name        string                   `json:"name,omitempty"`
	Description string                   `json:"description,omitempty"`
	Labels      map[string]string        `json:"labels,omitempty"`
	CreateTime  *time.Time               `json:"createTime,omitempty"`
	UpdateTime  *time.Time               `json:"updateTime,omitempty"`
	Status      status.Status            `json:"status,omitempty"`
	Template    types.TemplateVersionRef `json:"template,omitempty"`
	Attributes  property.Values          `json:"attributes,omitempty"`

	Project     *ProjectOutput     `json:"project,omitempty"`
	Environment *EnvironmentOutput `json:"environment,omitempty"`
}

// View returns the output of Service.
func (s *Service) View() *ServiceOutput {
	return ExposeService(s)
}

// View returns the output of Services.
func (ss Services) View() []*ServiceOutput {
	return ExposeServices(ss)
}

// ExposeService converts the Service to ServiceOutput.
func ExposeService(s *Service) *ServiceOutput {
	if s == nil {
		return nil
	}

	so := &ServiceOutput{
		ID:          s.ID,
		Name:        s.Name,
		Description: s.Description,
		Labels:      s.Labels,
		CreateTime:  s.CreateTime,
		UpdateTime:  s.UpdateTime,
		Status:      s.Status,
		Template:    s.Template,
		Attributes:  s.Attributes,
	}

	if s.Edges.Project != nil {
		so.Project = ExposeProject(s.Edges.Project)
	} else if s.ProjectID != "" {
		so.Project = &ProjectOutput{
			ID: s.ProjectID,
		}
	}
	if s.Edges.Environment != nil {
		so.Environment = ExposeEnvironment(s.Edges.Environment)
	} else if s.EnvironmentID != "" {
		so.Environment = &EnvironmentOutput{
			ID: s.EnvironmentID,
		}
	}
	return so
}

// ExposeServices converts the Service slice to ServiceOutput pointer slice.
func ExposeServices(ss []*Service) []*ServiceOutput {
	if len(ss) == 0 {
		return nil
	}

	sos := make([]*ServiceOutput, len(ss))
	for i := range ss {
		sos[i] = ExposeService(ss[i])
	}
	return sos
}
