// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/serviceresource"
	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/dao/types/object"
)

// ServiceResourceCreateInput holds the creation input of the ServiceResource entity.
type ServiceResourceCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Service *ServiceQueryInput `uri:",inline" query:"-" json:"service"`

	Shape        string                      `uri:"-" query:"-" json:"shape"`
	DeployerType string                      `uri:"-" query:"-" json:"deployerType"`
	Name         string                      `uri:"-" query:"-" json:"name"`
	Type         string                      `uri:"-" query:"-" json:"type"`
	Mode         string                      `uri:"-" query:"-" json:"mode"`
	ProjectID    object.ID                   `uri:"-" query:"-" json:"projectID"`
	Status       types.ServiceResourceStatus `uri:"-" query:"-" json:"status,omitempty"`

	Components   []*ServiceResourceCreateInput             `uri:"-" query:"-" json:"components,omitempty"`
	Instances    []*ServiceResourceCreateInput             `uri:"-" query:"-" json:"instances,omitempty"`
	Dependencies []*ServiceResourceRelationshipCreateInput `uri:"-" query:"-" json:"dependencies,omitempty"`
}

// Model returns the ServiceResource entity for creating,
// after validating.
func (srci *ServiceResourceCreateInput) Model() *ServiceResource {
	if srci == nil {
		return nil
	}

	sr := &ServiceResource{
		Shape:        srci.Shape,
		DeployerType: srci.DeployerType,
		Name:         srci.Name,
		Type:         srci.Type,
		Mode:         srci.Mode,
		ProjectID:    srci.ProjectID,
		Status:       srci.Status,
	}

	if srci.Service != nil {
		sr.ServiceID = srci.Service.ID
	}

	for j := range srci.Components {
		if srci.Components[j] == nil {
			continue
		}
		sr.Edges.Components = append(sr.Edges.Components,
			srci.Components[j].Model())
	}
	for j := range srci.Instances {
		if srci.Instances[j] == nil {
			continue
		}
		sr.Edges.Instances = append(sr.Edges.Instances,
			srci.Instances[j].Model())
	}
	for j := range srci.Dependencies {
		if srci.Dependencies[j] == nil {
			continue
		}
		sr.Edges.Dependencies = append(sr.Edges.Dependencies,
			srci.Dependencies[j].Model())
	}
	return sr
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srci *ServiceResourceCreateInput) Load() error {
	if srci == nil {
		return errors.New("nil receiver")
	}

	return srci.LoadWith(srci.inputConfig.Context, srci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srci *ServiceResourceCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srci == nil {
		return errors.New("nil receiver")
	}

	if srci.Service != nil {
		err = srci.Service.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	for i := range srci.Components {
		if srci.Components[i] == nil {
			continue
		}
		err = srci.Components[i].LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	for i := range srci.Instances {
		if srci.Instances[i] == nil {
			continue
		}
		err = srci.Instances[i].LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	for i := range srci.Dependencies {
		if srci.Dependencies[i] == nil {
			continue
		}
		err = srci.Dependencies[i].LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceResourceCreateInputs holds the creation input item of the ServiceResource entities.
type ServiceResourceCreateInputsItem struct {
	Shape        string                      `uri:"-" query:"-" json:"shape"`
	DeployerType string                      `uri:"-" query:"-" json:"deployerType"`
	Name         string                      `uri:"-" query:"-" json:"name"`
	Type         string                      `uri:"-" query:"-" json:"type"`
	Mode         string                      `uri:"-" query:"-" json:"mode"`
	ProjectID    object.ID                   `uri:"-" query:"-" json:"projectID"`
	Status       types.ServiceResourceStatus `uri:"-" query:"-" json:"status,omitempty"`

	Components   []*ServiceResourceCreateInput             `uri:"-" query:"-" json:"components,omitempty"`
	Instances    []*ServiceResourceCreateInput             `uri:"-" query:"-" json:"instances,omitempty"`
	Dependencies []*ServiceResourceRelationshipCreateInput `uri:"-" query:"-" json:"dependencies,omitempty"`
}

// ServiceResourceCreateInputs holds the creation input of the ServiceResource entities.
type ServiceResourceCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Service *ServiceQueryInput `uri:",inline" query:"-" json:"service"`

	Items []*ServiceResourceCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ServiceResource entities for creating,
// after validating.
func (srci *ServiceResourceCreateInputs) Model() []*ServiceResource {
	if srci == nil || len(srci.Items) == 0 {
		return nil
	}

	srs := make([]*ServiceResource, len(srci.Items))

	for i := range srci.Items {
		sr := &ServiceResource{
			Shape:        srci.Items[i].Shape,
			DeployerType: srci.Items[i].DeployerType,
			Name:         srci.Items[i].Name,
			Type:         srci.Items[i].Type,
			Mode:         srci.Items[i].Mode,
			ProjectID:    srci.Items[i].ProjectID,
			Status:       srci.Items[i].Status,
		}

		if srci.Service != nil {
			sr.ServiceID = srci.Service.ID
		}

		for j := range srci.Items[i].Components {
			if srci.Items[i].Components[j] == nil {
				continue
			}
			sr.Edges.Components = append(sr.Edges.Components,
				srci.Items[i].Components[j].Model())
		}
		for j := range srci.Items[i].Instances {
			if srci.Items[i].Instances[j] == nil {
				continue
			}
			sr.Edges.Instances = append(sr.Edges.Instances,
				srci.Items[i].Instances[j].Model())
		}
		for j := range srci.Items[i].Dependencies {
			if srci.Items[i].Dependencies[j] == nil {
				continue
			}
			sr.Edges.Dependencies = append(sr.Edges.Dependencies,
				srci.Items[i].Dependencies[j].Model())
		}

		srs[i] = sr
	}

	return srs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srci *ServiceResourceCreateInputs) Load() error {
	if srci == nil {
		return errors.New("nil receiver")
	}

	return srci.LoadWith(srci.inputConfig.Context, srci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srci *ServiceResourceCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srci == nil {
		return errors.New("nil receiver")
	}

	if len(srci.Items) == 0 {
		return errors.New("empty items")
	}

	if srci.Service != nil {
		err = srci.Service.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceResourceDeleteInput holds the deletion input of the ServiceResource entity.
type ServiceResourceDeleteInput = ServiceResourceQueryInput

// ServiceResourceDeleteInputs holds the deletion input item of the ServiceResource entities.
type ServiceResourceDeleteInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`
}

// ServiceResourceDeleteInputs holds the deletion input of the ServiceResource entities.
type ServiceResourceDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Service *ServiceQueryInput `uri:",inline" query:"-" json:"service"`

	Items []*ServiceResourceDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ServiceResource entities for deleting,
// after validating.
func (srdi *ServiceResourceDeleteInputs) Model() []*ServiceResource {
	if srdi == nil || len(srdi.Items) == 0 {
		return nil
	}

	srs := make([]*ServiceResource, len(srdi.Items))
	for i := range srdi.Items {
		srs[i] = &ServiceResource{
			ID: srdi.Items[i].ID,
		}
	}
	return srs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srdi *ServiceResourceDeleteInputs) Load() error {
	if srdi == nil {
		return errors.New("nil receiver")
	}

	return srdi.LoadWith(srdi.inputConfig.Context, srdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srdi *ServiceResourceDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srdi == nil {
		return errors.New("nil receiver")
	}

	if len(srdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.ServiceResources().Query()

	if srdi.Service != nil {
		err = srdi.Service.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			serviceresource.ServiceID(srdi.Service.ID))
	}

	ids := make([]object.ID, 0, len(srdi.Items))

	for i := range srdi.Items {
		if srdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if srdi.Items[i].ID != "" {
			ids = append(ids, srdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(serviceresource.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ServiceResourceQueryInput holds the query input of the ServiceResource entity.
type ServiceResourceQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Service *ServiceQueryInput `uri:",inline" query:"-" json:"-"`

	Refer *object.Refer `uri:"serviceresource,default=\"\"" query:"-" json:"-"`
	ID    object.ID     `uri:"id" query:"-" json:"id"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
}

// Model returns the ServiceResource entity for querying,
// after validating.
func (srqi *ServiceResourceQueryInput) Model() *ServiceResource {
	if srqi == nil {
		return nil
	}

	return &ServiceResource{
		ID: srqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srqi *ServiceResourceQueryInput) Load() error {
	if srqi == nil {
		return errors.New("nil receiver")
	}

	return srqi.LoadWith(srqi.inputConfig.Context, srqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srqi *ServiceResourceQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srqi == nil {
		return errors.New("nil receiver")
	}

	if srqi.Refer != nil && *srqi.Refer == "" {
		return nil
	}

	q := cs.ServiceResources().Query()

	if srqi.Service != nil {
		err = srqi.Service.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			serviceresource.ServiceID(srqi.Service.ID))
	}

	if srqi.Refer != nil {
		if srqi.Refer.IsID() {
			q.Where(
				serviceresource.ID(srqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of serviceresource")
		}
	} else if srqi.ID != "" {
		q.Where(
			serviceresource.ID(srqi.ID))
	} else {
		return errors.New("invalid identify of serviceresource")
	}

	srqi.ID, err = q.OnlyID(ctx)
	return err
}

// ServiceResourceQueryInputs holds the query input of the ServiceResource entities.
type ServiceResourceQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Service *ServiceQueryInput `uri:",inline" query:"-" json:"service"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srqi *ServiceResourceQueryInputs) Load() error {
	if srqi == nil {
		return errors.New("nil receiver")
	}

	return srqi.LoadWith(srqi.inputConfig.Context, srqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srqi *ServiceResourceQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srqi == nil {
		return errors.New("nil receiver")
	}

	if srqi.Service != nil {
		err = srqi.Service.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}

	return err
}

// ServiceResourceUpdateInput holds the modification input of the ServiceResource entity.
type ServiceResourceUpdateInput struct {
	ServiceResourceQueryInput `uri:",inline" query:"-" json:",inline"`

	Status types.ServiceResourceStatus `uri:"-" query:"-" json:"status,omitempty"`

	Components   []*ServiceResourceUpdateInput             `uri:"-" query:"-" json:"components,omitempty"`
	Instances    []*ServiceResourceUpdateInput             `uri:"-" query:"-" json:"instances,omitempty"`
	Dependencies []*ServiceResourceRelationshipUpdateInput `uri:"-" query:"-" json:"dependencies,omitempty"`
}

// Model returns the ServiceResource entity for modifying,
// after validating.
func (srui *ServiceResourceUpdateInput) Model() *ServiceResource {
	if srui == nil {
		return nil
	}

	sr := &ServiceResource{
		ID:     srui.ID,
		Status: srui.Status,
	}

	for j := range srui.Components {
		if srui.Components[j] == nil {
			continue
		}
		sr.Edges.Components = append(sr.Edges.Components,
			srui.Components[j].Model())
	}
	for j := range srui.Instances {
		if srui.Instances[j] == nil {
			continue
		}
		sr.Edges.Instances = append(sr.Edges.Instances,
			srui.Instances[j].Model())
	}
	for j := range srui.Dependencies {
		if srui.Dependencies[j] == nil {
			continue
		}
		sr.Edges.Dependencies = append(sr.Edges.Dependencies,
			srui.Dependencies[j].Model())
	}
	return sr
}

// ServiceResourceUpdateInputs holds the modification input item of the ServiceResource entities.
type ServiceResourceUpdateInputsItem struct {
	ID object.ID `uri:"-" query:"-" json:"id"`

	Status types.ServiceResourceStatus `uri:"-" query:"-" json:"status,omitempty"`

	Components   []*ServiceResourceUpdateInput             `uri:"-" query:"-" json:"components,omitempty"`
	Instances    []*ServiceResourceUpdateInput             `uri:"-" query:"-" json:"instances,omitempty"`
	Dependencies []*ServiceResourceRelationshipUpdateInput `uri:"-" query:"-" json:"dependencies,omitempty"`
}

// ServiceResourceUpdateInputs holds the modification input of the ServiceResource entities.
type ServiceResourceUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Service *ServiceQueryInput `uri:",inline" query:"-" json:"service"`

	Items []*ServiceResourceUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the ServiceResource entities for modifying,
// after validating.
func (srui *ServiceResourceUpdateInputs) Model() []*ServiceResource {
	if srui == nil || len(srui.Items) == 0 {
		return nil
	}

	srs := make([]*ServiceResource, len(srui.Items))

	for i := range srui.Items {
		sr := &ServiceResource{
			ID:     srui.Items[i].ID,
			Status: srui.Items[i].Status,
		}

		for j := range srui.Items[i].Components {
			if srui.Items[i].Components[j] == nil {
				continue
			}
			sr.Edges.Components = append(sr.Edges.Components,
				srui.Items[i].Components[j].Model())
		}
		for j := range srui.Items[i].Instances {
			if srui.Items[i].Instances[j] == nil {
				continue
			}
			sr.Edges.Instances = append(sr.Edges.Instances,
				srui.Items[i].Instances[j].Model())
		}
		for j := range srui.Items[i].Dependencies {
			if srui.Items[i].Dependencies[j] == nil {
				continue
			}
			sr.Edges.Dependencies = append(sr.Edges.Dependencies,
				srui.Items[i].Dependencies[j].Model())
		}

		srs[i] = sr
	}

	return srs
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (srui *ServiceResourceUpdateInputs) Load() error {
	if srui == nil {
		return errors.New("nil receiver")
	}

	return srui.LoadWith(srui.inputConfig.Context, srui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (srui *ServiceResourceUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if srui == nil {
		return errors.New("nil receiver")
	}

	if len(srui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.ServiceResources().Query()

	if srui.Service != nil {
		err = srui.Service.LoadWith(ctx, cs)
		if err != nil {
			return err
		}
		q.Where(
			serviceresource.ServiceID(srui.Service.ID))
	}

	ids := make([]object.ID, 0, len(srui.Items))

	for i := range srui.Items {
		if srui.Items[i] == nil {
			return errors.New("nil item")
		}

		if srui.Items[i].ID != "" {
			ids = append(ids, srui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)

	idsCnt, err := q.Where(serviceresource.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ServiceResourceOutput holds the output of the ServiceResource entity.
type ServiceResourceOutput struct {
	ID           object.ID                           `json:"id,omitempty"`
	CreateTime   *time.Time                          `json:"createTime,omitempty"`
	UpdateTime   *time.Time                          `json:"updateTime,omitempty"`
	ProjectID    object.ID                           `json:"projectID,omitempty"`
	Mode         string                              `json:"mode,omitempty"`
	Type         string                              `json:"type,omitempty"`
	Name         string                              `json:"name,omitempty"`
	DeployerType string                              `json:"deployerType,omitempty"`
	Shape        string                              `json:"shape,omitempty"`
	Status       types.ServiceResourceStatus         `json:"status,omitempty"`
	Keys         *types.ServiceResourceOperationKeys `json:"keys,omitempty"`

	Service      *ServiceOutput                       `json:"service,omitempty"`
	Connector    *ConnectorOutput                     `json:"connector,omitempty"`
	Composition  *ServiceResourceOutput               `json:"composition,omitempty"`
	Components   []*ServiceResourceOutput             `json:"components,omitempty"`
	Class        *ServiceResourceOutput               `json:"class,omitempty"`
	Instances    []*ServiceResourceOutput             `json:"instances,omitempty"`
	Dependencies []*ServiceResourceRelationshipOutput `json:"dependencies,omitempty"`
}

// View returns the output of ServiceResource.
func (sr *ServiceResource) View() *ServiceResourceOutput {
	return ExposeServiceResource(sr)
}

// View returns the output of ServiceResources.
func (srs ServiceResources) View() []*ServiceResourceOutput {
	return ExposeServiceResources(srs)
}

// ExposeServiceResource converts the ServiceResource to ServiceResourceOutput.
func ExposeServiceResource(sr *ServiceResource) *ServiceResourceOutput {
	if sr == nil {
		return nil
	}

	sro := &ServiceResourceOutput{
		ID:           sr.ID,
		CreateTime:   sr.CreateTime,
		UpdateTime:   sr.UpdateTime,
		ProjectID:    sr.ProjectID,
		Mode:         sr.Mode,
		Type:         sr.Type,
		Name:         sr.Name,
		DeployerType: sr.DeployerType,
		Shape:        sr.Shape,
		Status:       sr.Status,
		Keys:         sr.Keys,
	}

	if sr.Edges.Service != nil {
		sro.Service = ExposeService(sr.Edges.Service)
	} else if sr.ServiceID != "" {
		sro.Service = &ServiceOutput{
			ID: sr.ServiceID,
		}
	}
	if sr.Edges.Connector != nil {
		sro.Connector = ExposeConnector(sr.Edges.Connector)
	} else if sr.ConnectorID != "" {
		sro.Connector = &ConnectorOutput{
			ID: sr.ConnectorID,
		}
	}
	if sr.Edges.Composition != nil {
		sro.Composition = ExposeServiceResource(sr.Edges.Composition)
	} else if sr.CompositionID != "" {
		sro.Composition = &ServiceResourceOutput{
			ID: sr.CompositionID,
		}
	}
	if sr.Edges.Components != nil {
		sro.Components = ExposeServiceResources(sr.Edges.Components)
	}
	if sr.Edges.Class != nil {
		sro.Class = ExposeServiceResource(sr.Edges.Class)
	} else if sr.ClassID != "" {
		sro.Class = &ServiceResourceOutput{
			ID: sr.ClassID,
		}
	}
	if sr.Edges.Instances != nil {
		sro.Instances = ExposeServiceResources(sr.Edges.Instances)
	}
	if sr.Edges.Dependencies != nil {
		sro.Dependencies = ExposeServiceResourceRelationships(sr.Edges.Dependencies)
	}
	return sro
}

// ExposeServiceResources converts the ServiceResource slice to ServiceResourceOutput pointer slice.
func ExposeServiceResources(srs []*ServiceResource) []*ServiceResourceOutput {
	if len(srs) == 0 {
		return nil
	}

	sros := make([]*ServiceResourceOutput, len(srs))
	for i := range srs {
		sros[i] = ExposeServiceResource(srs[i])
	}
	return sros
}
