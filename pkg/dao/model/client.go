// SPDX-FileCopyrightText: 2024 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/seal-io/walrus/pkg/dao/model/migrate"
	"github.com/seal-io/walrus/pkg/dao/types/object"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	"github.com/seal-io/walrus/pkg/dao/model/catalog"
	"github.com/seal-io/walrus/pkg/dao/model/connector"
	"github.com/seal-io/walrus/pkg/dao/model/costreport"
	"github.com/seal-io/walrus/pkg/dao/model/distributelock"
	"github.com/seal-io/walrus/pkg/dao/model/environment"
	"github.com/seal-io/walrus/pkg/dao/model/environmentconnectorrelationship"
	"github.com/seal-io/walrus/pkg/dao/model/perspective"
	"github.com/seal-io/walrus/pkg/dao/model/project"
	"github.com/seal-io/walrus/pkg/dao/model/resource"
	"github.com/seal-io/walrus/pkg/dao/model/resourcecomponent"
	"github.com/seal-io/walrus/pkg/dao/model/resourcecomponentrelationship"
	"github.com/seal-io/walrus/pkg/dao/model/resourcedefinition"
	"github.com/seal-io/walrus/pkg/dao/model/resourcedefinitionmatchingrule"
	"github.com/seal-io/walrus/pkg/dao/model/resourcerelationship"
	"github.com/seal-io/walrus/pkg/dao/model/resourcerun"
	"github.com/seal-io/walrus/pkg/dao/model/role"
	"github.com/seal-io/walrus/pkg/dao/model/setting"
	"github.com/seal-io/walrus/pkg/dao/model/subject"
	"github.com/seal-io/walrus/pkg/dao/model/subjectrolerelationship"
	"github.com/seal-io/walrus/pkg/dao/model/template"
	"github.com/seal-io/walrus/pkg/dao/model/templateversion"
	"github.com/seal-io/walrus/pkg/dao/model/token"
	"github.com/seal-io/walrus/pkg/dao/model/variable"
	"github.com/seal-io/walrus/pkg/dao/model/workflow"
	"github.com/seal-io/walrus/pkg/dao/model/workflowexecution"
	"github.com/seal-io/walrus/pkg/dao/model/workflowstage"
	"github.com/seal-io/walrus/pkg/dao/model/workflowstageexecution"
	"github.com/seal-io/walrus/pkg/dao/model/workflowstep"
	"github.com/seal-io/walrus/pkg/dao/model/workflowstepexecution"

	stdsql "database/sql"

	"github.com/seal-io/walrus/pkg/dao/model/internal"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Catalog is the client for interacting with the Catalog builders.
	Catalog *CatalogClient
	// Connector is the client for interacting with the Connector builders.
	Connector *ConnectorClient
	// CostReport is the client for interacting with the CostReport builders.
	CostReport *CostReportClient
	// DistributeLock is the client for interacting with the DistributeLock builders.
	DistributeLock *DistributeLockClient
	// Environment is the client for interacting with the Environment builders.
	Environment *EnvironmentClient
	// EnvironmentConnectorRelationship is the client for interacting with the EnvironmentConnectorRelationship builders.
	EnvironmentConnectorRelationship *EnvironmentConnectorRelationshipClient
	// Perspective is the client for interacting with the Perspective builders.
	Perspective *PerspectiveClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Resource is the client for interacting with the Resource builders.
	Resource *ResourceClient
	// ResourceComponent is the client for interacting with the ResourceComponent builders.
	ResourceComponent *ResourceComponentClient
	// ResourceComponentRelationship is the client for interacting with the ResourceComponentRelationship builders.
	ResourceComponentRelationship *ResourceComponentRelationshipClient
	// ResourceDefinition is the client for interacting with the ResourceDefinition builders.
	ResourceDefinition *ResourceDefinitionClient
	// ResourceDefinitionMatchingRule is the client for interacting with the ResourceDefinitionMatchingRule builders.
	ResourceDefinitionMatchingRule *ResourceDefinitionMatchingRuleClient
	// ResourceRelationship is the client for interacting with the ResourceRelationship builders.
	ResourceRelationship *ResourceRelationshipClient
	// ResourceRun is the client for interacting with the ResourceRun builders.
	ResourceRun *ResourceRunClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// Subject is the client for interacting with the Subject builders.
	Subject *SubjectClient
	// SubjectRoleRelationship is the client for interacting with the SubjectRoleRelationship builders.
	SubjectRoleRelationship *SubjectRoleRelationshipClient
	// Template is the client for interacting with the Template builders.
	Template *TemplateClient
	// TemplateVersion is the client for interacting with the TemplateVersion builders.
	TemplateVersion *TemplateVersionClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// Variable is the client for interacting with the Variable builders.
	Variable *VariableClient
	// Workflow is the client for interacting with the Workflow builders.
	Workflow *WorkflowClient
	// WorkflowExecution is the client for interacting with the WorkflowExecution builders.
	WorkflowExecution *WorkflowExecutionClient
	// WorkflowStage is the client for interacting with the WorkflowStage builders.
	WorkflowStage *WorkflowStageClient
	// WorkflowStageExecution is the client for interacting with the WorkflowStageExecution builders.
	WorkflowStageExecution *WorkflowStageExecutionClient
	// WorkflowStep is the client for interacting with the WorkflowStep builders.
	WorkflowStep *WorkflowStepClient
	// WorkflowStepExecution is the client for interacting with the WorkflowStepExecution builders.
	WorkflowStepExecution *WorkflowStepExecutionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Catalog = NewCatalogClient(c.config)
	c.Connector = NewConnectorClient(c.config)
	c.CostReport = NewCostReportClient(c.config)
	c.DistributeLock = NewDistributeLockClient(c.config)
	c.Environment = NewEnvironmentClient(c.config)
	c.EnvironmentConnectorRelationship = NewEnvironmentConnectorRelationshipClient(c.config)
	c.Perspective = NewPerspectiveClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Resource = NewResourceClient(c.config)
	c.ResourceComponent = NewResourceComponentClient(c.config)
	c.ResourceComponentRelationship = NewResourceComponentRelationshipClient(c.config)
	c.ResourceDefinition = NewResourceDefinitionClient(c.config)
	c.ResourceDefinitionMatchingRule = NewResourceDefinitionMatchingRuleClient(c.config)
	c.ResourceRelationship = NewResourceRelationshipClient(c.config)
	c.ResourceRun = NewResourceRunClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.Subject = NewSubjectClient(c.config)
	c.SubjectRoleRelationship = NewSubjectRoleRelationshipClient(c.config)
	c.Template = NewTemplateClient(c.config)
	c.TemplateVersion = NewTemplateVersionClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.Variable = NewVariableClient(c.config)
	c.Workflow = NewWorkflowClient(c.config)
	c.WorkflowExecution = NewWorkflowExecutionClient(c.config)
	c.WorkflowStage = NewWorkflowStageClient(c.config)
	c.WorkflowStageExecution = NewWorkflowStageExecutionClient(c.config)
	c.WorkflowStep = NewWorkflowStepClient(c.config)
	c.WorkflowStepExecution = NewWorkflowStepExecutionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
		// schemaConfig contains alternative names for all tables.
		schemaConfig SchemaConfig
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("model: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("model: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                              ctx,
		config:                           cfg,
		Catalog:                          NewCatalogClient(cfg),
		Connector:                        NewConnectorClient(cfg),
		CostReport:                       NewCostReportClient(cfg),
		DistributeLock:                   NewDistributeLockClient(cfg),
		Environment:                      NewEnvironmentClient(cfg),
		EnvironmentConnectorRelationship: NewEnvironmentConnectorRelationshipClient(cfg),
		Perspective:                      NewPerspectiveClient(cfg),
		Project:                          NewProjectClient(cfg),
		Resource:                         NewResourceClient(cfg),
		ResourceComponent:                NewResourceComponentClient(cfg),
		ResourceComponentRelationship:    NewResourceComponentRelationshipClient(cfg),
		ResourceDefinition:               NewResourceDefinitionClient(cfg),
		ResourceDefinitionMatchingRule:   NewResourceDefinitionMatchingRuleClient(cfg),
		ResourceRelationship:             NewResourceRelationshipClient(cfg),
		ResourceRun:                      NewResourceRunClient(cfg),
		Role:                             NewRoleClient(cfg),
		Setting:                          NewSettingClient(cfg),
		Subject:                          NewSubjectClient(cfg),
		SubjectRoleRelationship:          NewSubjectRoleRelationshipClient(cfg),
		Template:                         NewTemplateClient(cfg),
		TemplateVersion:                  NewTemplateVersionClient(cfg),
		Token:                            NewTokenClient(cfg),
		Variable:                         NewVariableClient(cfg),
		Workflow:                         NewWorkflowClient(cfg),
		WorkflowExecution:                NewWorkflowExecutionClient(cfg),
		WorkflowStage:                    NewWorkflowStageClient(cfg),
		WorkflowStageExecution:           NewWorkflowStageExecutionClient(cfg),
		WorkflowStep:                     NewWorkflowStepClient(cfg),
		WorkflowStepExecution:            NewWorkflowStepExecutionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                              ctx,
		config:                           cfg,
		Catalog:                          NewCatalogClient(cfg),
		Connector:                        NewConnectorClient(cfg),
		CostReport:                       NewCostReportClient(cfg),
		DistributeLock:                   NewDistributeLockClient(cfg),
		Environment:                      NewEnvironmentClient(cfg),
		EnvironmentConnectorRelationship: NewEnvironmentConnectorRelationshipClient(cfg),
		Perspective:                      NewPerspectiveClient(cfg),
		Project:                          NewProjectClient(cfg),
		Resource:                         NewResourceClient(cfg),
		ResourceComponent:                NewResourceComponentClient(cfg),
		ResourceComponentRelationship:    NewResourceComponentRelationshipClient(cfg),
		ResourceDefinition:               NewResourceDefinitionClient(cfg),
		ResourceDefinitionMatchingRule:   NewResourceDefinitionMatchingRuleClient(cfg),
		ResourceRelationship:             NewResourceRelationshipClient(cfg),
		ResourceRun:                      NewResourceRunClient(cfg),
		Role:                             NewRoleClient(cfg),
		Setting:                          NewSettingClient(cfg),
		Subject:                          NewSubjectClient(cfg),
		SubjectRoleRelationship:          NewSubjectRoleRelationshipClient(cfg),
		Template:                         NewTemplateClient(cfg),
		TemplateVersion:                  NewTemplateVersionClient(cfg),
		Token:                            NewTokenClient(cfg),
		Variable:                         NewVariableClient(cfg),
		Workflow:                         NewWorkflowClient(cfg),
		WorkflowExecution:                NewWorkflowExecutionClient(cfg),
		WorkflowStage:                    NewWorkflowStageClient(cfg),
		WorkflowStageExecution:           NewWorkflowStageExecutionClient(cfg),
		WorkflowStep:                     NewWorkflowStepClient(cfg),
		WorkflowStepExecution:            NewWorkflowStepExecutionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Catalog.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Catalog, c.Connector, c.CostReport, c.DistributeLock, c.Environment,
		c.EnvironmentConnectorRelationship, c.Perspective, c.Project, c.Resource,
		c.ResourceComponent, c.ResourceComponentRelationship, c.ResourceDefinition,
		c.ResourceDefinitionMatchingRule, c.ResourceRelationship, c.ResourceRun,
		c.Role, c.Setting, c.Subject, c.SubjectRoleRelationship, c.Template,
		c.TemplateVersion, c.Token, c.Variable, c.Workflow, c.WorkflowExecution,
		c.WorkflowStage, c.WorkflowStageExecution, c.WorkflowStep,
		c.WorkflowStepExecution,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Catalog, c.Connector, c.CostReport, c.DistributeLock, c.Environment,
		c.EnvironmentConnectorRelationship, c.Perspective, c.Project, c.Resource,
		c.ResourceComponent, c.ResourceComponentRelationship, c.ResourceDefinition,
		c.ResourceDefinitionMatchingRule, c.ResourceRelationship, c.ResourceRun,
		c.Role, c.Setting, c.Subject, c.SubjectRoleRelationship, c.Template,
		c.TemplateVersion, c.Token, c.Variable, c.Workflow, c.WorkflowExecution,
		c.WorkflowStage, c.WorkflowStageExecution, c.WorkflowStep,
		c.WorkflowStepExecution,
	} {
		n.Intercept(interceptors...)
	}
}

// Catalogs implements the ClientSet.
func (c *Client) Catalogs() *CatalogClient {
	return c.Catalog
}

// Connectors implements the ClientSet.
func (c *Client) Connectors() *ConnectorClient {
	return c.Connector
}

// CostReports implements the ClientSet.
func (c *Client) CostReports() *CostReportClient {
	return c.CostReport
}

// DistributeLocks implements the ClientSet.
func (c *Client) DistributeLocks() *DistributeLockClient {
	return c.DistributeLock
}

// Environments implements the ClientSet.
func (c *Client) Environments() *EnvironmentClient {
	return c.Environment
}

// EnvironmentConnectorRelationships implements the ClientSet.
func (c *Client) EnvironmentConnectorRelationships() *EnvironmentConnectorRelationshipClient {
	return c.EnvironmentConnectorRelationship
}

// Perspectives implements the ClientSet.
func (c *Client) Perspectives() *PerspectiveClient {
	return c.Perspective
}

// Projects implements the ClientSet.
func (c *Client) Projects() *ProjectClient {
	return c.Project
}

// Resources implements the ClientSet.
func (c *Client) Resources() *ResourceClient {
	return c.Resource
}

// ResourceComponents implements the ClientSet.
func (c *Client) ResourceComponents() *ResourceComponentClient {
	return c.ResourceComponent
}

// ResourceComponentRelationships implements the ClientSet.
func (c *Client) ResourceComponentRelationships() *ResourceComponentRelationshipClient {
	return c.ResourceComponentRelationship
}

// ResourceDefinitions implements the ClientSet.
func (c *Client) ResourceDefinitions() *ResourceDefinitionClient {
	return c.ResourceDefinition
}

// ResourceDefinitionMatchingRules implements the ClientSet.
func (c *Client) ResourceDefinitionMatchingRules() *ResourceDefinitionMatchingRuleClient {
	return c.ResourceDefinitionMatchingRule
}

// ResourceRelationships implements the ClientSet.
func (c *Client) ResourceRelationships() *ResourceRelationshipClient {
	return c.ResourceRelationship
}

// ResourceRuns implements the ClientSet.
func (c *Client) ResourceRuns() *ResourceRunClient {
	return c.ResourceRun
}

// Roles implements the ClientSet.
func (c *Client) Roles() *RoleClient {
	return c.Role
}

// Settings implements the ClientSet.
func (c *Client) Settings() *SettingClient {
	return c.Setting
}

// Subjects implements the ClientSet.
func (c *Client) Subjects() *SubjectClient {
	return c.Subject
}

// SubjectRoleRelationships implements the ClientSet.
func (c *Client) SubjectRoleRelationships() *SubjectRoleRelationshipClient {
	return c.SubjectRoleRelationship
}

// Templates implements the ClientSet.
func (c *Client) Templates() *TemplateClient {
	return c.Template
}

// TemplateVersions implements the ClientSet.
func (c *Client) TemplateVersions() *TemplateVersionClient {
	return c.TemplateVersion
}

// Tokens implements the ClientSet.
func (c *Client) Tokens() *TokenClient {
	return c.Token
}

// Variables implements the ClientSet.
func (c *Client) Variables() *VariableClient {
	return c.Variable
}

// Workflows implements the ClientSet.
func (c *Client) Workflows() *WorkflowClient {
	return c.Workflow
}

// WorkflowExecutions implements the ClientSet.
func (c *Client) WorkflowExecutions() *WorkflowExecutionClient {
	return c.WorkflowExecution
}

// WorkflowStages implements the ClientSet.
func (c *Client) WorkflowStages() *WorkflowStageClient {
	return c.WorkflowStage
}

// WorkflowStageExecutions implements the ClientSet.
func (c *Client) WorkflowStageExecutions() *WorkflowStageExecutionClient {
	return c.WorkflowStageExecution
}

// WorkflowSteps implements the ClientSet.
func (c *Client) WorkflowSteps() *WorkflowStepClient {
	return c.WorkflowStep
}

// WorkflowStepExecutions implements the ClientSet.
func (c *Client) WorkflowStepExecutions() *WorkflowStepExecutionClient {
	return c.WorkflowStepExecution
}

// Dialect returns the dialect name of the driver.
func (c *Client) Dialect() string {
	return c.driver.Dialect()
}

// WithDebug enables the debug mode of the client.
func (c *Client) WithDebug() ClientSet {
	return c.Debug()
}

// WithTx gives a new transactional client in the callback function,
// if already in a transaction, this will keep in the same transaction.
func (c *Client) WithTx(ctx context.Context, fn func(tx *Tx) error) (err error) {
	var tx *Tx
	tx, err = c.Tx(ctx)
	if err != nil {
		return
	}
	defer func() {
		if v := recover(); v != nil {
			switch vt := v.(type) {
			case error:
				err = fmt.Errorf("panic as %w", vt)
			default:
				err = fmt.Errorf("panic as %v", v)
			}
			if txErr := tx.Rollback(); txErr != nil {
				err = fmt.Errorf("try to rollback as received %w, but failed: %v", err, txErr)
			}
		}
	}()
	if err = fn(tx); err != nil {
		if txErr := tx.Rollback(); txErr != nil {
			err = fmt.Errorf("try to rollback as received %w, but failed: %v", err, txErr)
		}
		return
	}
	if txErr := tx.Commit(); txErr != nil {
		err = fmt.Errorf("try to commit, but failed: %v", txErr)
	}
	return
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CatalogMutation:
		return c.Catalog.mutate(ctx, m)
	case *ConnectorMutation:
		return c.Connector.mutate(ctx, m)
	case *CostReportMutation:
		return c.CostReport.mutate(ctx, m)
	case *DistributeLockMutation:
		return c.DistributeLock.mutate(ctx, m)
	case *EnvironmentMutation:
		return c.Environment.mutate(ctx, m)
	case *EnvironmentConnectorRelationshipMutation:
		return c.EnvironmentConnectorRelationship.mutate(ctx, m)
	case *PerspectiveMutation:
		return c.Perspective.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *ResourceMutation:
		return c.Resource.mutate(ctx, m)
	case *ResourceComponentMutation:
		return c.ResourceComponent.mutate(ctx, m)
	case *ResourceComponentRelationshipMutation:
		return c.ResourceComponentRelationship.mutate(ctx, m)
	case *ResourceDefinitionMutation:
		return c.ResourceDefinition.mutate(ctx, m)
	case *ResourceDefinitionMatchingRuleMutation:
		return c.ResourceDefinitionMatchingRule.mutate(ctx, m)
	case *ResourceRelationshipMutation:
		return c.ResourceRelationship.mutate(ctx, m)
	case *ResourceRunMutation:
		return c.ResourceRun.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *SettingMutation:
		return c.Setting.mutate(ctx, m)
	case *SubjectMutation:
		return c.Subject.mutate(ctx, m)
	case *SubjectRoleRelationshipMutation:
		return c.SubjectRoleRelationship.mutate(ctx, m)
	case *TemplateMutation:
		return c.Template.mutate(ctx, m)
	case *TemplateVersionMutation:
		return c.TemplateVersion.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *VariableMutation:
		return c.Variable.mutate(ctx, m)
	case *WorkflowMutation:
		return c.Workflow.mutate(ctx, m)
	case *WorkflowExecutionMutation:
		return c.WorkflowExecution.mutate(ctx, m)
	case *WorkflowStageMutation:
		return c.WorkflowStage.mutate(ctx, m)
	case *WorkflowStageExecutionMutation:
		return c.WorkflowStageExecution.mutate(ctx, m)
	case *WorkflowStepMutation:
		return c.WorkflowStep.mutate(ctx, m)
	case *WorkflowStepExecutionMutation:
		return c.WorkflowStepExecution.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("model: unknown mutation type %T", m)
	}
}

// CatalogClient is a client for the Catalog schema.
type CatalogClient struct {
	config
}

// NewCatalogClient returns a client for the Catalog from the given config.
func NewCatalogClient(c config) *CatalogClient {
	return &CatalogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `catalog.Hooks(f(g(h())))`.
func (c *CatalogClient) Use(hooks ...Hook) {
	c.hooks.Catalog = append(c.hooks.Catalog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `catalog.Intercept(f(g(h())))`.
func (c *CatalogClient) Intercept(interceptors ...Interceptor) {
	c.inters.Catalog = append(c.inters.Catalog, interceptors...)
}

// Create returns a builder for creating a Catalog entity.
func (c *CatalogClient) Create() *CatalogCreate {
	mutation := newCatalogMutation(c.config, OpCreate)
	return &CatalogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Catalog entities.
func (c *CatalogClient) CreateBulk(builders ...*CatalogCreate) *CatalogCreateBulk {
	return &CatalogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CatalogClient) MapCreateBulk(slice any, setFunc func(*CatalogCreate, int)) *CatalogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CatalogCreateBulk{err: fmt.Errorf("calling to CatalogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CatalogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CatalogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Catalog.
func (c *CatalogClient) Update() *CatalogUpdate {
	mutation := newCatalogMutation(c.config, OpUpdate)
	return &CatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CatalogClient) UpdateOne(ca *Catalog) *CatalogUpdateOne {
	mutation := newCatalogMutation(c.config, OpUpdateOne, withCatalog(ca))
	return &CatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CatalogClient) UpdateOneID(id object.ID) *CatalogUpdateOne {
	mutation := newCatalogMutation(c.config, OpUpdateOne, withCatalogID(id))
	return &CatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Catalog.
func (c *CatalogClient) Delete() *CatalogDelete {
	mutation := newCatalogMutation(c.config, OpDelete)
	return &CatalogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CatalogClient) DeleteOne(ca *Catalog) *CatalogDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CatalogClient) DeleteOneID(id object.ID) *CatalogDeleteOne {
	builder := c.Delete().Where(catalog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CatalogDeleteOne{builder}
}

// Query returns a query builder for Catalog.
func (c *CatalogClient) Query() *CatalogQuery {
	return &CatalogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCatalog},
		inters: c.Interceptors(),
	}
}

// Get returns a Catalog entity by its id.
func (c *CatalogClient) Get(ctx context.Context, id object.ID) (*Catalog, error) {
	return c.Query().Where(catalog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CatalogClient) GetX(ctx context.Context, id object.ID) *Catalog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTemplates queries the templates edge of a Catalog.
func (c *CatalogClient) QueryTemplates(ca *Catalog) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(catalog.Table, catalog.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, catalog.TemplatesTable, catalog.TemplatesColumn),
		)
		schemaConfig := ca.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Catalog.
func (c *CatalogClient) QueryProject(ca *Catalog) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(catalog.Table, catalog.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, catalog.ProjectTable, catalog.ProjectColumn),
		)
		schemaConfig := ca.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.Catalog
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CatalogClient) Hooks() []Hook {
	hooks := c.hooks.Catalog
	return append(hooks[:len(hooks):len(hooks)], catalog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CatalogClient) Interceptors() []Interceptor {
	inters := c.inters.Catalog
	return append(inters[:len(inters):len(inters)], catalog.Interceptors[:]...)
}

func (c *CatalogClient) mutate(ctx context.Context, m *CatalogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CatalogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CatalogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Catalog mutation op: %q", m.Op())
	}
}

// ConnectorClient is a client for the Connector schema.
type ConnectorClient struct {
	config
}

// NewConnectorClient returns a client for the Connector from the given config.
func NewConnectorClient(c config) *ConnectorClient {
	return &ConnectorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `connector.Hooks(f(g(h())))`.
func (c *ConnectorClient) Use(hooks ...Hook) {
	c.hooks.Connector = append(c.hooks.Connector, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `connector.Intercept(f(g(h())))`.
func (c *ConnectorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Connector = append(c.inters.Connector, interceptors...)
}

// Create returns a builder for creating a Connector entity.
func (c *ConnectorClient) Create() *ConnectorCreate {
	mutation := newConnectorMutation(c.config, OpCreate)
	return &ConnectorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Connector entities.
func (c *ConnectorClient) CreateBulk(builders ...*ConnectorCreate) *ConnectorCreateBulk {
	return &ConnectorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConnectorClient) MapCreateBulk(slice any, setFunc func(*ConnectorCreate, int)) *ConnectorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConnectorCreateBulk{err: fmt.Errorf("calling to ConnectorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConnectorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConnectorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Connector.
func (c *ConnectorClient) Update() *ConnectorUpdate {
	mutation := newConnectorMutation(c.config, OpUpdate)
	return &ConnectorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConnectorClient) UpdateOne(co *Connector) *ConnectorUpdateOne {
	mutation := newConnectorMutation(c.config, OpUpdateOne, withConnector(co))
	return &ConnectorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConnectorClient) UpdateOneID(id object.ID) *ConnectorUpdateOne {
	mutation := newConnectorMutation(c.config, OpUpdateOne, withConnectorID(id))
	return &ConnectorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Connector.
func (c *ConnectorClient) Delete() *ConnectorDelete {
	mutation := newConnectorMutation(c.config, OpDelete)
	return &ConnectorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConnectorClient) DeleteOne(co *Connector) *ConnectorDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConnectorClient) DeleteOneID(id object.ID) *ConnectorDeleteOne {
	builder := c.Delete().Where(connector.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConnectorDeleteOne{builder}
}

// Query returns a query builder for Connector.
func (c *ConnectorClient) Query() *ConnectorQuery {
	return &ConnectorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConnector},
		inters: c.Interceptors(),
	}
}

// Get returns a Connector entity by its id.
func (c *ConnectorClient) Get(ctx context.Context, id object.ID) (*Connector, error) {
	return c.Query().Where(connector.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConnectorClient) GetX(ctx context.Context, id object.ID) *Connector {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Connector.
func (c *ConnectorClient) QueryProject(co *Connector) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connector.Table, connector.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, connector.ProjectTable, connector.ProjectColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.Connector
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironments queries the environments edge of a Connector.
func (c *ConnectorClient) QueryEnvironments(co *Connector) *EnvironmentConnectorRelationshipQuery {
	query := (&EnvironmentConnectorRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connector.Table, connector.FieldID, id),
			sqlgraph.To(environmentconnectorrelationship.Table, environmentconnectorrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, connector.EnvironmentsTable, connector.EnvironmentsColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.EnvironmentConnectorRelationship
		step.Edge.Schema = schemaConfig.EnvironmentConnectorRelationship
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceComponents queries the resource_components edge of a Connector.
func (c *ConnectorClient) QueryResourceComponents(co *Connector) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connector.Table, connector.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, connector.ResourceComponentsTable, connector.ResourceComponentsColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCostReports queries the cost_reports edge of a Connector.
func (c *ConnectorClient) QueryCostReports(co *Connector) *CostReportQuery {
	query := (&CostReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connector.Table, connector.FieldID, id),
			sqlgraph.To(costreport.Table, costreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, connector.CostReportsTable, connector.CostReportsColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.CostReport
		step.Edge.Schema = schemaConfig.CostReport
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConnectorClient) Hooks() []Hook {
	hooks := c.hooks.Connector
	return append(hooks[:len(hooks):len(hooks)], connector.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ConnectorClient) Interceptors() []Interceptor {
	inters := c.inters.Connector
	return append(inters[:len(inters):len(inters)], connector.Interceptors[:]...)
}

func (c *ConnectorClient) mutate(ctx context.Context, m *ConnectorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConnectorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConnectorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConnectorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConnectorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Connector mutation op: %q", m.Op())
	}
}

// CostReportClient is a client for the CostReport schema.
type CostReportClient struct {
	config
}

// NewCostReportClient returns a client for the CostReport from the given config.
func NewCostReportClient(c config) *CostReportClient {
	return &CostReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `costreport.Hooks(f(g(h())))`.
func (c *CostReportClient) Use(hooks ...Hook) {
	c.hooks.CostReport = append(c.hooks.CostReport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `costreport.Intercept(f(g(h())))`.
func (c *CostReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.CostReport = append(c.inters.CostReport, interceptors...)
}

// Create returns a builder for creating a CostReport entity.
func (c *CostReportClient) Create() *CostReportCreate {
	mutation := newCostReportMutation(c.config, OpCreate)
	return &CostReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CostReport entities.
func (c *CostReportClient) CreateBulk(builders ...*CostReportCreate) *CostReportCreateBulk {
	return &CostReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CostReportClient) MapCreateBulk(slice any, setFunc func(*CostReportCreate, int)) *CostReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CostReportCreateBulk{err: fmt.Errorf("calling to CostReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CostReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CostReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CostReport.
func (c *CostReportClient) Update() *CostReportUpdate {
	mutation := newCostReportMutation(c.config, OpUpdate)
	return &CostReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CostReportClient) UpdateOne(cr *CostReport) *CostReportUpdateOne {
	mutation := newCostReportMutation(c.config, OpUpdateOne, withCostReport(cr))
	return &CostReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CostReportClient) UpdateOneID(id int) *CostReportUpdateOne {
	mutation := newCostReportMutation(c.config, OpUpdateOne, withCostReportID(id))
	return &CostReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CostReport.
func (c *CostReportClient) Delete() *CostReportDelete {
	mutation := newCostReportMutation(c.config, OpDelete)
	return &CostReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CostReportClient) DeleteOne(cr *CostReport) *CostReportDeleteOne {
	return c.DeleteOneID(cr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CostReportClient) DeleteOneID(id int) *CostReportDeleteOne {
	builder := c.Delete().Where(costreport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CostReportDeleteOne{builder}
}

// Query returns a query builder for CostReport.
func (c *CostReportClient) Query() *CostReportQuery {
	return &CostReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCostReport},
		inters: c.Interceptors(),
	}
}

// Get returns a CostReport entity by its id.
func (c *CostReportClient) Get(ctx context.Context, id int) (*CostReport, error) {
	return c.Query().Where(costreport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CostReportClient) GetX(ctx context.Context, id int) *CostReport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConnector queries the connector edge of a CostReport.
func (c *CostReportClient) QueryConnector(cr *CostReport) *ConnectorQuery {
	query := (&ConnectorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(costreport.Table, costreport.FieldID, id),
			sqlgraph.To(connector.Table, connector.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, costreport.ConnectorTable, costreport.ConnectorColumn),
		)
		schemaConfig := cr.schemaConfig
		step.To.Schema = schemaConfig.Connector
		step.Edge.Schema = schemaConfig.CostReport
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CostReportClient) Hooks() []Hook {
	hooks := c.hooks.CostReport
	return append(hooks[:len(hooks):len(hooks)], costreport.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CostReportClient) Interceptors() []Interceptor {
	return c.inters.CostReport
}

func (c *CostReportClient) mutate(ctx context.Context, m *CostReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CostReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CostReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CostReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CostReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown CostReport mutation op: %q", m.Op())
	}
}

// DistributeLockClient is a client for the DistributeLock schema.
type DistributeLockClient struct {
	config
}

// NewDistributeLockClient returns a client for the DistributeLock from the given config.
func NewDistributeLockClient(c config) *DistributeLockClient {
	return &DistributeLockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `distributelock.Hooks(f(g(h())))`.
func (c *DistributeLockClient) Use(hooks ...Hook) {
	c.hooks.DistributeLock = append(c.hooks.DistributeLock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `distributelock.Intercept(f(g(h())))`.
func (c *DistributeLockClient) Intercept(interceptors ...Interceptor) {
	c.inters.DistributeLock = append(c.inters.DistributeLock, interceptors...)
}

// Create returns a builder for creating a DistributeLock entity.
func (c *DistributeLockClient) Create() *DistributeLockCreate {
	mutation := newDistributeLockMutation(c.config, OpCreate)
	return &DistributeLockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DistributeLock entities.
func (c *DistributeLockClient) CreateBulk(builders ...*DistributeLockCreate) *DistributeLockCreateBulk {
	return &DistributeLockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DistributeLockClient) MapCreateBulk(slice any, setFunc func(*DistributeLockCreate, int)) *DistributeLockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DistributeLockCreateBulk{err: fmt.Errorf("calling to DistributeLockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DistributeLockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DistributeLockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DistributeLock.
func (c *DistributeLockClient) Update() *DistributeLockUpdate {
	mutation := newDistributeLockMutation(c.config, OpUpdate)
	return &DistributeLockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DistributeLockClient) UpdateOne(dl *DistributeLock) *DistributeLockUpdateOne {
	mutation := newDistributeLockMutation(c.config, OpUpdateOne, withDistributeLock(dl))
	return &DistributeLockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DistributeLockClient) UpdateOneID(id string) *DistributeLockUpdateOne {
	mutation := newDistributeLockMutation(c.config, OpUpdateOne, withDistributeLockID(id))
	return &DistributeLockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DistributeLock.
func (c *DistributeLockClient) Delete() *DistributeLockDelete {
	mutation := newDistributeLockMutation(c.config, OpDelete)
	return &DistributeLockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DistributeLockClient) DeleteOne(dl *DistributeLock) *DistributeLockDeleteOne {
	return c.DeleteOneID(dl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DistributeLockClient) DeleteOneID(id string) *DistributeLockDeleteOne {
	builder := c.Delete().Where(distributelock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DistributeLockDeleteOne{builder}
}

// Query returns a query builder for DistributeLock.
func (c *DistributeLockClient) Query() *DistributeLockQuery {
	return &DistributeLockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDistributeLock},
		inters: c.Interceptors(),
	}
}

// Get returns a DistributeLock entity by its id.
func (c *DistributeLockClient) Get(ctx context.Context, id string) (*DistributeLock, error) {
	return c.Query().Where(distributelock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DistributeLockClient) GetX(ctx context.Context, id string) *DistributeLock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DistributeLockClient) Hooks() []Hook {
	return c.hooks.DistributeLock
}

// Interceptors returns the client interceptors.
func (c *DistributeLockClient) Interceptors() []Interceptor {
	return c.inters.DistributeLock
}

func (c *DistributeLockClient) mutate(ctx context.Context, m *DistributeLockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DistributeLockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DistributeLockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DistributeLockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DistributeLockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown DistributeLock mutation op: %q", m.Op())
	}
}

// EnvironmentClient is a client for the Environment schema.
type EnvironmentClient struct {
	config
}

// NewEnvironmentClient returns a client for the Environment from the given config.
func NewEnvironmentClient(c config) *EnvironmentClient {
	return &EnvironmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `environment.Hooks(f(g(h())))`.
func (c *EnvironmentClient) Use(hooks ...Hook) {
	c.hooks.Environment = append(c.hooks.Environment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `environment.Intercept(f(g(h())))`.
func (c *EnvironmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Environment = append(c.inters.Environment, interceptors...)
}

// Create returns a builder for creating a Environment entity.
func (c *EnvironmentClient) Create() *EnvironmentCreate {
	mutation := newEnvironmentMutation(c.config, OpCreate)
	return &EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Environment entities.
func (c *EnvironmentClient) CreateBulk(builders ...*EnvironmentCreate) *EnvironmentCreateBulk {
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvironmentClient) MapCreateBulk(slice any, setFunc func(*EnvironmentCreate, int)) *EnvironmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvironmentCreateBulk{err: fmt.Errorf("calling to EnvironmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvironmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Environment.
func (c *EnvironmentClient) Update() *EnvironmentUpdate {
	mutation := newEnvironmentMutation(c.config, OpUpdate)
	return &EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvironmentClient) UpdateOne(e *Environment) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironment(e))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvironmentClient) UpdateOneID(id object.ID) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironmentID(id))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Environment.
func (c *EnvironmentClient) Delete() *EnvironmentDelete {
	mutation := newEnvironmentMutation(c.config, OpDelete)
	return &EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvironmentClient) DeleteOne(e *Environment) *EnvironmentDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvironmentClient) DeleteOneID(id object.ID) *EnvironmentDeleteOne {
	builder := c.Delete().Where(environment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvironmentDeleteOne{builder}
}

// Query returns a query builder for Environment.
func (c *EnvironmentClient) Query() *EnvironmentQuery {
	return &EnvironmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvironment},
		inters: c.Interceptors(),
	}
}

// Get returns a Environment entity by its id.
func (c *EnvironmentClient) Get(ctx context.Context, id object.ID) (*Environment, error) {
	return c.Query().Where(environment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvironmentClient) GetX(ctx context.Context, id object.ID) *Environment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Environment.
func (c *EnvironmentClient) QueryProject(e *Environment) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, environment.ProjectTable, environment.ProjectColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.Environment
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectors queries the connectors edge of a Environment.
func (c *EnvironmentClient) QueryConnectors(e *Environment) *EnvironmentConnectorRelationshipQuery {
	query := (&EnvironmentConnectorRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(environmentconnectorrelationship.Table, environmentconnectorrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, environment.ConnectorsTable, environment.ConnectorsColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.EnvironmentConnectorRelationship
		step.Edge.Schema = schemaConfig.EnvironmentConnectorRelationship
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResources queries the resources edge of a Environment.
func (c *EnvironmentClient) QueryResources(e *Environment) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.ResourcesTable, environment.ResourcesColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceRuns queries the resource_runs edge of a Environment.
func (c *EnvironmentClient) QueryResourceRuns(e *Environment) *ResourceRunQuery {
	query := (&ResourceRunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(resourcerun.Table, resourcerun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.ResourceRunsTable, environment.ResourceRunsColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.ResourceRun
		step.Edge.Schema = schemaConfig.ResourceRun
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceComponents queries the resource_components edge of a Environment.
func (c *EnvironmentClient) QueryResourceComponents(e *Environment) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.ResourceComponentsTable, environment.ResourceComponentsColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVariables queries the variables edge of a Environment.
func (c *EnvironmentClient) QueryVariables(e *Environment) *VariableQuery {
	query := (&VariableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(variable.Table, variable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.VariablesTable, environment.VariablesColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Variable
		step.Edge.Schema = schemaConfig.Variable
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvironmentClient) Hooks() []Hook {
	hooks := c.hooks.Environment
	return append(hooks[:len(hooks):len(hooks)], environment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EnvironmentClient) Interceptors() []Interceptor {
	inters := c.inters.Environment
	return append(inters[:len(inters):len(inters)], environment.Interceptors[:]...)
}

func (c *EnvironmentClient) mutate(ctx context.Context, m *EnvironmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Environment mutation op: %q", m.Op())
	}
}

// EnvironmentConnectorRelationshipClient is a client for the EnvironmentConnectorRelationship schema.
type EnvironmentConnectorRelationshipClient struct {
	config
}

// NewEnvironmentConnectorRelationshipClient returns a client for the EnvironmentConnectorRelationship from the given config.
func NewEnvironmentConnectorRelationshipClient(c config) *EnvironmentConnectorRelationshipClient {
	return &EnvironmentConnectorRelationshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `environmentconnectorrelationship.Hooks(f(g(h())))`.
func (c *EnvironmentConnectorRelationshipClient) Use(hooks ...Hook) {
	c.hooks.EnvironmentConnectorRelationship = append(c.hooks.EnvironmentConnectorRelationship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `environmentconnectorrelationship.Intercept(f(g(h())))`.
func (c *EnvironmentConnectorRelationshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnvironmentConnectorRelationship = append(c.inters.EnvironmentConnectorRelationship, interceptors...)
}

// Create returns a builder for creating a EnvironmentConnectorRelationship entity.
func (c *EnvironmentConnectorRelationshipClient) Create() *EnvironmentConnectorRelationshipCreate {
	mutation := newEnvironmentConnectorRelationshipMutation(c.config, OpCreate)
	return &EnvironmentConnectorRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnvironmentConnectorRelationship entities.
func (c *EnvironmentConnectorRelationshipClient) CreateBulk(builders ...*EnvironmentConnectorRelationshipCreate) *EnvironmentConnectorRelationshipCreateBulk {
	return &EnvironmentConnectorRelationshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvironmentConnectorRelationshipClient) MapCreateBulk(slice any, setFunc func(*EnvironmentConnectorRelationshipCreate, int)) *EnvironmentConnectorRelationshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvironmentConnectorRelationshipCreateBulk{err: fmt.Errorf("calling to EnvironmentConnectorRelationshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvironmentConnectorRelationshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvironmentConnectorRelationshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnvironmentConnectorRelationship.
func (c *EnvironmentConnectorRelationshipClient) Update() *EnvironmentConnectorRelationshipUpdate {
	mutation := newEnvironmentConnectorRelationshipMutation(c.config, OpUpdate)
	return &EnvironmentConnectorRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvironmentConnectorRelationshipClient) UpdateOne(ecr *EnvironmentConnectorRelationship) *EnvironmentConnectorRelationshipUpdateOne {
	mutation := newEnvironmentConnectorRelationshipMutation(c.config, OpUpdateOne, withEnvironmentConnectorRelationship(ecr))
	return &EnvironmentConnectorRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvironmentConnectorRelationshipClient) UpdateOneID(id object.ID) *EnvironmentConnectorRelationshipUpdateOne {
	mutation := newEnvironmentConnectorRelationshipMutation(c.config, OpUpdateOne, withEnvironmentConnectorRelationshipID(id))
	return &EnvironmentConnectorRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnvironmentConnectorRelationship.
func (c *EnvironmentConnectorRelationshipClient) Delete() *EnvironmentConnectorRelationshipDelete {
	mutation := newEnvironmentConnectorRelationshipMutation(c.config, OpDelete)
	return &EnvironmentConnectorRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvironmentConnectorRelationshipClient) DeleteOne(ecr *EnvironmentConnectorRelationship) *EnvironmentConnectorRelationshipDeleteOne {
	return c.DeleteOneID(ecr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvironmentConnectorRelationshipClient) DeleteOneID(id object.ID) *EnvironmentConnectorRelationshipDeleteOne {
	builder := c.Delete().Where(environmentconnectorrelationship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvironmentConnectorRelationshipDeleteOne{builder}
}

// Query returns a query builder for EnvironmentConnectorRelationship.
func (c *EnvironmentConnectorRelationshipClient) Query() *EnvironmentConnectorRelationshipQuery {
	return &EnvironmentConnectorRelationshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvironmentConnectorRelationship},
		inters: c.Interceptors(),
	}
}

// Get returns a EnvironmentConnectorRelationship entity by its id.
func (c *EnvironmentConnectorRelationshipClient) Get(ctx context.Context, id object.ID) (*EnvironmentConnectorRelationship, error) {
	return c.Query().Where(environmentconnectorrelationship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvironmentConnectorRelationshipClient) GetX(ctx context.Context, id object.ID) *EnvironmentConnectorRelationship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironment queries the environment edge of a EnvironmentConnectorRelationship.
func (c *EnvironmentConnectorRelationshipClient) QueryEnvironment(ecr *EnvironmentConnectorRelationship) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ecr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environmentconnectorrelationship.Table, environmentconnectorrelationship.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, environmentconnectorrelationship.EnvironmentTable, environmentconnectorrelationship.EnvironmentColumn),
		)
		schemaConfig := ecr.schemaConfig
		step.To.Schema = schemaConfig.Environment
		step.Edge.Schema = schemaConfig.EnvironmentConnectorRelationship
		fromV = sqlgraph.Neighbors(ecr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnector queries the connector edge of a EnvironmentConnectorRelationship.
func (c *EnvironmentConnectorRelationshipClient) QueryConnector(ecr *EnvironmentConnectorRelationship) *ConnectorQuery {
	query := (&ConnectorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ecr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environmentconnectorrelationship.Table, environmentconnectorrelationship.FieldID, id),
			sqlgraph.To(connector.Table, connector.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, environmentconnectorrelationship.ConnectorTable, environmentconnectorrelationship.ConnectorColumn),
		)
		schemaConfig := ecr.schemaConfig
		step.To.Schema = schemaConfig.Connector
		step.Edge.Schema = schemaConfig.EnvironmentConnectorRelationship
		fromV = sqlgraph.Neighbors(ecr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvironmentConnectorRelationshipClient) Hooks() []Hook {
	hooks := c.hooks.EnvironmentConnectorRelationship
	return append(hooks[:len(hooks):len(hooks)], environmentconnectorrelationship.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EnvironmentConnectorRelationshipClient) Interceptors() []Interceptor {
	return c.inters.EnvironmentConnectorRelationship
}

func (c *EnvironmentConnectorRelationshipClient) mutate(ctx context.Context, m *EnvironmentConnectorRelationshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvironmentConnectorRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvironmentConnectorRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvironmentConnectorRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvironmentConnectorRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown EnvironmentConnectorRelationship mutation op: %q", m.Op())
	}
}

// PerspectiveClient is a client for the Perspective schema.
type PerspectiveClient struct {
	config
}

// NewPerspectiveClient returns a client for the Perspective from the given config.
func NewPerspectiveClient(c config) *PerspectiveClient {
	return &PerspectiveClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `perspective.Hooks(f(g(h())))`.
func (c *PerspectiveClient) Use(hooks ...Hook) {
	c.hooks.Perspective = append(c.hooks.Perspective, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `perspective.Intercept(f(g(h())))`.
func (c *PerspectiveClient) Intercept(interceptors ...Interceptor) {
	c.inters.Perspective = append(c.inters.Perspective, interceptors...)
}

// Create returns a builder for creating a Perspective entity.
func (c *PerspectiveClient) Create() *PerspectiveCreate {
	mutation := newPerspectiveMutation(c.config, OpCreate)
	return &PerspectiveCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Perspective entities.
func (c *PerspectiveClient) CreateBulk(builders ...*PerspectiveCreate) *PerspectiveCreateBulk {
	return &PerspectiveCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PerspectiveClient) MapCreateBulk(slice any, setFunc func(*PerspectiveCreate, int)) *PerspectiveCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PerspectiveCreateBulk{err: fmt.Errorf("calling to PerspectiveClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PerspectiveCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PerspectiveCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Perspective.
func (c *PerspectiveClient) Update() *PerspectiveUpdate {
	mutation := newPerspectiveMutation(c.config, OpUpdate)
	return &PerspectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PerspectiveClient) UpdateOne(pe *Perspective) *PerspectiveUpdateOne {
	mutation := newPerspectiveMutation(c.config, OpUpdateOne, withPerspective(pe))
	return &PerspectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PerspectiveClient) UpdateOneID(id object.ID) *PerspectiveUpdateOne {
	mutation := newPerspectiveMutation(c.config, OpUpdateOne, withPerspectiveID(id))
	return &PerspectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Perspective.
func (c *PerspectiveClient) Delete() *PerspectiveDelete {
	mutation := newPerspectiveMutation(c.config, OpDelete)
	return &PerspectiveDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PerspectiveClient) DeleteOne(pe *Perspective) *PerspectiveDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PerspectiveClient) DeleteOneID(id object.ID) *PerspectiveDeleteOne {
	builder := c.Delete().Where(perspective.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PerspectiveDeleteOne{builder}
}

// Query returns a query builder for Perspective.
func (c *PerspectiveClient) Query() *PerspectiveQuery {
	return &PerspectiveQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePerspective},
		inters: c.Interceptors(),
	}
}

// Get returns a Perspective entity by its id.
func (c *PerspectiveClient) Get(ctx context.Context, id object.ID) (*Perspective, error) {
	return c.Query().Where(perspective.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PerspectiveClient) GetX(ctx context.Context, id object.ID) *Perspective {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PerspectiveClient) Hooks() []Hook {
	hooks := c.hooks.Perspective
	return append(hooks[:len(hooks):len(hooks)], perspective.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PerspectiveClient) Interceptors() []Interceptor {
	return c.inters.Perspective
}

func (c *PerspectiveClient) mutate(ctx context.Context, m *PerspectiveMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PerspectiveCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PerspectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PerspectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PerspectiveDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Perspective mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id object.ID) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id object.ID) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id object.ID) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id object.ID) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironments queries the environments edge of a Project.
func (c *ProjectClient) QueryEnvironments(pr *Project) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.EnvironmentsTable, project.EnvironmentsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Environment
		step.Edge.Schema = schemaConfig.Environment
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectors queries the connectors edge of a Project.
func (c *ProjectClient) QueryConnectors(pr *Project) *ConnectorQuery {
	query := (&ConnectorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(connector.Table, connector.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.ConnectorsTable, project.ConnectorsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Connector
		step.Edge.Schema = schemaConfig.Connector
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubjectRoles queries the subject_roles edge of a Project.
func (c *ProjectClient) QuerySubjectRoles(pr *Project) *SubjectRoleRelationshipQuery {
	query := (&SubjectRoleRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(subjectrolerelationship.Table, subjectrolerelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.SubjectRolesTable, project.SubjectRolesColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.SubjectRoleRelationship
		step.Edge.Schema = schemaConfig.SubjectRoleRelationship
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResources queries the resources edge of a Project.
func (c *ProjectClient) QueryResources(pr *Project) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.ResourcesTable, project.ResourcesColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceComponents queries the resource_components edge of a Project.
func (c *ProjectClient) QueryResourceComponents(pr *Project) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.ResourceComponentsTable, project.ResourceComponentsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceRuns queries the resource_runs edge of a Project.
func (c *ProjectClient) QueryResourceRuns(pr *Project) *ResourceRunQuery {
	query := (&ResourceRunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(resourcerun.Table, resourcerun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.ResourceRunsTable, project.ResourceRunsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.ResourceRun
		step.Edge.Schema = schemaConfig.ResourceRun
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVariables queries the variables edge of a Project.
func (c *ProjectClient) QueryVariables(pr *Project) *VariableQuery {
	query := (&VariableClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(variable.Table, variable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.VariablesTable, project.VariablesColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Variable
		step.Edge.Schema = schemaConfig.Variable
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplates queries the templates edge of a Project.
func (c *ProjectClient) QueryTemplates(pr *Project) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.TemplatesTable, project.TemplatesColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplateVersions queries the template_versions edge of a Project.
func (c *ProjectClient) QueryTemplateVersions(pr *Project) *TemplateVersionQuery {
	query := (&TemplateVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(templateversion.Table, templateversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.TemplateVersionsTable, project.TemplateVersionsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.TemplateVersion
		step.Edge.Schema = schemaConfig.TemplateVersion
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCatalogs queries the catalogs edge of a Project.
func (c *ProjectClient) QueryCatalogs(pr *Project) *CatalogQuery {
	query := (&CatalogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(catalog.Table, catalog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.CatalogsTable, project.CatalogsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Catalog
		step.Edge.Schema = schemaConfig.Catalog
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflows queries the workflows edge of a Project.
func (c *ProjectClient) QueryWorkflows(pr *Project) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.WorkflowsTable, project.WorkflowsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Workflow
		step.Edge.Schema = schemaConfig.Workflow
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowStages queries the workflow_stages edge of a Project.
func (c *ProjectClient) QueryWorkflowStages(pr *Project) *WorkflowStageQuery {
	query := (&WorkflowStageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(workflowstage.Table, workflowstage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.WorkflowStagesTable, project.WorkflowStagesColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStage
		step.Edge.Schema = schemaConfig.WorkflowStage
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowSteps queries the workflow_steps edge of a Project.
func (c *ProjectClient) QueryWorkflowSteps(pr *Project) *WorkflowStepQuery {
	query := (&WorkflowStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(workflowstep.Table, workflowstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.WorkflowStepsTable, project.WorkflowStepsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStep
		step.Edge.Schema = schemaConfig.WorkflowStep
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowExecutions queries the workflow_executions edge of a Project.
func (c *ProjectClient) QueryWorkflowExecutions(pr *Project) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.WorkflowExecutionsTable, project.WorkflowExecutionsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.WorkflowExecution
		step.Edge.Schema = schemaConfig.WorkflowExecution
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowStageExecutions queries the workflow_stage_executions edge of a Project.
func (c *ProjectClient) QueryWorkflowStageExecutions(pr *Project) *WorkflowStageExecutionQuery {
	query := (&WorkflowStageExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(workflowstageexecution.Table, workflowstageexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.WorkflowStageExecutionsTable, project.WorkflowStageExecutionsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStageExecution
		step.Edge.Schema = schemaConfig.WorkflowStageExecution
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowStepExecutions queries the workflow_step_executions edge of a Project.
func (c *ProjectClient) QueryWorkflowStepExecutions(pr *Project) *WorkflowStepExecutionQuery {
	query := (&WorkflowStepExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(workflowstepexecution.Table, workflowstepexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.WorkflowStepExecutionsTable, project.WorkflowStepExecutionsColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStepExecution
		step.Edge.Schema = schemaConfig.WorkflowStepExecution
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	hooks := c.hooks.Project
	return append(hooks[:len(hooks):len(hooks)], project.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	inters := c.inters.Project
	return append(inters[:len(inters):len(inters)], project.Interceptors[:]...)
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Project mutation op: %q", m.Op())
	}
}

// ResourceClient is a client for the Resource schema.
type ResourceClient struct {
	config
}

// NewResourceClient returns a client for the Resource from the given config.
func NewResourceClient(c config) *ResourceClient {
	return &ResourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resource.Hooks(f(g(h())))`.
func (c *ResourceClient) Use(hooks ...Hook) {
	c.hooks.Resource = append(c.hooks.Resource, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resource.Intercept(f(g(h())))`.
func (c *ResourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Resource = append(c.inters.Resource, interceptors...)
}

// Create returns a builder for creating a Resource entity.
func (c *ResourceClient) Create() *ResourceCreate {
	mutation := newResourceMutation(c.config, OpCreate)
	return &ResourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Resource entities.
func (c *ResourceClient) CreateBulk(builders ...*ResourceCreate) *ResourceCreateBulk {
	return &ResourceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceClient) MapCreateBulk(slice any, setFunc func(*ResourceCreate, int)) *ResourceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceCreateBulk{err: fmt.Errorf("calling to ResourceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Resource.
func (c *ResourceClient) Update() *ResourceUpdate {
	mutation := newResourceMutation(c.config, OpUpdate)
	return &ResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceClient) UpdateOne(r *Resource) *ResourceUpdateOne {
	mutation := newResourceMutation(c.config, OpUpdateOne, withResource(r))
	return &ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceClient) UpdateOneID(id object.ID) *ResourceUpdateOne {
	mutation := newResourceMutation(c.config, OpUpdateOne, withResourceID(id))
	return &ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Resource.
func (c *ResourceClient) Delete() *ResourceDelete {
	mutation := newResourceMutation(c.config, OpDelete)
	return &ResourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceClient) DeleteOne(r *Resource) *ResourceDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceClient) DeleteOneID(id object.ID) *ResourceDeleteOne {
	builder := c.Delete().Where(resource.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceDeleteOne{builder}
}

// Query returns a query builder for Resource.
func (c *ResourceClient) Query() *ResourceQuery {
	return &ResourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResource},
		inters: c.Interceptors(),
	}
}

// Get returns a Resource entity by its id.
func (c *ResourceClient) Get(ctx context.Context, id object.ID) (*Resource, error) {
	return c.Query().Where(resource.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceClient) GetX(ctx context.Context, id object.ID) *Resource {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Resource.
func (c *ResourceClient) QueryProject(r *Resource) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resource.ProjectTable, resource.ProjectColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the environment edge of a Resource.
func (c *ResourceClient) QueryEnvironment(r *Resource) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resource.EnvironmentTable, resource.EnvironmentColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.Environment
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a Resource.
func (c *ResourceClient) QueryTemplate(r *Resource) *TemplateVersionQuery {
	query := (&TemplateVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(templateversion.Table, templateversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resource.TemplateTable, resource.TemplateColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.TemplateVersion
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceDefinition queries the resource_definition edge of a Resource.
func (c *ResourceClient) QueryResourceDefinition(r *Resource) *ResourceDefinitionQuery {
	query := (&ResourceDefinitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resourcedefinition.Table, resourcedefinition.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resource.ResourceDefinitionTable, resource.ResourceDefinitionColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.ResourceDefinition
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceDefinitionMatchingRule queries the resource_definition_matching_rule edge of a Resource.
func (c *ResourceClient) QueryResourceDefinitionMatchingRule(r *Resource) *ResourceDefinitionMatchingRuleQuery {
	query := (&ResourceDefinitionMatchingRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resourcedefinitionmatchingrule.Table, resourcedefinitionmatchingrule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resource.ResourceDefinitionMatchingRuleTable, resource.ResourceDefinitionMatchingRuleColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.ResourceDefinitionMatchingRule
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRuns queries the runs edge of a Resource.
func (c *ResourceClient) QueryRuns(r *Resource) *ResourceRunQuery {
	query := (&ResourceRunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resourcerun.Table, resourcerun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, resource.RunsTable, resource.RunsColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.ResourceRun
		step.Edge.Schema = schemaConfig.ResourceRun
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a Resource.
func (c *ResourceClient) QueryComponents(r *Resource) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, resource.ComponentsTable, resource.ComponentsColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a Resource.
func (c *ResourceClient) QueryDependencies(r *Resource) *ResourceRelationshipQuery {
	query := (&ResourceRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resource.Table, resource.FieldID, id),
			sqlgraph.To(resourcerelationship.Table, resourcerelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, resource.DependenciesTable, resource.DependenciesColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.ResourceRelationship
		step.Edge.Schema = schemaConfig.ResourceRelationship
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceClient) Hooks() []Hook {
	hooks := c.hooks.Resource
	return append(hooks[:len(hooks):len(hooks)], resource.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ResourceClient) Interceptors() []Interceptor {
	inters := c.inters.Resource
	return append(inters[:len(inters):len(inters)], resource.Interceptors[:]...)
}

func (c *ResourceClient) mutate(ctx context.Context, m *ResourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Resource mutation op: %q", m.Op())
	}
}

// ResourceComponentClient is a client for the ResourceComponent schema.
type ResourceComponentClient struct {
	config
}

// NewResourceComponentClient returns a client for the ResourceComponent from the given config.
func NewResourceComponentClient(c config) *ResourceComponentClient {
	return &ResourceComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourcecomponent.Hooks(f(g(h())))`.
func (c *ResourceComponentClient) Use(hooks ...Hook) {
	c.hooks.ResourceComponent = append(c.hooks.ResourceComponent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourcecomponent.Intercept(f(g(h())))`.
func (c *ResourceComponentClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceComponent = append(c.inters.ResourceComponent, interceptors...)
}

// Create returns a builder for creating a ResourceComponent entity.
func (c *ResourceComponentClient) Create() *ResourceComponentCreate {
	mutation := newResourceComponentMutation(c.config, OpCreate)
	return &ResourceComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceComponent entities.
func (c *ResourceComponentClient) CreateBulk(builders ...*ResourceComponentCreate) *ResourceComponentCreateBulk {
	return &ResourceComponentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceComponentClient) MapCreateBulk(slice any, setFunc func(*ResourceComponentCreate, int)) *ResourceComponentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceComponentCreateBulk{err: fmt.Errorf("calling to ResourceComponentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceComponentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceComponent.
func (c *ResourceComponentClient) Update() *ResourceComponentUpdate {
	mutation := newResourceComponentMutation(c.config, OpUpdate)
	return &ResourceComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceComponentClient) UpdateOne(rc *ResourceComponent) *ResourceComponentUpdateOne {
	mutation := newResourceComponentMutation(c.config, OpUpdateOne, withResourceComponent(rc))
	return &ResourceComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceComponentClient) UpdateOneID(id object.ID) *ResourceComponentUpdateOne {
	mutation := newResourceComponentMutation(c.config, OpUpdateOne, withResourceComponentID(id))
	return &ResourceComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceComponent.
func (c *ResourceComponentClient) Delete() *ResourceComponentDelete {
	mutation := newResourceComponentMutation(c.config, OpDelete)
	return &ResourceComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceComponentClient) DeleteOne(rc *ResourceComponent) *ResourceComponentDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceComponentClient) DeleteOneID(id object.ID) *ResourceComponentDeleteOne {
	builder := c.Delete().Where(resourcecomponent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceComponentDeleteOne{builder}
}

// Query returns a query builder for ResourceComponent.
func (c *ResourceComponentClient) Query() *ResourceComponentQuery {
	return &ResourceComponentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceComponent},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceComponent entity by its id.
func (c *ResourceComponentClient) Get(ctx context.Context, id object.ID) (*ResourceComponent, error) {
	return c.Query().Where(resourcecomponent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceComponentClient) GetX(ctx context.Context, id object.ID) *ResourceComponent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryProject(rc *ResourceComponent) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcecomponent.ProjectTable, resourcecomponent.ProjectColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the environment edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryEnvironment(rc *ResourceComponent) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcecomponent.EnvironmentTable, resourcecomponent.EnvironmentColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.Environment
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResource queries the resource edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryResource(rc *ResourceComponent) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcecomponent.ResourceTable, resourcecomponent.ResourceColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnector queries the connector edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryConnector(rc *ResourceComponent) *ConnectorQuery {
	query := (&ConnectorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(connector.Table, connector.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcecomponent.ConnectorTable, resourcecomponent.ConnectorColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.Connector
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComposition queries the composition edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryComposition(rc *ResourceComponent) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcecomponent.CompositionTable, resourcecomponent.CompositionColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryComponents(rc *ResourceComponent) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, resourcecomponent.ComponentsTable, resourcecomponent.ComponentsColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClass queries the class edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryClass(rc *ResourceComponent) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcecomponent.ClassTable, resourcecomponent.ClassColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryInstances(rc *ResourceComponent) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, resourcecomponent.InstancesTable, resourcecomponent.InstancesColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponent
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a ResourceComponent.
func (c *ResourceComponentClient) QueryDependencies(rc *ResourceComponent) *ResourceComponentRelationshipQuery {
	query := (&ResourceComponentRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponent.Table, resourcecomponent.FieldID, id),
			sqlgraph.To(resourcecomponentrelationship.Table, resourcecomponentrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, resourcecomponent.DependenciesTable, resourcecomponent.DependenciesColumn),
		)
		schemaConfig := rc.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponentRelationship
		step.Edge.Schema = schemaConfig.ResourceComponentRelationship
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceComponentClient) Hooks() []Hook {
	hooks := c.hooks.ResourceComponent
	return append(hooks[:len(hooks):len(hooks)], resourcecomponent.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ResourceComponentClient) Interceptors() []Interceptor {
	inters := c.inters.ResourceComponent
	return append(inters[:len(inters):len(inters)], resourcecomponent.Interceptors[:]...)
}

func (c *ResourceComponentClient) mutate(ctx context.Context, m *ResourceComponentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceComponentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceComponentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown ResourceComponent mutation op: %q", m.Op())
	}
}

// ResourceComponentRelationshipClient is a client for the ResourceComponentRelationship schema.
type ResourceComponentRelationshipClient struct {
	config
}

// NewResourceComponentRelationshipClient returns a client for the ResourceComponentRelationship from the given config.
func NewResourceComponentRelationshipClient(c config) *ResourceComponentRelationshipClient {
	return &ResourceComponentRelationshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourcecomponentrelationship.Hooks(f(g(h())))`.
func (c *ResourceComponentRelationshipClient) Use(hooks ...Hook) {
	c.hooks.ResourceComponentRelationship = append(c.hooks.ResourceComponentRelationship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourcecomponentrelationship.Intercept(f(g(h())))`.
func (c *ResourceComponentRelationshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceComponentRelationship = append(c.inters.ResourceComponentRelationship, interceptors...)
}

// Create returns a builder for creating a ResourceComponentRelationship entity.
func (c *ResourceComponentRelationshipClient) Create() *ResourceComponentRelationshipCreate {
	mutation := newResourceComponentRelationshipMutation(c.config, OpCreate)
	return &ResourceComponentRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceComponentRelationship entities.
func (c *ResourceComponentRelationshipClient) CreateBulk(builders ...*ResourceComponentRelationshipCreate) *ResourceComponentRelationshipCreateBulk {
	return &ResourceComponentRelationshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceComponentRelationshipClient) MapCreateBulk(slice any, setFunc func(*ResourceComponentRelationshipCreate, int)) *ResourceComponentRelationshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceComponentRelationshipCreateBulk{err: fmt.Errorf("calling to ResourceComponentRelationshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceComponentRelationshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceComponentRelationshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceComponentRelationship.
func (c *ResourceComponentRelationshipClient) Update() *ResourceComponentRelationshipUpdate {
	mutation := newResourceComponentRelationshipMutation(c.config, OpUpdate)
	return &ResourceComponentRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceComponentRelationshipClient) UpdateOne(rcr *ResourceComponentRelationship) *ResourceComponentRelationshipUpdateOne {
	mutation := newResourceComponentRelationshipMutation(c.config, OpUpdateOne, withResourceComponentRelationship(rcr))
	return &ResourceComponentRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceComponentRelationshipClient) UpdateOneID(id object.ID) *ResourceComponentRelationshipUpdateOne {
	mutation := newResourceComponentRelationshipMutation(c.config, OpUpdateOne, withResourceComponentRelationshipID(id))
	return &ResourceComponentRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceComponentRelationship.
func (c *ResourceComponentRelationshipClient) Delete() *ResourceComponentRelationshipDelete {
	mutation := newResourceComponentRelationshipMutation(c.config, OpDelete)
	return &ResourceComponentRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceComponentRelationshipClient) DeleteOne(rcr *ResourceComponentRelationship) *ResourceComponentRelationshipDeleteOne {
	return c.DeleteOneID(rcr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceComponentRelationshipClient) DeleteOneID(id object.ID) *ResourceComponentRelationshipDeleteOne {
	builder := c.Delete().Where(resourcecomponentrelationship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceComponentRelationshipDeleteOne{builder}
}

// Query returns a query builder for ResourceComponentRelationship.
func (c *ResourceComponentRelationshipClient) Query() *ResourceComponentRelationshipQuery {
	return &ResourceComponentRelationshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceComponentRelationship},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceComponentRelationship entity by its id.
func (c *ResourceComponentRelationshipClient) Get(ctx context.Context, id object.ID) (*ResourceComponentRelationship, error) {
	return c.Query().Where(resourcecomponentrelationship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceComponentRelationshipClient) GetX(ctx context.Context, id object.ID) *ResourceComponentRelationship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResourceComponent queries the resource_component edge of a ResourceComponentRelationship.
func (c *ResourceComponentRelationshipClient) QueryResourceComponent(rcr *ResourceComponentRelationship) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rcr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponentrelationship.Table, resourcecomponentrelationship.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, resourcecomponentrelationship.ResourceComponentTable, resourcecomponentrelationship.ResourceComponentColumn),
		)
		schemaConfig := rcr.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponentRelationship
		fromV = sqlgraph.Neighbors(rcr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependency queries the dependency edge of a ResourceComponentRelationship.
func (c *ResourceComponentRelationshipClient) QueryDependency(rcr *ResourceComponentRelationship) *ResourceComponentQuery {
	query := (&ResourceComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rcr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcecomponentrelationship.Table, resourcecomponentrelationship.FieldID, id),
			sqlgraph.To(resourcecomponent.Table, resourcecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, resourcecomponentrelationship.DependencyTable, resourcecomponentrelationship.DependencyColumn),
		)
		schemaConfig := rcr.schemaConfig
		step.To.Schema = schemaConfig.ResourceComponent
		step.Edge.Schema = schemaConfig.ResourceComponentRelationship
		fromV = sqlgraph.Neighbors(rcr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceComponentRelationshipClient) Hooks() []Hook {
	hooks := c.hooks.ResourceComponentRelationship
	return append(hooks[:len(hooks):len(hooks)], resourcecomponentrelationship.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ResourceComponentRelationshipClient) Interceptors() []Interceptor {
	return c.inters.ResourceComponentRelationship
}

func (c *ResourceComponentRelationshipClient) mutate(ctx context.Context, m *ResourceComponentRelationshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceComponentRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceComponentRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceComponentRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceComponentRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown ResourceComponentRelationship mutation op: %q", m.Op())
	}
}

// ResourceDefinitionClient is a client for the ResourceDefinition schema.
type ResourceDefinitionClient struct {
	config
}

// NewResourceDefinitionClient returns a client for the ResourceDefinition from the given config.
func NewResourceDefinitionClient(c config) *ResourceDefinitionClient {
	return &ResourceDefinitionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourcedefinition.Hooks(f(g(h())))`.
func (c *ResourceDefinitionClient) Use(hooks ...Hook) {
	c.hooks.ResourceDefinition = append(c.hooks.ResourceDefinition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourcedefinition.Intercept(f(g(h())))`.
func (c *ResourceDefinitionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceDefinition = append(c.inters.ResourceDefinition, interceptors...)
}

// Create returns a builder for creating a ResourceDefinition entity.
func (c *ResourceDefinitionClient) Create() *ResourceDefinitionCreate {
	mutation := newResourceDefinitionMutation(c.config, OpCreate)
	return &ResourceDefinitionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceDefinition entities.
func (c *ResourceDefinitionClient) CreateBulk(builders ...*ResourceDefinitionCreate) *ResourceDefinitionCreateBulk {
	return &ResourceDefinitionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceDefinitionClient) MapCreateBulk(slice any, setFunc func(*ResourceDefinitionCreate, int)) *ResourceDefinitionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceDefinitionCreateBulk{err: fmt.Errorf("calling to ResourceDefinitionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceDefinitionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceDefinitionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceDefinition.
func (c *ResourceDefinitionClient) Update() *ResourceDefinitionUpdate {
	mutation := newResourceDefinitionMutation(c.config, OpUpdate)
	return &ResourceDefinitionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceDefinitionClient) UpdateOne(rd *ResourceDefinition) *ResourceDefinitionUpdateOne {
	mutation := newResourceDefinitionMutation(c.config, OpUpdateOne, withResourceDefinition(rd))
	return &ResourceDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceDefinitionClient) UpdateOneID(id object.ID) *ResourceDefinitionUpdateOne {
	mutation := newResourceDefinitionMutation(c.config, OpUpdateOne, withResourceDefinitionID(id))
	return &ResourceDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceDefinition.
func (c *ResourceDefinitionClient) Delete() *ResourceDefinitionDelete {
	mutation := newResourceDefinitionMutation(c.config, OpDelete)
	return &ResourceDefinitionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceDefinitionClient) DeleteOne(rd *ResourceDefinition) *ResourceDefinitionDeleteOne {
	return c.DeleteOneID(rd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceDefinitionClient) DeleteOneID(id object.ID) *ResourceDefinitionDeleteOne {
	builder := c.Delete().Where(resourcedefinition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceDefinitionDeleteOne{builder}
}

// Query returns a query builder for ResourceDefinition.
func (c *ResourceDefinitionClient) Query() *ResourceDefinitionQuery {
	return &ResourceDefinitionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceDefinition},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceDefinition entity by its id.
func (c *ResourceDefinitionClient) Get(ctx context.Context, id object.ID) (*ResourceDefinition, error) {
	return c.Query().Where(resourcedefinition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceDefinitionClient) GetX(ctx context.Context, id object.ID) *ResourceDefinition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMatchingRules queries the matching_rules edge of a ResourceDefinition.
func (c *ResourceDefinitionClient) QueryMatchingRules(rd *ResourceDefinition) *ResourceDefinitionMatchingRuleQuery {
	query := (&ResourceDefinitionMatchingRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcedefinition.Table, resourcedefinition.FieldID, id),
			sqlgraph.To(resourcedefinitionmatchingrule.Table, resourcedefinitionmatchingrule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, resourcedefinition.MatchingRulesTable, resourcedefinition.MatchingRulesColumn),
		)
		schemaConfig := rd.schemaConfig
		step.To.Schema = schemaConfig.ResourceDefinitionMatchingRule
		step.Edge.Schema = schemaConfig.ResourceDefinitionMatchingRule
		fromV = sqlgraph.Neighbors(rd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResources queries the resources edge of a ResourceDefinition.
func (c *ResourceDefinitionClient) QueryResources(rd *ResourceDefinition) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcedefinition.Table, resourcedefinition.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, resourcedefinition.ResourcesTable, resourcedefinition.ResourcesColumn),
		)
		schemaConfig := rd.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(rd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceDefinitionClient) Hooks() []Hook {
	hooks := c.hooks.ResourceDefinition
	return append(hooks[:len(hooks):len(hooks)], resourcedefinition.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ResourceDefinitionClient) Interceptors() []Interceptor {
	return c.inters.ResourceDefinition
}

func (c *ResourceDefinitionClient) mutate(ctx context.Context, m *ResourceDefinitionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceDefinitionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceDefinitionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceDefinitionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown ResourceDefinition mutation op: %q", m.Op())
	}
}

// ResourceDefinitionMatchingRuleClient is a client for the ResourceDefinitionMatchingRule schema.
type ResourceDefinitionMatchingRuleClient struct {
	config
}

// NewResourceDefinitionMatchingRuleClient returns a client for the ResourceDefinitionMatchingRule from the given config.
func NewResourceDefinitionMatchingRuleClient(c config) *ResourceDefinitionMatchingRuleClient {
	return &ResourceDefinitionMatchingRuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourcedefinitionmatchingrule.Hooks(f(g(h())))`.
func (c *ResourceDefinitionMatchingRuleClient) Use(hooks ...Hook) {
	c.hooks.ResourceDefinitionMatchingRule = append(c.hooks.ResourceDefinitionMatchingRule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourcedefinitionmatchingrule.Intercept(f(g(h())))`.
func (c *ResourceDefinitionMatchingRuleClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceDefinitionMatchingRule = append(c.inters.ResourceDefinitionMatchingRule, interceptors...)
}

// Create returns a builder for creating a ResourceDefinitionMatchingRule entity.
func (c *ResourceDefinitionMatchingRuleClient) Create() *ResourceDefinitionMatchingRuleCreate {
	mutation := newResourceDefinitionMatchingRuleMutation(c.config, OpCreate)
	return &ResourceDefinitionMatchingRuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceDefinitionMatchingRule entities.
func (c *ResourceDefinitionMatchingRuleClient) CreateBulk(builders ...*ResourceDefinitionMatchingRuleCreate) *ResourceDefinitionMatchingRuleCreateBulk {
	return &ResourceDefinitionMatchingRuleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceDefinitionMatchingRuleClient) MapCreateBulk(slice any, setFunc func(*ResourceDefinitionMatchingRuleCreate, int)) *ResourceDefinitionMatchingRuleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceDefinitionMatchingRuleCreateBulk{err: fmt.Errorf("calling to ResourceDefinitionMatchingRuleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceDefinitionMatchingRuleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceDefinitionMatchingRuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceDefinitionMatchingRule.
func (c *ResourceDefinitionMatchingRuleClient) Update() *ResourceDefinitionMatchingRuleUpdate {
	mutation := newResourceDefinitionMatchingRuleMutation(c.config, OpUpdate)
	return &ResourceDefinitionMatchingRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceDefinitionMatchingRuleClient) UpdateOne(rdmr *ResourceDefinitionMatchingRule) *ResourceDefinitionMatchingRuleUpdateOne {
	mutation := newResourceDefinitionMatchingRuleMutation(c.config, OpUpdateOne, withResourceDefinitionMatchingRule(rdmr))
	return &ResourceDefinitionMatchingRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceDefinitionMatchingRuleClient) UpdateOneID(id object.ID) *ResourceDefinitionMatchingRuleUpdateOne {
	mutation := newResourceDefinitionMatchingRuleMutation(c.config, OpUpdateOne, withResourceDefinitionMatchingRuleID(id))
	return &ResourceDefinitionMatchingRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceDefinitionMatchingRule.
func (c *ResourceDefinitionMatchingRuleClient) Delete() *ResourceDefinitionMatchingRuleDelete {
	mutation := newResourceDefinitionMatchingRuleMutation(c.config, OpDelete)
	return &ResourceDefinitionMatchingRuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceDefinitionMatchingRuleClient) DeleteOne(rdmr *ResourceDefinitionMatchingRule) *ResourceDefinitionMatchingRuleDeleteOne {
	return c.DeleteOneID(rdmr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceDefinitionMatchingRuleClient) DeleteOneID(id object.ID) *ResourceDefinitionMatchingRuleDeleteOne {
	builder := c.Delete().Where(resourcedefinitionmatchingrule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceDefinitionMatchingRuleDeleteOne{builder}
}

// Query returns a query builder for ResourceDefinitionMatchingRule.
func (c *ResourceDefinitionMatchingRuleClient) Query() *ResourceDefinitionMatchingRuleQuery {
	return &ResourceDefinitionMatchingRuleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceDefinitionMatchingRule},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceDefinitionMatchingRule entity by its id.
func (c *ResourceDefinitionMatchingRuleClient) Get(ctx context.Context, id object.ID) (*ResourceDefinitionMatchingRule, error) {
	return c.Query().Where(resourcedefinitionmatchingrule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceDefinitionMatchingRuleClient) GetX(ctx context.Context, id object.ID) *ResourceDefinitionMatchingRule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResourceDefinition queries the resource_definition edge of a ResourceDefinitionMatchingRule.
func (c *ResourceDefinitionMatchingRuleClient) QueryResourceDefinition(rdmr *ResourceDefinitionMatchingRule) *ResourceDefinitionQuery {
	query := (&ResourceDefinitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdmr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcedefinitionmatchingrule.Table, resourcedefinitionmatchingrule.FieldID, id),
			sqlgraph.To(resourcedefinition.Table, resourcedefinition.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, resourcedefinitionmatchingrule.ResourceDefinitionTable, resourcedefinitionmatchingrule.ResourceDefinitionColumn),
		)
		schemaConfig := rdmr.schemaConfig
		step.To.Schema = schemaConfig.ResourceDefinition
		step.Edge.Schema = schemaConfig.ResourceDefinitionMatchingRule
		fromV = sqlgraph.Neighbors(rdmr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a ResourceDefinitionMatchingRule.
func (c *ResourceDefinitionMatchingRuleClient) QueryTemplate(rdmr *ResourceDefinitionMatchingRule) *TemplateVersionQuery {
	query := (&TemplateVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdmr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcedefinitionmatchingrule.Table, resourcedefinitionmatchingrule.FieldID, id),
			sqlgraph.To(templateversion.Table, templateversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, resourcedefinitionmatchingrule.TemplateTable, resourcedefinitionmatchingrule.TemplateColumn),
		)
		schemaConfig := rdmr.schemaConfig
		step.To.Schema = schemaConfig.TemplateVersion
		step.Edge.Schema = schemaConfig.ResourceDefinitionMatchingRule
		fromV = sqlgraph.Neighbors(rdmr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResources queries the resources edge of a ResourceDefinitionMatchingRule.
func (c *ResourceDefinitionMatchingRuleClient) QueryResources(rdmr *ResourceDefinitionMatchingRule) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rdmr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcedefinitionmatchingrule.Table, resourcedefinitionmatchingrule.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, resourcedefinitionmatchingrule.ResourcesTable, resourcedefinitionmatchingrule.ResourcesColumn),
		)
		schemaConfig := rdmr.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(rdmr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceDefinitionMatchingRuleClient) Hooks() []Hook {
	hooks := c.hooks.ResourceDefinitionMatchingRule
	return append(hooks[:len(hooks):len(hooks)], resourcedefinitionmatchingrule.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ResourceDefinitionMatchingRuleClient) Interceptors() []Interceptor {
	return c.inters.ResourceDefinitionMatchingRule
}

func (c *ResourceDefinitionMatchingRuleClient) mutate(ctx context.Context, m *ResourceDefinitionMatchingRuleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceDefinitionMatchingRuleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceDefinitionMatchingRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceDefinitionMatchingRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceDefinitionMatchingRuleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown ResourceDefinitionMatchingRule mutation op: %q", m.Op())
	}
}

// ResourceRelationshipClient is a client for the ResourceRelationship schema.
type ResourceRelationshipClient struct {
	config
}

// NewResourceRelationshipClient returns a client for the ResourceRelationship from the given config.
func NewResourceRelationshipClient(c config) *ResourceRelationshipClient {
	return &ResourceRelationshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourcerelationship.Hooks(f(g(h())))`.
func (c *ResourceRelationshipClient) Use(hooks ...Hook) {
	c.hooks.ResourceRelationship = append(c.hooks.ResourceRelationship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourcerelationship.Intercept(f(g(h())))`.
func (c *ResourceRelationshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceRelationship = append(c.inters.ResourceRelationship, interceptors...)
}

// Create returns a builder for creating a ResourceRelationship entity.
func (c *ResourceRelationshipClient) Create() *ResourceRelationshipCreate {
	mutation := newResourceRelationshipMutation(c.config, OpCreate)
	return &ResourceRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceRelationship entities.
func (c *ResourceRelationshipClient) CreateBulk(builders ...*ResourceRelationshipCreate) *ResourceRelationshipCreateBulk {
	return &ResourceRelationshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceRelationshipClient) MapCreateBulk(slice any, setFunc func(*ResourceRelationshipCreate, int)) *ResourceRelationshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceRelationshipCreateBulk{err: fmt.Errorf("calling to ResourceRelationshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceRelationshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceRelationshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceRelationship.
func (c *ResourceRelationshipClient) Update() *ResourceRelationshipUpdate {
	mutation := newResourceRelationshipMutation(c.config, OpUpdate)
	return &ResourceRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceRelationshipClient) UpdateOne(rr *ResourceRelationship) *ResourceRelationshipUpdateOne {
	mutation := newResourceRelationshipMutation(c.config, OpUpdateOne, withResourceRelationship(rr))
	return &ResourceRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceRelationshipClient) UpdateOneID(id object.ID) *ResourceRelationshipUpdateOne {
	mutation := newResourceRelationshipMutation(c.config, OpUpdateOne, withResourceRelationshipID(id))
	return &ResourceRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceRelationship.
func (c *ResourceRelationshipClient) Delete() *ResourceRelationshipDelete {
	mutation := newResourceRelationshipMutation(c.config, OpDelete)
	return &ResourceRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceRelationshipClient) DeleteOne(rr *ResourceRelationship) *ResourceRelationshipDeleteOne {
	return c.DeleteOneID(rr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceRelationshipClient) DeleteOneID(id object.ID) *ResourceRelationshipDeleteOne {
	builder := c.Delete().Where(resourcerelationship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceRelationshipDeleteOne{builder}
}

// Query returns a query builder for ResourceRelationship.
func (c *ResourceRelationshipClient) Query() *ResourceRelationshipQuery {
	return &ResourceRelationshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceRelationship},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceRelationship entity by its id.
func (c *ResourceRelationshipClient) Get(ctx context.Context, id object.ID) (*ResourceRelationship, error) {
	return c.Query().Where(resourcerelationship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceRelationshipClient) GetX(ctx context.Context, id object.ID) *ResourceRelationship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResource queries the resource edge of a ResourceRelationship.
func (c *ResourceRelationshipClient) QueryResource(rr *ResourceRelationship) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcerelationship.Table, resourcerelationship.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, resourcerelationship.ResourceTable, resourcerelationship.ResourceColumn),
		)
		schemaConfig := rr.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.ResourceRelationship
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependency queries the dependency edge of a ResourceRelationship.
func (c *ResourceRelationshipClient) QueryDependency(rr *ResourceRelationship) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcerelationship.Table, resourcerelationship.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, resourcerelationship.DependencyTable, resourcerelationship.DependencyColumn),
		)
		schemaConfig := rr.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.ResourceRelationship
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceRelationshipClient) Hooks() []Hook {
	hooks := c.hooks.ResourceRelationship
	return append(hooks[:len(hooks):len(hooks)], resourcerelationship.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ResourceRelationshipClient) Interceptors() []Interceptor {
	return c.inters.ResourceRelationship
}

func (c *ResourceRelationshipClient) mutate(ctx context.Context, m *ResourceRelationshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown ResourceRelationship mutation op: %q", m.Op())
	}
}

// ResourceRunClient is a client for the ResourceRun schema.
type ResourceRunClient struct {
	config
}

// NewResourceRunClient returns a client for the ResourceRun from the given config.
func NewResourceRunClient(c config) *ResourceRunClient {
	return &ResourceRunClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourcerun.Hooks(f(g(h())))`.
func (c *ResourceRunClient) Use(hooks ...Hook) {
	c.hooks.ResourceRun = append(c.hooks.ResourceRun, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourcerun.Intercept(f(g(h())))`.
func (c *ResourceRunClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceRun = append(c.inters.ResourceRun, interceptors...)
}

// Create returns a builder for creating a ResourceRun entity.
func (c *ResourceRunClient) Create() *ResourceRunCreate {
	mutation := newResourceRunMutation(c.config, OpCreate)
	return &ResourceRunCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceRun entities.
func (c *ResourceRunClient) CreateBulk(builders ...*ResourceRunCreate) *ResourceRunCreateBulk {
	return &ResourceRunCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceRunClient) MapCreateBulk(slice any, setFunc func(*ResourceRunCreate, int)) *ResourceRunCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceRunCreateBulk{err: fmt.Errorf("calling to ResourceRunClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceRunCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceRunCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceRun.
func (c *ResourceRunClient) Update() *ResourceRunUpdate {
	mutation := newResourceRunMutation(c.config, OpUpdate)
	return &ResourceRunUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceRunClient) UpdateOne(rr *ResourceRun) *ResourceRunUpdateOne {
	mutation := newResourceRunMutation(c.config, OpUpdateOne, withResourceRun(rr))
	return &ResourceRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceRunClient) UpdateOneID(id object.ID) *ResourceRunUpdateOne {
	mutation := newResourceRunMutation(c.config, OpUpdateOne, withResourceRunID(id))
	return &ResourceRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceRun.
func (c *ResourceRunClient) Delete() *ResourceRunDelete {
	mutation := newResourceRunMutation(c.config, OpDelete)
	return &ResourceRunDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceRunClient) DeleteOne(rr *ResourceRun) *ResourceRunDeleteOne {
	return c.DeleteOneID(rr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceRunClient) DeleteOneID(id object.ID) *ResourceRunDeleteOne {
	builder := c.Delete().Where(resourcerun.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceRunDeleteOne{builder}
}

// Query returns a query builder for ResourceRun.
func (c *ResourceRunClient) Query() *ResourceRunQuery {
	return &ResourceRunQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceRun},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceRun entity by its id.
func (c *ResourceRunClient) Get(ctx context.Context, id object.ID) (*ResourceRun, error) {
	return c.Query().Where(resourcerun.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceRunClient) GetX(ctx context.Context, id object.ID) *ResourceRun {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a ResourceRun.
func (c *ResourceRunClient) QueryProject(rr *ResourceRun) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcerun.Table, resourcerun.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcerun.ProjectTable, resourcerun.ProjectColumn),
		)
		schemaConfig := rr.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.ResourceRun
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the environment edge of a ResourceRun.
func (c *ResourceRunClient) QueryEnvironment(rr *ResourceRun) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcerun.Table, resourcerun.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcerun.EnvironmentTable, resourcerun.EnvironmentColumn),
		)
		schemaConfig := rr.schemaConfig
		step.To.Schema = schemaConfig.Environment
		step.Edge.Schema = schemaConfig.ResourceRun
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResource queries the resource edge of a ResourceRun.
func (c *ResourceRunClient) QueryResource(rr *ResourceRun) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourcerun.Table, resourcerun.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourcerun.ResourceTable, resourcerun.ResourceColumn),
		)
		schemaConfig := rr.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.ResourceRun
		fromV = sqlgraph.Neighbors(rr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceRunClient) Hooks() []Hook {
	hooks := c.hooks.ResourceRun
	return append(hooks[:len(hooks):len(hooks)], resourcerun.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ResourceRunClient) Interceptors() []Interceptor {
	inters := c.inters.ResourceRun
	return append(inters[:len(inters):len(inters)], resourcerun.Interceptors[:]...)
}

func (c *ResourceRunClient) mutate(ctx context.Context, m *ResourceRunMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceRunCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceRunUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceRunDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown ResourceRun mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id string) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id string) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id string) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id string) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubjects queries the subjects edge of a Role.
func (c *RoleClient) QuerySubjects(r *Role) *SubjectRoleRelationshipQuery {
	query := (&SubjectRoleRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(subjectrolerelationship.Table, subjectrolerelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, role.SubjectsTable, role.SubjectsColumn),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.SubjectRoleRelationship
		step.Edge.Schema = schemaConfig.SubjectRoleRelationship
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	hooks := c.hooks.Role
	return append(hooks[:len(hooks):len(hooks)], role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Role mutation op: %q", m.Op())
	}
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setting.Intercept(f(g(h())))`.
func (c *SettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Setting = append(c.inters.Setting, interceptors...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingClient) MapCreateBulk(slice any, setFunc func(*SettingCreate, int)) *SettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingCreateBulk{err: fmt.Errorf("calling to SettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(s *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(s))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id object.ID) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(s *Setting) *SettingDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id object.ID) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id object.ID) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id object.ID) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	hooks := c.hooks.Setting
	return append(hooks[:len(hooks):len(hooks)], setting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SettingClient) Interceptors() []Interceptor {
	return c.inters.Setting
}

func (c *SettingClient) mutate(ctx context.Context, m *SettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Setting mutation op: %q", m.Op())
	}
}

// SubjectClient is a client for the Subject schema.
type SubjectClient struct {
	config
}

// NewSubjectClient returns a client for the Subject from the given config.
func NewSubjectClient(c config) *SubjectClient {
	return &SubjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subject.Hooks(f(g(h())))`.
func (c *SubjectClient) Use(hooks ...Hook) {
	c.hooks.Subject = append(c.hooks.Subject, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subject.Intercept(f(g(h())))`.
func (c *SubjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subject = append(c.inters.Subject, interceptors...)
}

// Create returns a builder for creating a Subject entity.
func (c *SubjectClient) Create() *SubjectCreate {
	mutation := newSubjectMutation(c.config, OpCreate)
	return &SubjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subject entities.
func (c *SubjectClient) CreateBulk(builders ...*SubjectCreate) *SubjectCreateBulk {
	return &SubjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubjectClient) MapCreateBulk(slice any, setFunc func(*SubjectCreate, int)) *SubjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubjectCreateBulk{err: fmt.Errorf("calling to SubjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subject.
func (c *SubjectClient) Update() *SubjectUpdate {
	mutation := newSubjectMutation(c.config, OpUpdate)
	return &SubjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubjectClient) UpdateOne(s *Subject) *SubjectUpdateOne {
	mutation := newSubjectMutation(c.config, OpUpdateOne, withSubject(s))
	return &SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubjectClient) UpdateOneID(id object.ID) *SubjectUpdateOne {
	mutation := newSubjectMutation(c.config, OpUpdateOne, withSubjectID(id))
	return &SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subject.
func (c *SubjectClient) Delete() *SubjectDelete {
	mutation := newSubjectMutation(c.config, OpDelete)
	return &SubjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubjectClient) DeleteOne(s *Subject) *SubjectDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubjectClient) DeleteOneID(id object.ID) *SubjectDeleteOne {
	builder := c.Delete().Where(subject.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubjectDeleteOne{builder}
}

// Query returns a query builder for Subject.
func (c *SubjectClient) Query() *SubjectQuery {
	return &SubjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubject},
		inters: c.Interceptors(),
	}
}

// Get returns a Subject entity by its id.
func (c *SubjectClient) Get(ctx context.Context, id object.ID) (*Subject, error) {
	return c.Query().Where(subject.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubjectClient) GetX(ctx context.Context, id object.ID) *Subject {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTokens queries the tokens edge of a Subject.
func (c *SubjectClient) QueryTokens(s *Subject) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subject.Table, subject.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subject.TokensTable, subject.TokensColumn),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Token
		step.Edge.Schema = schemaConfig.Token
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoles queries the roles edge of a Subject.
func (c *SubjectClient) QueryRoles(s *Subject) *SubjectRoleRelationshipQuery {
	query := (&SubjectRoleRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subject.Table, subject.FieldID, id),
			sqlgraph.To(subjectrolerelationship.Table, subjectrolerelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, subject.RolesTable, subject.RolesColumn),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.SubjectRoleRelationship
		step.Edge.Schema = schemaConfig.SubjectRoleRelationship
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubjectClient) Hooks() []Hook {
	hooks := c.hooks.Subject
	return append(hooks[:len(hooks):len(hooks)], subject.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubjectClient) Interceptors() []Interceptor {
	return c.inters.Subject
}

func (c *SubjectClient) mutate(ctx context.Context, m *SubjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Subject mutation op: %q", m.Op())
	}
}

// SubjectRoleRelationshipClient is a client for the SubjectRoleRelationship schema.
type SubjectRoleRelationshipClient struct {
	config
}

// NewSubjectRoleRelationshipClient returns a client for the SubjectRoleRelationship from the given config.
func NewSubjectRoleRelationshipClient(c config) *SubjectRoleRelationshipClient {
	return &SubjectRoleRelationshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subjectrolerelationship.Hooks(f(g(h())))`.
func (c *SubjectRoleRelationshipClient) Use(hooks ...Hook) {
	c.hooks.SubjectRoleRelationship = append(c.hooks.SubjectRoleRelationship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subjectrolerelationship.Intercept(f(g(h())))`.
func (c *SubjectRoleRelationshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubjectRoleRelationship = append(c.inters.SubjectRoleRelationship, interceptors...)
}

// Create returns a builder for creating a SubjectRoleRelationship entity.
func (c *SubjectRoleRelationshipClient) Create() *SubjectRoleRelationshipCreate {
	mutation := newSubjectRoleRelationshipMutation(c.config, OpCreate)
	return &SubjectRoleRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubjectRoleRelationship entities.
func (c *SubjectRoleRelationshipClient) CreateBulk(builders ...*SubjectRoleRelationshipCreate) *SubjectRoleRelationshipCreateBulk {
	return &SubjectRoleRelationshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubjectRoleRelationshipClient) MapCreateBulk(slice any, setFunc func(*SubjectRoleRelationshipCreate, int)) *SubjectRoleRelationshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubjectRoleRelationshipCreateBulk{err: fmt.Errorf("calling to SubjectRoleRelationshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubjectRoleRelationshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubjectRoleRelationshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubjectRoleRelationship.
func (c *SubjectRoleRelationshipClient) Update() *SubjectRoleRelationshipUpdate {
	mutation := newSubjectRoleRelationshipMutation(c.config, OpUpdate)
	return &SubjectRoleRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubjectRoleRelationshipClient) UpdateOne(srr *SubjectRoleRelationship) *SubjectRoleRelationshipUpdateOne {
	mutation := newSubjectRoleRelationshipMutation(c.config, OpUpdateOne, withSubjectRoleRelationship(srr))
	return &SubjectRoleRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubjectRoleRelationshipClient) UpdateOneID(id object.ID) *SubjectRoleRelationshipUpdateOne {
	mutation := newSubjectRoleRelationshipMutation(c.config, OpUpdateOne, withSubjectRoleRelationshipID(id))
	return &SubjectRoleRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubjectRoleRelationship.
func (c *SubjectRoleRelationshipClient) Delete() *SubjectRoleRelationshipDelete {
	mutation := newSubjectRoleRelationshipMutation(c.config, OpDelete)
	return &SubjectRoleRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubjectRoleRelationshipClient) DeleteOne(srr *SubjectRoleRelationship) *SubjectRoleRelationshipDeleteOne {
	return c.DeleteOneID(srr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubjectRoleRelationshipClient) DeleteOneID(id object.ID) *SubjectRoleRelationshipDeleteOne {
	builder := c.Delete().Where(subjectrolerelationship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubjectRoleRelationshipDeleteOne{builder}
}

// Query returns a query builder for SubjectRoleRelationship.
func (c *SubjectRoleRelationshipClient) Query() *SubjectRoleRelationshipQuery {
	return &SubjectRoleRelationshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubjectRoleRelationship},
		inters: c.Interceptors(),
	}
}

// Get returns a SubjectRoleRelationship entity by its id.
func (c *SubjectRoleRelationshipClient) Get(ctx context.Context, id object.ID) (*SubjectRoleRelationship, error) {
	return c.Query().Where(subjectrolerelationship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubjectRoleRelationshipClient) GetX(ctx context.Context, id object.ID) *SubjectRoleRelationship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a SubjectRoleRelationship.
func (c *SubjectRoleRelationshipClient) QueryProject(srr *SubjectRoleRelationship) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := srr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subjectrolerelationship.Table, subjectrolerelationship.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subjectrolerelationship.ProjectTable, subjectrolerelationship.ProjectColumn),
		)
		schemaConfig := srr.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.SubjectRoleRelationship
		fromV = sqlgraph.Neighbors(srr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubject queries the subject edge of a SubjectRoleRelationship.
func (c *SubjectRoleRelationshipClient) QuerySubject(srr *SubjectRoleRelationship) *SubjectQuery {
	query := (&SubjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := srr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subjectrolerelationship.Table, subjectrolerelationship.FieldID, id),
			sqlgraph.To(subject.Table, subject.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subjectrolerelationship.SubjectTable, subjectrolerelationship.SubjectColumn),
		)
		schemaConfig := srr.schemaConfig
		step.To.Schema = schemaConfig.Subject
		step.Edge.Schema = schemaConfig.SubjectRoleRelationship
		fromV = sqlgraph.Neighbors(srr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRole queries the role edge of a SubjectRoleRelationship.
func (c *SubjectRoleRelationshipClient) QueryRole(srr *SubjectRoleRelationship) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := srr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subjectrolerelationship.Table, subjectrolerelationship.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subjectrolerelationship.RoleTable, subjectrolerelationship.RoleColumn),
		)
		schemaConfig := srr.schemaConfig
		step.To.Schema = schemaConfig.Role
		step.Edge.Schema = schemaConfig.SubjectRoleRelationship
		fromV = sqlgraph.Neighbors(srr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubjectRoleRelationshipClient) Hooks() []Hook {
	hooks := c.hooks.SubjectRoleRelationship
	return append(hooks[:len(hooks):len(hooks)], subjectrolerelationship.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubjectRoleRelationshipClient) Interceptors() []Interceptor {
	inters := c.inters.SubjectRoleRelationship
	return append(inters[:len(inters):len(inters)], subjectrolerelationship.Interceptors[:]...)
}

func (c *SubjectRoleRelationshipClient) mutate(ctx context.Context, m *SubjectRoleRelationshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubjectRoleRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubjectRoleRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubjectRoleRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubjectRoleRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown SubjectRoleRelationship mutation op: %q", m.Op())
	}
}

// TemplateClient is a client for the Template schema.
type TemplateClient struct {
	config
}

// NewTemplateClient returns a client for the Template from the given config.
func NewTemplateClient(c config) *TemplateClient {
	return &TemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `template.Hooks(f(g(h())))`.
func (c *TemplateClient) Use(hooks ...Hook) {
	c.hooks.Template = append(c.hooks.Template, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `template.Intercept(f(g(h())))`.
func (c *TemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Template = append(c.inters.Template, interceptors...)
}

// Create returns a builder for creating a Template entity.
func (c *TemplateClient) Create() *TemplateCreate {
	mutation := newTemplateMutation(c.config, OpCreate)
	return &TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Template entities.
func (c *TemplateClient) CreateBulk(builders ...*TemplateCreate) *TemplateCreateBulk {
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplateClient) MapCreateBulk(slice any, setFunc func(*TemplateCreate, int)) *TemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplateCreateBulk{err: fmt.Errorf("calling to TemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Template.
func (c *TemplateClient) Update() *TemplateUpdate {
	mutation := newTemplateMutation(c.config, OpUpdate)
	return &TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplateClient) UpdateOne(t *Template) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplate(t))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplateClient) UpdateOneID(id object.ID) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplateID(id))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Template.
func (c *TemplateClient) Delete() *TemplateDelete {
	mutation := newTemplateMutation(c.config, OpDelete)
	return &TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplateClient) DeleteOne(t *Template) *TemplateDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplateClient) DeleteOneID(id object.ID) *TemplateDeleteOne {
	builder := c.Delete().Where(template.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplateDeleteOne{builder}
}

// Query returns a query builder for Template.
func (c *TemplateClient) Query() *TemplateQuery {
	return &TemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a Template entity by its id.
func (c *TemplateClient) Get(ctx context.Context, id object.ID) (*Template, error) {
	return c.Query().Where(template.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplateClient) GetX(ctx context.Context, id object.ID) *Template {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVersions queries the versions edge of a Template.
func (c *TemplateClient) QueryVersions(t *Template) *TemplateVersionQuery {
	query := (&TemplateVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(templateversion.Table, templateversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, template.VersionsTable, template.VersionsColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.TemplateVersion
		step.Edge.Schema = schemaConfig.TemplateVersion
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCatalog queries the catalog edge of a Template.
func (c *TemplateClient) QueryCatalog(t *Template) *CatalogQuery {
	query := (&CatalogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(catalog.Table, catalog.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, template.CatalogTable, template.CatalogColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Catalog
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Template.
func (c *TemplateClient) QueryProject(t *Template) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, template.ProjectTable, template.ProjectColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TemplateClient) Hooks() []Hook {
	hooks := c.hooks.Template
	return append(hooks[:len(hooks):len(hooks)], template.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TemplateClient) Interceptors() []Interceptor {
	inters := c.inters.Template
	return append(inters[:len(inters):len(inters)], template.Interceptors[:]...)
}

func (c *TemplateClient) mutate(ctx context.Context, m *TemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Template mutation op: %q", m.Op())
	}
}

// TemplateVersionClient is a client for the TemplateVersion schema.
type TemplateVersionClient struct {
	config
}

// NewTemplateVersionClient returns a client for the TemplateVersion from the given config.
func NewTemplateVersionClient(c config) *TemplateVersionClient {
	return &TemplateVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `templateversion.Hooks(f(g(h())))`.
func (c *TemplateVersionClient) Use(hooks ...Hook) {
	c.hooks.TemplateVersion = append(c.hooks.TemplateVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `templateversion.Intercept(f(g(h())))`.
func (c *TemplateVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TemplateVersion = append(c.inters.TemplateVersion, interceptors...)
}

// Create returns a builder for creating a TemplateVersion entity.
func (c *TemplateVersionClient) Create() *TemplateVersionCreate {
	mutation := newTemplateVersionMutation(c.config, OpCreate)
	return &TemplateVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TemplateVersion entities.
func (c *TemplateVersionClient) CreateBulk(builders ...*TemplateVersionCreate) *TemplateVersionCreateBulk {
	return &TemplateVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplateVersionClient) MapCreateBulk(slice any, setFunc func(*TemplateVersionCreate, int)) *TemplateVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplateVersionCreateBulk{err: fmt.Errorf("calling to TemplateVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplateVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplateVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TemplateVersion.
func (c *TemplateVersionClient) Update() *TemplateVersionUpdate {
	mutation := newTemplateVersionMutation(c.config, OpUpdate)
	return &TemplateVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplateVersionClient) UpdateOne(tv *TemplateVersion) *TemplateVersionUpdateOne {
	mutation := newTemplateVersionMutation(c.config, OpUpdateOne, withTemplateVersion(tv))
	return &TemplateVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplateVersionClient) UpdateOneID(id object.ID) *TemplateVersionUpdateOne {
	mutation := newTemplateVersionMutation(c.config, OpUpdateOne, withTemplateVersionID(id))
	return &TemplateVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TemplateVersion.
func (c *TemplateVersionClient) Delete() *TemplateVersionDelete {
	mutation := newTemplateVersionMutation(c.config, OpDelete)
	return &TemplateVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplateVersionClient) DeleteOne(tv *TemplateVersion) *TemplateVersionDeleteOne {
	return c.DeleteOneID(tv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplateVersionClient) DeleteOneID(id object.ID) *TemplateVersionDeleteOne {
	builder := c.Delete().Where(templateversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplateVersionDeleteOne{builder}
}

// Query returns a query builder for TemplateVersion.
func (c *TemplateVersionClient) Query() *TemplateVersionQuery {
	return &TemplateVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemplateVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a TemplateVersion entity by its id.
func (c *TemplateVersionClient) Get(ctx context.Context, id object.ID) (*TemplateVersion, error) {
	return c.Query().Where(templateversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplateVersionClient) GetX(ctx context.Context, id object.ID) *TemplateVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTemplate queries the template edge of a TemplateVersion.
func (c *TemplateVersionClient) QueryTemplate(tv *TemplateVersion) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(templateversion.Table, templateversion.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, templateversion.TemplateTable, templateversion.TemplateColumn),
		)
		schemaConfig := tv.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.TemplateVersion
		fromV = sqlgraph.Neighbors(tv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResources queries the resources edge of a TemplateVersion.
func (c *TemplateVersionClient) QueryResources(tv *TemplateVersion) *ResourceQuery {
	query := (&ResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(templateversion.Table, templateversion.FieldID, id),
			sqlgraph.To(resource.Table, resource.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, templateversion.ResourcesTable, templateversion.ResourcesColumn),
		)
		schemaConfig := tv.schemaConfig
		step.To.Schema = schemaConfig.Resource
		step.Edge.Schema = schemaConfig.Resource
		fromV = sqlgraph.Neighbors(tv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceDefinitions queries the resource_definitions edge of a TemplateVersion.
func (c *TemplateVersionClient) QueryResourceDefinitions(tv *TemplateVersion) *ResourceDefinitionMatchingRuleQuery {
	query := (&ResourceDefinitionMatchingRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(templateversion.Table, templateversion.FieldID, id),
			sqlgraph.To(resourcedefinitionmatchingrule.Table, resourcedefinitionmatchingrule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, templateversion.ResourceDefinitionsTable, templateversion.ResourceDefinitionsColumn),
		)
		schemaConfig := tv.schemaConfig
		step.To.Schema = schemaConfig.ResourceDefinitionMatchingRule
		step.Edge.Schema = schemaConfig.ResourceDefinitionMatchingRule
		fromV = sqlgraph.Neighbors(tv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a TemplateVersion.
func (c *TemplateVersionClient) QueryProject(tv *TemplateVersion) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(templateversion.Table, templateversion.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, templateversion.ProjectTable, templateversion.ProjectColumn),
		)
		schemaConfig := tv.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.TemplateVersion
		fromV = sqlgraph.Neighbors(tv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TemplateVersionClient) Hooks() []Hook {
	hooks := c.hooks.TemplateVersion
	return append(hooks[:len(hooks):len(hooks)], templateversion.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TemplateVersionClient) Interceptors() []Interceptor {
	inters := c.inters.TemplateVersion
	return append(inters[:len(inters):len(inters)], templateversion.Interceptors[:]...)
}

func (c *TemplateVersionClient) mutate(ctx context.Context, m *TemplateVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplateVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplateVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplateVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplateVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown TemplateVersion mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id object.ID) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id object.ID) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id object.ID) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id object.ID) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubject queries the subject edge of a Token.
func (c *TokenClient) QuerySubject(t *Token) *SubjectQuery {
	query := (&SubjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(subject.Table, subject.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, token.SubjectTable, token.SubjectColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Subject
		step.Edge.Schema = schemaConfig.Token
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	hooks := c.hooks.Token
	return append(hooks[:len(hooks):len(hooks)], token.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	inters := c.inters.Token
	return append(inters[:len(inters):len(inters)], token.Interceptors[:]...)
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Token mutation op: %q", m.Op())
	}
}

// VariableClient is a client for the Variable schema.
type VariableClient struct {
	config
}

// NewVariableClient returns a client for the Variable from the given config.
func NewVariableClient(c config) *VariableClient {
	return &VariableClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `variable.Hooks(f(g(h())))`.
func (c *VariableClient) Use(hooks ...Hook) {
	c.hooks.Variable = append(c.hooks.Variable, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `variable.Intercept(f(g(h())))`.
func (c *VariableClient) Intercept(interceptors ...Interceptor) {
	c.inters.Variable = append(c.inters.Variable, interceptors...)
}

// Create returns a builder for creating a Variable entity.
func (c *VariableClient) Create() *VariableCreate {
	mutation := newVariableMutation(c.config, OpCreate)
	return &VariableCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Variable entities.
func (c *VariableClient) CreateBulk(builders ...*VariableCreate) *VariableCreateBulk {
	return &VariableCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VariableClient) MapCreateBulk(slice any, setFunc func(*VariableCreate, int)) *VariableCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VariableCreateBulk{err: fmt.Errorf("calling to VariableClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VariableCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VariableCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Variable.
func (c *VariableClient) Update() *VariableUpdate {
	mutation := newVariableMutation(c.config, OpUpdate)
	return &VariableUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VariableClient) UpdateOne(v *Variable) *VariableUpdateOne {
	mutation := newVariableMutation(c.config, OpUpdateOne, withVariable(v))
	return &VariableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VariableClient) UpdateOneID(id object.ID) *VariableUpdateOne {
	mutation := newVariableMutation(c.config, OpUpdateOne, withVariableID(id))
	return &VariableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Variable.
func (c *VariableClient) Delete() *VariableDelete {
	mutation := newVariableMutation(c.config, OpDelete)
	return &VariableDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VariableClient) DeleteOne(v *Variable) *VariableDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VariableClient) DeleteOneID(id object.ID) *VariableDeleteOne {
	builder := c.Delete().Where(variable.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VariableDeleteOne{builder}
}

// Query returns a query builder for Variable.
func (c *VariableClient) Query() *VariableQuery {
	return &VariableQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVariable},
		inters: c.Interceptors(),
	}
}

// Get returns a Variable entity by its id.
func (c *VariableClient) Get(ctx context.Context, id object.ID) (*Variable, error) {
	return c.Query().Where(variable.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VariableClient) GetX(ctx context.Context, id object.ID) *Variable {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Variable.
func (c *VariableClient) QueryProject(v *Variable) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(variable.Table, variable.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, variable.ProjectTable, variable.ProjectColumn),
		)
		schemaConfig := v.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.Variable
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the environment edge of a Variable.
func (c *VariableClient) QueryEnvironment(v *Variable) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(variable.Table, variable.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, variable.EnvironmentTable, variable.EnvironmentColumn),
		)
		schemaConfig := v.schemaConfig
		step.To.Schema = schemaConfig.Environment
		step.Edge.Schema = schemaConfig.Variable
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VariableClient) Hooks() []Hook {
	hooks := c.hooks.Variable
	return append(hooks[:len(hooks):len(hooks)], variable.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VariableClient) Interceptors() []Interceptor {
	inters := c.inters.Variable
	return append(inters[:len(inters):len(inters)], variable.Interceptors[:]...)
}

func (c *VariableClient) mutate(ctx context.Context, m *VariableMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VariableCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VariableUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VariableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VariableDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Variable mutation op: %q", m.Op())
	}
}

// WorkflowClient is a client for the Workflow schema.
type WorkflowClient struct {
	config
}

// NewWorkflowClient returns a client for the Workflow from the given config.
func NewWorkflowClient(c config) *WorkflowClient {
	return &WorkflowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflow.Hooks(f(g(h())))`.
func (c *WorkflowClient) Use(hooks ...Hook) {
	c.hooks.Workflow = append(c.hooks.Workflow, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflow.Intercept(f(g(h())))`.
func (c *WorkflowClient) Intercept(interceptors ...Interceptor) {
	c.inters.Workflow = append(c.inters.Workflow, interceptors...)
}

// Create returns a builder for creating a Workflow entity.
func (c *WorkflowClient) Create() *WorkflowCreate {
	mutation := newWorkflowMutation(c.config, OpCreate)
	return &WorkflowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workflow entities.
func (c *WorkflowClient) CreateBulk(builders ...*WorkflowCreate) *WorkflowCreateBulk {
	return &WorkflowCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowClient) MapCreateBulk(slice any, setFunc func(*WorkflowCreate, int)) *WorkflowCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowCreateBulk{err: fmt.Errorf("calling to WorkflowClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workflow.
func (c *WorkflowClient) Update() *WorkflowUpdate {
	mutation := newWorkflowMutation(c.config, OpUpdate)
	return &WorkflowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowClient) UpdateOne(w *Workflow) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflow(w))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowClient) UpdateOneID(id object.ID) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflowID(id))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workflow.
func (c *WorkflowClient) Delete() *WorkflowDelete {
	mutation := newWorkflowMutation(c.config, OpDelete)
	return &WorkflowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowClient) DeleteOne(w *Workflow) *WorkflowDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowClient) DeleteOneID(id object.ID) *WorkflowDeleteOne {
	builder := c.Delete().Where(workflow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowDeleteOne{builder}
}

// Query returns a query builder for Workflow.
func (c *WorkflowClient) Query() *WorkflowQuery {
	return &WorkflowQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflow},
		inters: c.Interceptors(),
	}
}

// Get returns a Workflow entity by its id.
func (c *WorkflowClient) Get(ctx context.Context, id object.ID) (*Workflow, error) {
	return c.Query().Where(workflow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowClient) GetX(ctx context.Context, id object.ID) *Workflow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Workflow.
func (c *WorkflowClient) QueryProject(w *Workflow) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflow.ProjectTable, workflow.ProjectColumn),
		)
		schemaConfig := w.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.Workflow
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStages queries the stages edge of a Workflow.
func (c *WorkflowClient) QueryStages(w *Workflow) *WorkflowStageQuery {
	query := (&WorkflowStageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(workflowstage.Table, workflowstage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.StagesTable, workflow.StagesColumn),
		)
		schemaConfig := w.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStage
		step.Edge.Schema = schemaConfig.WorkflowStage
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a Workflow.
func (c *WorkflowClient) QueryExecutions(w *Workflow) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.ExecutionsTable, workflow.ExecutionsColumn),
		)
		schemaConfig := w.schemaConfig
		step.To.Schema = schemaConfig.WorkflowExecution
		step.Edge.Schema = schemaConfig.WorkflowExecution
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowClient) Hooks() []Hook {
	hooks := c.hooks.Workflow
	return append(hooks[:len(hooks):len(hooks)], workflow.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowClient) Interceptors() []Interceptor {
	inters := c.inters.Workflow
	return append(inters[:len(inters):len(inters)], workflow.Interceptors[:]...)
}

func (c *WorkflowClient) mutate(ctx context.Context, m *WorkflowMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown Workflow mutation op: %q", m.Op())
	}
}

// WorkflowExecutionClient is a client for the WorkflowExecution schema.
type WorkflowExecutionClient struct {
	config
}

// NewWorkflowExecutionClient returns a client for the WorkflowExecution from the given config.
func NewWorkflowExecutionClient(c config) *WorkflowExecutionClient {
	return &WorkflowExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowexecution.Hooks(f(g(h())))`.
func (c *WorkflowExecutionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowExecution = append(c.hooks.WorkflowExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowexecution.Intercept(f(g(h())))`.
func (c *WorkflowExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowExecution = append(c.inters.WorkflowExecution, interceptors...)
}

// Create returns a builder for creating a WorkflowExecution entity.
func (c *WorkflowExecutionClient) Create() *WorkflowExecutionCreate {
	mutation := newWorkflowExecutionMutation(c.config, OpCreate)
	return &WorkflowExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowExecution entities.
func (c *WorkflowExecutionClient) CreateBulk(builders ...*WorkflowExecutionCreate) *WorkflowExecutionCreateBulk {
	return &WorkflowExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowExecutionClient) MapCreateBulk(slice any, setFunc func(*WorkflowExecutionCreate, int)) *WorkflowExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowExecutionCreateBulk{err: fmt.Errorf("calling to WorkflowExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Update() *WorkflowExecutionUpdate {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdate)
	return &WorkflowExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowExecutionClient) UpdateOne(we *WorkflowExecution) *WorkflowExecutionUpdateOne {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdateOne, withWorkflowExecution(we))
	return &WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowExecutionClient) UpdateOneID(id object.ID) *WorkflowExecutionUpdateOne {
	mutation := newWorkflowExecutionMutation(c.config, OpUpdateOne, withWorkflowExecutionID(id))
	return &WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Delete() *WorkflowExecutionDelete {
	mutation := newWorkflowExecutionMutation(c.config, OpDelete)
	return &WorkflowExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowExecutionClient) DeleteOne(we *WorkflowExecution) *WorkflowExecutionDeleteOne {
	return c.DeleteOneID(we.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowExecutionClient) DeleteOneID(id object.ID) *WorkflowExecutionDeleteOne {
	builder := c.Delete().Where(workflowexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowExecutionDeleteOne{builder}
}

// Query returns a query builder for WorkflowExecution.
func (c *WorkflowExecutionClient) Query() *WorkflowExecutionQuery {
	return &WorkflowExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowExecution entity by its id.
func (c *WorkflowExecutionClient) Get(ctx context.Context, id object.ID) (*WorkflowExecution, error) {
	return c.Query().Where(workflowexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowExecutionClient) GetX(ctx context.Context, id object.ID) *WorkflowExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryProject(we *WorkflowExecution) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowexecution.ProjectTable, workflowexecution.ProjectColumn),
		)
		schemaConfig := we.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.WorkflowExecution
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStages queries the stages edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryStages(we *WorkflowExecution) *WorkflowStageExecutionQuery {
	query := (&WorkflowStageExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(workflowstageexecution.Table, workflowstageexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowexecution.StagesTable, workflowexecution.StagesColumn),
		)
		schemaConfig := we.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStageExecution
		step.Edge.Schema = schemaConfig.WorkflowStageExecution
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflow queries the workflow edge of a WorkflowExecution.
func (c *WorkflowExecutionClient) QueryWorkflow(we *WorkflowExecution) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowexecution.Table, workflowexecution.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowexecution.WorkflowTable, workflowexecution.WorkflowColumn),
		)
		schemaConfig := we.schemaConfig
		step.To.Schema = schemaConfig.Workflow
		step.Edge.Schema = schemaConfig.WorkflowExecution
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowExecutionClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowExecution
	return append(hooks[:len(hooks):len(hooks)], workflowexecution.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowExecutionClient) Interceptors() []Interceptor {
	inters := c.inters.WorkflowExecution
	return append(inters[:len(inters):len(inters)], workflowexecution.Interceptors[:]...)
}

func (c *WorkflowExecutionClient) mutate(ctx context.Context, m *WorkflowExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown WorkflowExecution mutation op: %q", m.Op())
	}
}

// WorkflowStageClient is a client for the WorkflowStage schema.
type WorkflowStageClient struct {
	config
}

// NewWorkflowStageClient returns a client for the WorkflowStage from the given config.
func NewWorkflowStageClient(c config) *WorkflowStageClient {
	return &WorkflowStageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowstage.Hooks(f(g(h())))`.
func (c *WorkflowStageClient) Use(hooks ...Hook) {
	c.hooks.WorkflowStage = append(c.hooks.WorkflowStage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowstage.Intercept(f(g(h())))`.
func (c *WorkflowStageClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowStage = append(c.inters.WorkflowStage, interceptors...)
}

// Create returns a builder for creating a WorkflowStage entity.
func (c *WorkflowStageClient) Create() *WorkflowStageCreate {
	mutation := newWorkflowStageMutation(c.config, OpCreate)
	return &WorkflowStageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowStage entities.
func (c *WorkflowStageClient) CreateBulk(builders ...*WorkflowStageCreate) *WorkflowStageCreateBulk {
	return &WorkflowStageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowStageClient) MapCreateBulk(slice any, setFunc func(*WorkflowStageCreate, int)) *WorkflowStageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowStageCreateBulk{err: fmt.Errorf("calling to WorkflowStageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowStageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowStageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowStage.
func (c *WorkflowStageClient) Update() *WorkflowStageUpdate {
	mutation := newWorkflowStageMutation(c.config, OpUpdate)
	return &WorkflowStageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowStageClient) UpdateOne(ws *WorkflowStage) *WorkflowStageUpdateOne {
	mutation := newWorkflowStageMutation(c.config, OpUpdateOne, withWorkflowStage(ws))
	return &WorkflowStageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowStageClient) UpdateOneID(id object.ID) *WorkflowStageUpdateOne {
	mutation := newWorkflowStageMutation(c.config, OpUpdateOne, withWorkflowStageID(id))
	return &WorkflowStageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowStage.
func (c *WorkflowStageClient) Delete() *WorkflowStageDelete {
	mutation := newWorkflowStageMutation(c.config, OpDelete)
	return &WorkflowStageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowStageClient) DeleteOne(ws *WorkflowStage) *WorkflowStageDeleteOne {
	return c.DeleteOneID(ws.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowStageClient) DeleteOneID(id object.ID) *WorkflowStageDeleteOne {
	builder := c.Delete().Where(workflowstage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowStageDeleteOne{builder}
}

// Query returns a query builder for WorkflowStage.
func (c *WorkflowStageClient) Query() *WorkflowStageQuery {
	return &WorkflowStageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowStage},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowStage entity by its id.
func (c *WorkflowStageClient) Get(ctx context.Context, id object.ID) (*WorkflowStage, error) {
	return c.Query().Where(workflowstage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowStageClient) GetX(ctx context.Context, id object.ID) *WorkflowStage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a WorkflowStage.
func (c *WorkflowStageClient) QueryProject(ws *WorkflowStage) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstage.Table, workflowstage.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowstage.ProjectTable, workflowstage.ProjectColumn),
		)
		schemaConfig := ws.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.WorkflowStage
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySteps queries the steps edge of a WorkflowStage.
func (c *WorkflowStageClient) QuerySteps(ws *WorkflowStage) *WorkflowStepQuery {
	query := (&WorkflowStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstage.Table, workflowstage.FieldID, id),
			sqlgraph.To(workflowstep.Table, workflowstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowstage.StepsTable, workflowstage.StepsColumn),
		)
		schemaConfig := ws.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStep
		step.Edge.Schema = schemaConfig.WorkflowStep
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflow queries the workflow edge of a WorkflowStage.
func (c *WorkflowStageClient) QueryWorkflow(ws *WorkflowStage) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstage.Table, workflowstage.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowstage.WorkflowTable, workflowstage.WorkflowColumn),
		)
		schemaConfig := ws.schemaConfig
		step.To.Schema = schemaConfig.Workflow
		step.Edge.Schema = schemaConfig.WorkflowStage
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowStageClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowStage
	return append(hooks[:len(hooks):len(hooks)], workflowstage.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowStageClient) Interceptors() []Interceptor {
	inters := c.inters.WorkflowStage
	return append(inters[:len(inters):len(inters)], workflowstage.Interceptors[:]...)
}

func (c *WorkflowStageClient) mutate(ctx context.Context, m *WorkflowStageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowStageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowStageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowStageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowStageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown WorkflowStage mutation op: %q", m.Op())
	}
}

// WorkflowStageExecutionClient is a client for the WorkflowStageExecution schema.
type WorkflowStageExecutionClient struct {
	config
}

// NewWorkflowStageExecutionClient returns a client for the WorkflowStageExecution from the given config.
func NewWorkflowStageExecutionClient(c config) *WorkflowStageExecutionClient {
	return &WorkflowStageExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowstageexecution.Hooks(f(g(h())))`.
func (c *WorkflowStageExecutionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowStageExecution = append(c.hooks.WorkflowStageExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowstageexecution.Intercept(f(g(h())))`.
func (c *WorkflowStageExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowStageExecution = append(c.inters.WorkflowStageExecution, interceptors...)
}

// Create returns a builder for creating a WorkflowStageExecution entity.
func (c *WorkflowStageExecutionClient) Create() *WorkflowStageExecutionCreate {
	mutation := newWorkflowStageExecutionMutation(c.config, OpCreate)
	return &WorkflowStageExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowStageExecution entities.
func (c *WorkflowStageExecutionClient) CreateBulk(builders ...*WorkflowStageExecutionCreate) *WorkflowStageExecutionCreateBulk {
	return &WorkflowStageExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowStageExecutionClient) MapCreateBulk(slice any, setFunc func(*WorkflowStageExecutionCreate, int)) *WorkflowStageExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowStageExecutionCreateBulk{err: fmt.Errorf("calling to WorkflowStageExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowStageExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowStageExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowStageExecution.
func (c *WorkflowStageExecutionClient) Update() *WorkflowStageExecutionUpdate {
	mutation := newWorkflowStageExecutionMutation(c.config, OpUpdate)
	return &WorkflowStageExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowStageExecutionClient) UpdateOne(wse *WorkflowStageExecution) *WorkflowStageExecutionUpdateOne {
	mutation := newWorkflowStageExecutionMutation(c.config, OpUpdateOne, withWorkflowStageExecution(wse))
	return &WorkflowStageExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowStageExecutionClient) UpdateOneID(id object.ID) *WorkflowStageExecutionUpdateOne {
	mutation := newWorkflowStageExecutionMutation(c.config, OpUpdateOne, withWorkflowStageExecutionID(id))
	return &WorkflowStageExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowStageExecution.
func (c *WorkflowStageExecutionClient) Delete() *WorkflowStageExecutionDelete {
	mutation := newWorkflowStageExecutionMutation(c.config, OpDelete)
	return &WorkflowStageExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowStageExecutionClient) DeleteOne(wse *WorkflowStageExecution) *WorkflowStageExecutionDeleteOne {
	return c.DeleteOneID(wse.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowStageExecutionClient) DeleteOneID(id object.ID) *WorkflowStageExecutionDeleteOne {
	builder := c.Delete().Where(workflowstageexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowStageExecutionDeleteOne{builder}
}

// Query returns a query builder for WorkflowStageExecution.
func (c *WorkflowStageExecutionClient) Query() *WorkflowStageExecutionQuery {
	return &WorkflowStageExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowStageExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowStageExecution entity by its id.
func (c *WorkflowStageExecutionClient) Get(ctx context.Context, id object.ID) (*WorkflowStageExecution, error) {
	return c.Query().Where(workflowstageexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowStageExecutionClient) GetX(ctx context.Context, id object.ID) *WorkflowStageExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a WorkflowStageExecution.
func (c *WorkflowStageExecutionClient) QueryProject(wse *WorkflowStageExecution) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wse.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstageexecution.Table, workflowstageexecution.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowstageexecution.ProjectTable, workflowstageexecution.ProjectColumn),
		)
		schemaConfig := wse.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.WorkflowStageExecution
		fromV = sqlgraph.Neighbors(wse.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySteps queries the steps edge of a WorkflowStageExecution.
func (c *WorkflowStageExecutionClient) QuerySteps(wse *WorkflowStageExecution) *WorkflowStepExecutionQuery {
	query := (&WorkflowStepExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wse.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstageexecution.Table, workflowstageexecution.FieldID, id),
			sqlgraph.To(workflowstepexecution.Table, workflowstepexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowstageexecution.StepsTable, workflowstageexecution.StepsColumn),
		)
		schemaConfig := wse.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStepExecution
		step.Edge.Schema = schemaConfig.WorkflowStepExecution
		fromV = sqlgraph.Neighbors(wse.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflowExecution queries the workflow_execution edge of a WorkflowStageExecution.
func (c *WorkflowStageExecutionClient) QueryWorkflowExecution(wse *WorkflowStageExecution) *WorkflowExecutionQuery {
	query := (&WorkflowExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wse.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstageexecution.Table, workflowstageexecution.FieldID, id),
			sqlgraph.To(workflowexecution.Table, workflowexecution.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowstageexecution.WorkflowExecutionTable, workflowstageexecution.WorkflowExecutionColumn),
		)
		schemaConfig := wse.schemaConfig
		step.To.Schema = schemaConfig.WorkflowExecution
		step.Edge.Schema = schemaConfig.WorkflowStageExecution
		fromV = sqlgraph.Neighbors(wse.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowStageExecutionClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowStageExecution
	return append(hooks[:len(hooks):len(hooks)], workflowstageexecution.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowStageExecutionClient) Interceptors() []Interceptor {
	inters := c.inters.WorkflowStageExecution
	return append(inters[:len(inters):len(inters)], workflowstageexecution.Interceptors[:]...)
}

func (c *WorkflowStageExecutionClient) mutate(ctx context.Context, m *WorkflowStageExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowStageExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowStageExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowStageExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowStageExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown WorkflowStageExecution mutation op: %q", m.Op())
	}
}

// WorkflowStepClient is a client for the WorkflowStep schema.
type WorkflowStepClient struct {
	config
}

// NewWorkflowStepClient returns a client for the WorkflowStep from the given config.
func NewWorkflowStepClient(c config) *WorkflowStepClient {
	return &WorkflowStepClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowstep.Hooks(f(g(h())))`.
func (c *WorkflowStepClient) Use(hooks ...Hook) {
	c.hooks.WorkflowStep = append(c.hooks.WorkflowStep, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowstep.Intercept(f(g(h())))`.
func (c *WorkflowStepClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowStep = append(c.inters.WorkflowStep, interceptors...)
}

// Create returns a builder for creating a WorkflowStep entity.
func (c *WorkflowStepClient) Create() *WorkflowStepCreate {
	mutation := newWorkflowStepMutation(c.config, OpCreate)
	return &WorkflowStepCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowStep entities.
func (c *WorkflowStepClient) CreateBulk(builders ...*WorkflowStepCreate) *WorkflowStepCreateBulk {
	return &WorkflowStepCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowStepClient) MapCreateBulk(slice any, setFunc func(*WorkflowStepCreate, int)) *WorkflowStepCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowStepCreateBulk{err: fmt.Errorf("calling to WorkflowStepClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowStepCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowStepCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowStep.
func (c *WorkflowStepClient) Update() *WorkflowStepUpdate {
	mutation := newWorkflowStepMutation(c.config, OpUpdate)
	return &WorkflowStepUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowStepClient) UpdateOne(ws *WorkflowStep) *WorkflowStepUpdateOne {
	mutation := newWorkflowStepMutation(c.config, OpUpdateOne, withWorkflowStep(ws))
	return &WorkflowStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowStepClient) UpdateOneID(id object.ID) *WorkflowStepUpdateOne {
	mutation := newWorkflowStepMutation(c.config, OpUpdateOne, withWorkflowStepID(id))
	return &WorkflowStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowStep.
func (c *WorkflowStepClient) Delete() *WorkflowStepDelete {
	mutation := newWorkflowStepMutation(c.config, OpDelete)
	return &WorkflowStepDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowStepClient) DeleteOne(ws *WorkflowStep) *WorkflowStepDeleteOne {
	return c.DeleteOneID(ws.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowStepClient) DeleteOneID(id object.ID) *WorkflowStepDeleteOne {
	builder := c.Delete().Where(workflowstep.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowStepDeleteOne{builder}
}

// Query returns a query builder for WorkflowStep.
func (c *WorkflowStepClient) Query() *WorkflowStepQuery {
	return &WorkflowStepQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowStep},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowStep entity by its id.
func (c *WorkflowStepClient) Get(ctx context.Context, id object.ID) (*WorkflowStep, error) {
	return c.Query().Where(workflowstep.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowStepClient) GetX(ctx context.Context, id object.ID) *WorkflowStep {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a WorkflowStep.
func (c *WorkflowStepClient) QueryProject(ws *WorkflowStep) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstep.Table, workflowstep.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowstep.ProjectTable, workflowstep.ProjectColumn),
		)
		schemaConfig := ws.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.WorkflowStep
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStage queries the stage edge of a WorkflowStep.
func (c *WorkflowStepClient) QueryStage(ws *WorkflowStep) *WorkflowStageQuery {
	query := (&WorkflowStageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstep.Table, workflowstep.FieldID, id),
			sqlgraph.To(workflowstage.Table, workflowstage.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowstep.StageTable, workflowstep.StageColumn),
		)
		schemaConfig := ws.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStage
		step.Edge.Schema = schemaConfig.WorkflowStep
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowStepClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowStep
	return append(hooks[:len(hooks):len(hooks)], workflowstep.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowStepClient) Interceptors() []Interceptor {
	inters := c.inters.WorkflowStep
	return append(inters[:len(inters):len(inters)], workflowstep.Interceptors[:]...)
}

func (c *WorkflowStepClient) mutate(ctx context.Context, m *WorkflowStepMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowStepCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowStepUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowStepDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown WorkflowStep mutation op: %q", m.Op())
	}
}

// WorkflowStepExecutionClient is a client for the WorkflowStepExecution schema.
type WorkflowStepExecutionClient struct {
	config
}

// NewWorkflowStepExecutionClient returns a client for the WorkflowStepExecution from the given config.
func NewWorkflowStepExecutionClient(c config) *WorkflowStepExecutionClient {
	return &WorkflowStepExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowstepexecution.Hooks(f(g(h())))`.
func (c *WorkflowStepExecutionClient) Use(hooks ...Hook) {
	c.hooks.WorkflowStepExecution = append(c.hooks.WorkflowStepExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflowstepexecution.Intercept(f(g(h())))`.
func (c *WorkflowStepExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkflowStepExecution = append(c.inters.WorkflowStepExecution, interceptors...)
}

// Create returns a builder for creating a WorkflowStepExecution entity.
func (c *WorkflowStepExecutionClient) Create() *WorkflowStepExecutionCreate {
	mutation := newWorkflowStepExecutionMutation(c.config, OpCreate)
	return &WorkflowStepExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowStepExecution entities.
func (c *WorkflowStepExecutionClient) CreateBulk(builders ...*WorkflowStepExecutionCreate) *WorkflowStepExecutionCreateBulk {
	return &WorkflowStepExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowStepExecutionClient) MapCreateBulk(slice any, setFunc func(*WorkflowStepExecutionCreate, int)) *WorkflowStepExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowStepExecutionCreateBulk{err: fmt.Errorf("calling to WorkflowStepExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowStepExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowStepExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowStepExecution.
func (c *WorkflowStepExecutionClient) Update() *WorkflowStepExecutionUpdate {
	mutation := newWorkflowStepExecutionMutation(c.config, OpUpdate)
	return &WorkflowStepExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowStepExecutionClient) UpdateOne(wse *WorkflowStepExecution) *WorkflowStepExecutionUpdateOne {
	mutation := newWorkflowStepExecutionMutation(c.config, OpUpdateOne, withWorkflowStepExecution(wse))
	return &WorkflowStepExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowStepExecutionClient) UpdateOneID(id object.ID) *WorkflowStepExecutionUpdateOne {
	mutation := newWorkflowStepExecutionMutation(c.config, OpUpdateOne, withWorkflowStepExecutionID(id))
	return &WorkflowStepExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowStepExecution.
func (c *WorkflowStepExecutionClient) Delete() *WorkflowStepExecutionDelete {
	mutation := newWorkflowStepExecutionMutation(c.config, OpDelete)
	return &WorkflowStepExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowStepExecutionClient) DeleteOne(wse *WorkflowStepExecution) *WorkflowStepExecutionDeleteOne {
	return c.DeleteOneID(wse.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowStepExecutionClient) DeleteOneID(id object.ID) *WorkflowStepExecutionDeleteOne {
	builder := c.Delete().Where(workflowstepexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowStepExecutionDeleteOne{builder}
}

// Query returns a query builder for WorkflowStepExecution.
func (c *WorkflowStepExecutionClient) Query() *WorkflowStepExecutionQuery {
	return &WorkflowStepExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflowStepExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkflowStepExecution entity by its id.
func (c *WorkflowStepExecutionClient) Get(ctx context.Context, id object.ID) (*WorkflowStepExecution, error) {
	return c.Query().Where(workflowstepexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowStepExecutionClient) GetX(ctx context.Context, id object.ID) *WorkflowStepExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a WorkflowStepExecution.
func (c *WorkflowStepExecutionClient) QueryProject(wse *WorkflowStepExecution) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wse.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstepexecution.Table, workflowstepexecution.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowstepexecution.ProjectTable, workflowstepexecution.ProjectColumn),
		)
		schemaConfig := wse.schemaConfig
		step.To.Schema = schemaConfig.Project
		step.Edge.Schema = schemaConfig.WorkflowStepExecution
		fromV = sqlgraph.Neighbors(wse.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStageExecution queries the stage_execution edge of a WorkflowStepExecution.
func (c *WorkflowStepExecutionClient) QueryStageExecution(wse *WorkflowStepExecution) *WorkflowStageExecutionQuery {
	query := (&WorkflowStageExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wse.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowstepexecution.Table, workflowstepexecution.FieldID, id),
			sqlgraph.To(workflowstageexecution.Table, workflowstageexecution.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowstepexecution.StageExecutionTable, workflowstepexecution.StageExecutionColumn),
		)
		schemaConfig := wse.schemaConfig
		step.To.Schema = schemaConfig.WorkflowStageExecution
		step.Edge.Schema = schemaConfig.WorkflowStepExecution
		fromV = sqlgraph.Neighbors(wse.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowStepExecutionClient) Hooks() []Hook {
	hooks := c.hooks.WorkflowStepExecution
	return append(hooks[:len(hooks):len(hooks)], workflowstepexecution.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WorkflowStepExecutionClient) Interceptors() []Interceptor {
	inters := c.inters.WorkflowStepExecution
	return append(inters[:len(inters):len(inters)], workflowstepexecution.Interceptors[:]...)
}

func (c *WorkflowStepExecutionClient) mutate(ctx context.Context, m *WorkflowStepExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowStepExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowStepExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowStepExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowStepExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model: unknown WorkflowStepExecution mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Catalog, Connector, CostReport, DistributeLock, Environment,
		EnvironmentConnectorRelationship, Perspective, Project, Resource,
		ResourceComponent, ResourceComponentRelationship, ResourceDefinition,
		ResourceDefinitionMatchingRule, ResourceRelationship, ResourceRun, Role,
		Setting, Subject, SubjectRoleRelationship, Template, TemplateVersion, Token,
		Variable, Workflow, WorkflowExecution, WorkflowStage, WorkflowStageExecution,
		WorkflowStep, WorkflowStepExecution []ent.Hook
	}
	inters struct {
		Catalog, Connector, CostReport, DistributeLock, Environment,
		EnvironmentConnectorRelationship, Perspective, Project, Resource,
		ResourceComponent, ResourceComponentRelationship, ResourceDefinition,
		ResourceDefinitionMatchingRule, ResourceRelationship, ResourceRun, Role,
		Setting, Subject, SubjectRoleRelationship, Template, TemplateVersion, Token,
		Variable, Workflow, WorkflowExecution, WorkflowStage, WorkflowStageExecution,
		WorkflowStep, WorkflowStepExecution []ent.Interceptor
	}
)

// SchemaConfig represents alternative schema names for all tables
// that can be passed at runtime.
type SchemaConfig = internal.SchemaConfig

// AlternateSchemas allows alternate schema names to be
// passed into ent operations.
func AlternateSchema(schemaConfig SchemaConfig) Option {
	return func(c *config) {
		c.schemaConfig = schemaConfig
	}
}

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
