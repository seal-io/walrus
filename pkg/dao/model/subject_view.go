// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "seal". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"time"

	"github.com/seal-io/seal/pkg/dao/model/predicate"
	"github.com/seal-io/seal/pkg/dao/model/subject"
	"github.com/seal-io/seal/pkg/dao/types/object"
)

// SubjectCreateInput holds the creation input of the Subject entity.
type SubjectCreateInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Name        string `uri:"-" query:"-" json:"name"`
	Kind        string `uri:"-" query:"-" json:"kind,omitempty"`
	Domain      string `uri:"-" query:"-" json:"domain,omitempty"`
	Description string `uri:"-" query:"-" json:"description,omitempty"`
	Builtin     bool   `uri:"-" query:"-" json:"builtin,omitempty"`

	Roles []*SubjectRoleRelationshipCreateInput `uri:"-" query:"-" json:"roles,omitempty"`
}

// Model returns the Subject entity for creating,
// after validating.
func (sci *SubjectCreateInput) Model() *Subject {
	if sci == nil {
		return nil
	}

	s := &Subject{
		Name:        sci.Name,
		Kind:        sci.Kind,
		Domain:      sci.Domain,
		Description: sci.Description,
		Builtin:     sci.Builtin,
	}

	for j := range sci.Roles {
		if sci.Roles[j] == nil {
			continue
		}
		s.Edges.Roles = append(s.Edges.Roles,
			sci.Roles[j].Model())
	}
	return s
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sci *SubjectCreateInput) Load() error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	return sci.LoadWith(sci.inputConfig.Context, sci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sci *SubjectCreateInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sci == nil {
		return errors.New("nil receiver")
	}

	for i := range sci.Roles {
		if sci.Roles[i] == nil {
			continue
		}
		err = sci.Roles[i].LoadWith(ctx, cs)
		if err != nil {
			return err
		}
	}
	return nil
}

// SubjectCreateInputs holds the creation input item of the Subject entities.
type SubjectCreateInputsItem struct {
	Name        string `uri:"-" query:"-" json:"name"`
	Kind        string `uri:"-" query:"-" json:"kind,omitempty"`
	Domain      string `uri:"-" query:"-" json:"domain,omitempty"`
	Description string `uri:"-" query:"-" json:"description,omitempty"`
	Builtin     bool   `uri:"-" query:"-" json:"builtin,omitempty"`

	Roles []*SubjectRoleRelationshipCreateInput `uri:"-" query:"-" json:"roles,omitempty"`
}

// SubjectCreateInputs holds the creation input of the Subject entities.
type SubjectCreateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*SubjectCreateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Subject entities for creating,
// after validating.
func (sci *SubjectCreateInputs) Model() []*Subject {
	if sci == nil || len(sci.Items) == 0 {
		return nil
	}

	ss := make([]*Subject, len(sci.Items))

	for i := range sci.Items {
		s := &Subject{
			Name:        sci.Items[i].Name,
			Kind:        sci.Items[i].Kind,
			Domain:      sci.Items[i].Domain,
			Description: sci.Items[i].Description,
			Builtin:     sci.Items[i].Builtin,
		}

		for j := range sci.Items[i].Roles {
			if sci.Items[i].Roles[j] == nil {
				continue
			}
			s.Edges.Roles = append(s.Edges.Roles,
				sci.Items[i].Roles[j].Model())
		}

		ss[i] = s
	}

	return ss
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sci *SubjectCreateInputs) Load() error {
	if sci == nil {
		return errors.New("nil receiver")
	}

	return sci.LoadWith(sci.inputConfig.Context, sci.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sci *SubjectCreateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sci == nil {
		return errors.New("nil receiver")
	}

	if len(sci.Items) == 0 {
		return errors.New("empty items")
	}

	return nil
}

// SubjectDeleteInput holds the deletion input of the Subject entity.
type SubjectDeleteInput = SubjectQueryInput

// SubjectDeleteInputs holds the deletion input item of the Subject entities.
type SubjectDeleteInputsItem struct {
	ID     object.ID `uri:"-" query:"-" json:"id,omitempty"`
	Kind   string    `uri:"-" query:"-" json:"kind,omitempty"`
	Domain string    `uri:"-" query:"-" json:"domain,omitempty"`
	Name   string    `uri:"-" query:"-" json:"name,omitempty"`
}

// SubjectDeleteInputs holds the deletion input of the Subject entities.
type SubjectDeleteInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*SubjectDeleteInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Subject entities for deleting,
// after validating.
func (sdi *SubjectDeleteInputs) Model() []*Subject {
	if sdi == nil || len(sdi.Items) == 0 {
		return nil
	}

	ss := make([]*Subject, len(sdi.Items))
	for i := range sdi.Items {
		ss[i] = &Subject{
			ID: sdi.Items[i].ID,
		}
	}
	return ss
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sdi *SubjectDeleteInputs) Load() error {
	if sdi == nil {
		return errors.New("nil receiver")
	}

	return sdi.LoadWith(sdi.inputConfig.Context, sdi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sdi *SubjectDeleteInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sdi == nil {
		return errors.New("nil receiver")
	}

	if len(sdi.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Subjects().Query()

	ids := make([]object.ID, 0, len(sdi.Items))
	ors := make([]predicate.Subject, 0, len(sdi.Items))

	for i := range sdi.Items {
		if sdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if sdi.Items[i].ID != "" {
			ids = append(ids, sdi.Items[i].ID)
			ors = append(ors, subject.ID(sdi.Items[i].ID))
		} else if (sdi.Items[i].Kind != "") && (sdi.Items[i].Domain != "") && (sdi.Items[i].Name != "") {
			ors = append(ors, subject.And(
				subject.Kind(sdi.Items[i].Kind), subject.Domain(sdi.Items[i].Domain), subject.Name(sdi.Items[i].Name)))
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)
	if idsLen != cap(ids) {
		ids, err = q.Where(subject.Or(ors...)).
			IDs(ctx)
		if err != nil {
			return err
		}

		if len(ids) != idsLen {
			return errors.New("found unrecognized item")
		}

		for i := range ids {
			sdi.Items[i].ID = ids[i]
		}

		return nil
	}

	idsCnt, err := q.Where(subject.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// SubjectQueryInput holds the query input of the Subject entity.
type SubjectQueryInput struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Refer  *object.Refer `uri:"subject,default=\"\"" query:"-" json:"-"`
	ID     object.ID     `uri:"id" query:"-" json:"id,omitempty"` // TODO(thxCode): remove the uri:"id" after supporting hierarchical routes.
	Kind   string        `uri:"-" query:"-" json:"kind,omitempty"`
	Domain string        `uri:"-" query:"-" json:"domain,omitempty"`
	Name   string        `uri:"-" query:"-" json:"name,omitempty"`
}

// Model returns the Subject entity for querying,
// after validating.
func (sqi *SubjectQueryInput) Model() *Subject {
	if sqi == nil {
		return nil
	}

	return &Subject{
		ID: sqi.ID,
	}
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sqi *SubjectQueryInput) Load() error {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	return sqi.LoadWith(sqi.inputConfig.Context, sqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sqi *SubjectQueryInput) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	if sqi.Refer != nil && *sqi.Refer == "" {
		return nil
	}

	q := cs.Subjects().Query()

	if sqi.Refer != nil {
		if sqi.Refer.IsID() {
			q.Where(
				subject.ID(sqi.Refer.ID()))
		} else if refers := sqi.Refer.Split(3); len(refers) == 3 {
			q.Where(
				subject.Kind(refers[0].String()),
				subject.Domain(refers[1].String()),
				subject.Name(refers[2].String()))
		} else {
			return errors.New("invalid identify refer of subject")
		}
	} else if sqi.ID != "" {
		q.Where(
			subject.ID(sqi.ID))
	} else if (sqi.Kind != "") && (sqi.Domain != "") && (sqi.Name != "") {
		q.Where(
			subject.Kind(sqi.Kind), subject.Domain(sqi.Domain), subject.Name(sqi.Name))
	} else {
		return errors.New("invalid identify of subject")
	}

	sqi.ID, err = q.OnlyID(ctx)
	return err
}

// SubjectQueryInputs holds the query input of the Subject entities.
type SubjectQueryInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sqi *SubjectQueryInputs) Load() error {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	return sqi.LoadWith(sqi.inputConfig.Context, sqi.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sqi *SubjectQueryInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sqi == nil {
		return errors.New("nil receiver")
	}

	return err
}

// SubjectUpdateInput holds the modification input of the Subject entity.
type SubjectUpdateInput struct {
	SubjectQueryInput `uri:",inline" query:"-" json:",inline"`

	Kind        string `uri:"-" query:"-" json:"kind,omitempty"`
	Domain      string `uri:"-" query:"-" json:"domain,omitempty"`
	Name        string `uri:"-" query:"-" json:"name,omitempty"`
	Description string `uri:"-" query:"-" json:"description,omitempty"`

	Roles []*SubjectRoleRelationshipUpdateInput `uri:"-" query:"-" json:"roles,omitempty"`
}

// Model returns the Subject entity for modifying,
// after validating.
func (sui *SubjectUpdateInput) Model() *Subject {
	if sui == nil {
		return nil
	}

	s := &Subject{
		ID:          sui.ID,
		Kind:        sui.Kind,
		Domain:      sui.Domain,
		Name:        sui.Name,
		Description: sui.Description,
	}

	for j := range sui.Roles {
		if sui.Roles[j] == nil {
			continue
		}
		s.Edges.Roles = append(s.Edges.Roles,
			sui.Roles[j].Model())
	}
	return s
}

// SubjectUpdateInputs holds the modification input item of the Subject entities.
type SubjectUpdateInputsItem struct {
	ID     object.ID `uri:"-" query:"-" json:"id,omitempty"`
	Kind   string    `uri:"-" query:"-" json:"kind,omitempty"`
	Domain string    `uri:"-" query:"-" json:"domain,omitempty"`
	Name   string    `uri:"-" query:"-" json:"name,omitempty"`

	Description string `uri:"-" query:"-" json:"description,omitempty"`

	Roles []*SubjectRoleRelationshipUpdateInput `uri:"-" query:"-" json:"roles,omitempty"`
}

// SubjectUpdateInputs holds the modification input of the Subject entities.
type SubjectUpdateInputs struct {
	inputConfig `uri:"-" query:"-" json:"-"`

	Items []*SubjectUpdateInputsItem `uri:"-" query:"-" json:"items"`
}

// Model returns the Subject entities for modifying,
// after validating.
func (sui *SubjectUpdateInputs) Model() []*Subject {
	if sui == nil || len(sui.Items) == 0 {
		return nil
	}

	ss := make([]*Subject, len(sui.Items))

	for i := range sui.Items {
		s := &Subject{
			ID:          sui.Items[i].ID,
			Kind:        sui.Items[i].Kind,
			Domain:      sui.Items[i].Domain,
			Name:        sui.Items[i].Name,
			Description: sui.Items[i].Description,
		}

		for j := range sui.Items[i].Roles {
			if sui.Items[i].Roles[j] == nil {
				continue
			}
			s.Edges.Roles = append(s.Edges.Roles,
				sui.Items[i].Roles[j].Model())
		}

		ss[i] = s
	}

	return ss
}

// Load checks the input.
// TODO(thxCode): rename to Validate after supporting hierarchical routes.
func (sui *SubjectUpdateInputs) Load() error {
	if sui == nil {
		return errors.New("nil receiver")
	}

	return sui.LoadWith(sui.inputConfig.Context, sui.inputConfig.ClientSet)
}

// LoadWith checks the input with the given context and client set.
// TODO(thxCode): rename to ValidateWith after supporting hierarchical routes.
func (sui *SubjectUpdateInputs) LoadWith(ctx context.Context, cs ClientSet) (err error) {
	if sui == nil {
		return errors.New("nil receiver")
	}

	if len(sui.Items) == 0 {
		return errors.New("empty items")
	}

	q := cs.Subjects().Query()

	ids := make([]object.ID, 0, len(sui.Items))
	ors := make([]predicate.Subject, 0, len(sui.Items))

	for i := range sui.Items {
		if sui.Items[i] == nil {
			return errors.New("nil item")
		}

		if sui.Items[i].ID != "" {
			ids = append(ids, sui.Items[i].ID)
			ors = append(ors, subject.ID(sui.Items[i].ID))
		} else if (sui.Items[i].Kind != "") && (sui.Items[i].Domain != "") && (sui.Items[i].Name != "") {
			ors = append(ors, subject.And(
				subject.Kind(sui.Items[i].Kind), subject.Domain(sui.Items[i].Domain), subject.Name(sui.Items[i].Name)))
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	idsLen := len(ids)
	if idsLen != cap(ids) {
		ids, err = q.Where(subject.Or(ors...)).
			IDs(ctx)
		if err != nil {
			return err
		}

		if len(ids) != idsLen {
			return errors.New("found unrecognized item")
		}

		for i := range ids {
			sui.Items[i].ID = ids[i]
		}

		return nil
	}

	idsCnt, err := q.Where(subject.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != idsLen {
		return errors.New("found unrecognized item")
	}

	return nil
}

// SubjectOutput holds the output of the Subject entity.
type SubjectOutput struct {
	ID          object.ID  `json:"id,omitempty"`
	CreateTime  *time.Time `json:"createTime,omitempty"`
	UpdateTime  *time.Time `json:"updateTime,omitempty"`
	Kind        string     `json:"kind,omitempty"`
	Domain      string     `json:"domain,omitempty"`
	Name        string     `json:"name,omitempty"`
	Description string     `json:"description,omitempty"`
	Builtin     bool       `json:"builtin,omitempty"`

	Roles []*SubjectRoleRelationshipOutput `json:"roles,omitempty"`
}

// View returns the output of Subject.
func (s *Subject) View() *SubjectOutput {
	return ExposeSubject(s)
}

// View returns the output of Subjects.
func (ss Subjects) View() []*SubjectOutput {
	return ExposeSubjects(ss)
}

// ExposeSubject converts the Subject to SubjectOutput.
func ExposeSubject(s *Subject) *SubjectOutput {
	if s == nil {
		return nil
	}

	so := &SubjectOutput{
		ID:          s.ID,
		CreateTime:  s.CreateTime,
		UpdateTime:  s.UpdateTime,
		Kind:        s.Kind,
		Domain:      s.Domain,
		Name:        s.Name,
		Description: s.Description,
		Builtin:     s.Builtin,
	}

	if s.Edges.Roles != nil {
		so.Roles = ExposeSubjectRoleRelationships(s.Edges.Roles)
	}
	return so
}

// ExposeSubjects converts the Subject slice to SubjectOutput pointer slice.
func ExposeSubjects(ss []*Subject) []*SubjectOutput {
	if len(ss) == 0 {
		return nil
	}

	sos := make([]*SubjectOutput, len(ss))
	for i := range ss {
		sos[i] = ExposeSubject(ss[i])
	}
	return sos
}
