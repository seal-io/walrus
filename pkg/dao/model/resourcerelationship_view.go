// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/seal-io/walrus/pkg/dao/model/resourcerelationship"
	"github.com/seal-io/walrus/pkg/dao/types/object"
	"github.com/seal-io/walrus/utils/json"
)

// ResourceRelationshipCreateInput holds the creation input of the ResourceRelationship entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceRelationshipCreateInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Dependency specifies full inserting the new Resource entity of the ResourceRelationship entity.
	Dependency *ResourceQueryInput `uri:"-" query:"-" json:"dependency"`
}

// Model returns the ResourceRelationship entity for creating,
// after validating.
func (rrci *ResourceRelationshipCreateInput) Model() *ResourceRelationship {
	if rrci == nil {
		return nil
	}

	_rr := &ResourceRelationship{}

	if rrci.Dependency != nil {
		_rr.DependencyID = rrci.Dependency.ID
	}
	return _rr
}

// Validate checks the ResourceRelationshipCreateInput entity.
func (rrci *ResourceRelationshipCreateInput) Validate() error {
	if rrci == nil {
		return errors.New("nil receiver")
	}

	return rrci.ValidateWith(rrci.inputConfig.Context, rrci.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceRelationshipCreateInput entity with the given context and client set.
func (rrci *ResourceRelationshipCreateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rrci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	if rrci.Dependency != nil {
		if err := rrci.Dependency.ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rrci.Dependency = nil
			}
		}
	}

	return nil
}

// ResourceRelationshipCreateInputs holds the creation input item of the ResourceRelationship entities.
type ResourceRelationshipCreateInputsItem struct {

	// Dependency specifies full inserting the new Resource entity.
	Dependency *ResourceQueryInput `uri:"-" query:"-" json:"dependency"`
}

// ValidateWith checks the ResourceRelationshipCreateInputsItem entity with the given context and client set.
func (rrci *ResourceRelationshipCreateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rrci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	if rrci.Dependency != nil {
		if err := rrci.Dependency.ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rrci.Dependency = nil
			}
		}
	}

	return nil
}

// ResourceRelationshipCreateInputs holds the creation input of the ResourceRelationship entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceRelationshipCreateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceRelationshipCreateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceRelationship entities for creating,
// after validating.
func (rrci *ResourceRelationshipCreateInputs) Model() []*ResourceRelationship {
	if rrci == nil || len(rrci.Items) == 0 {
		return nil
	}

	_rrs := make([]*ResourceRelationship, len(rrci.Items))

	for i := range rrci.Items {
		_rr := &ResourceRelationship{}

		if rrci.Items[i].Dependency != nil {
			_rr.DependencyID = rrci.Items[i].Dependency.ID
		}

		_rrs[i] = _rr
	}

	return _rrs
}

// Validate checks the ResourceRelationshipCreateInputs entity .
func (rrci *ResourceRelationshipCreateInputs) Validate() error {
	if rrci == nil {
		return errors.New("nil receiver")
	}

	return rrci.ValidateWith(rrci.inputConfig.Context, rrci.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceRelationshipCreateInputs entity with the given context and client set.
func (rrci *ResourceRelationshipCreateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rrci == nil {
		return errors.New("nil receiver")
	}

	if len(rrci.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range rrci.Items {
		if rrci.Items[i] == nil {
			continue
		}

		if err := rrci.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ResourceRelationshipDeleteInput holds the deletion input of the ResourceRelationship entity,
// please tags with `path:",inline"` if embedding.
type ResourceRelationshipDeleteInput struct {
	ResourceRelationshipQueryInput `path:",inline"`
}

// ResourceRelationshipDeleteInputs holds the deletion input item of the ResourceRelationship entities.
type ResourceRelationshipDeleteInputsItem struct {
	// ID of the ResourceRelationship entity.
	ID object.ID `path:"-" query:"-" json:"id"`
}

// ResourceRelationshipDeleteInputs holds the deletion input of the ResourceRelationship entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceRelationshipDeleteInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceRelationshipDeleteInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceRelationship entities for deleting,
// after validating.
func (rrdi *ResourceRelationshipDeleteInputs) Model() []*ResourceRelationship {
	if rrdi == nil || len(rrdi.Items) == 0 {
		return nil
	}

	_rrs := make([]*ResourceRelationship, len(rrdi.Items))
	for i := range rrdi.Items {
		_rrs[i] = &ResourceRelationship{
			ID: rrdi.Items[i].ID,
		}
	}
	return _rrs
}

// IDs returns the ID list of the ResourceRelationship entities for deleting,
// after validating.
func (rrdi *ResourceRelationshipDeleteInputs) IDs() []object.ID {
	if rrdi == nil || len(rrdi.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(rrdi.Items))
	for i := range rrdi.Items {
		ids[i] = rrdi.Items[i].ID
	}
	return ids
}

// Validate checks the ResourceRelationshipDeleteInputs entity.
func (rrdi *ResourceRelationshipDeleteInputs) Validate() error {
	if rrdi == nil {
		return errors.New("nil receiver")
	}

	return rrdi.ValidateWith(rrdi.inputConfig.Context, rrdi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceRelationshipDeleteInputs entity with the given context and client set.
func (rrdi *ResourceRelationshipDeleteInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rrdi == nil {
		return errors.New("nil receiver")
	}

	if len(rrdi.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceRelationships().Query()

	ids := make([]object.ID, 0, len(rrdi.Items))

	for i := range rrdi.Items {
		if rrdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if rrdi.Items[i].ID != "" {
			ids = append(ids, rrdi.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	if len(ids) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	idsCnt, err := q.Where(resourcerelationship.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != cap(ids) {
		return errors.New("found unrecognized item")
	}

	return nil
}

// ResourceRelationshipPatchInput holds the patch input of the ResourceRelationship entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceRelationshipPatchInput struct {
	ResourceRelationshipQueryInput `path:",inline" query:"-" json:"-"`

	// CreateTime holds the value of the "create_time" field.
	CreateTime *time.Time `path:"-" query:"-" json:"createTime,omitempty"`
	// ID list of the resource includes all dependencies and the resource itself.
	Path []object.ID `path:"-" query:"-" json:"path,omitempty"`
	// Type of the relationship.
	Type string `path:"-" query:"-" json:"type,omitempty"`

	// Dependency indicates replacing the stale Resource entity.
	Dependency *ResourceQueryInput `uri:"-" query:"-" json:"dependency"`

	patchedEntity *ResourceRelationship `path:"-" query:"-" json:"-"`
}

// PatchModel returns the ResourceRelationship partition entity for patching.
func (rrpi *ResourceRelationshipPatchInput) PatchModel() *ResourceRelationship {
	if rrpi == nil {
		return nil
	}

	_rr := &ResourceRelationship{
		CreateTime: rrpi.CreateTime,
		Path:       rrpi.Path,
		Type:       rrpi.Type,
	}

	if rrpi.Dependency != nil {
		_rr.DependencyID = rrpi.Dependency.ID
	}
	return _rr
}

// Model returns the ResourceRelationship patched entity,
// after validating.
func (rrpi *ResourceRelationshipPatchInput) Model() *ResourceRelationship {
	if rrpi == nil {
		return nil
	}

	return rrpi.patchedEntity
}

// Validate checks the ResourceRelationshipPatchInput entity.
func (rrpi *ResourceRelationshipPatchInput) Validate() error {
	if rrpi == nil {
		return errors.New("nil receiver")
	}

	return rrpi.ValidateWith(rrpi.inputConfig.Context, rrpi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceRelationshipPatchInput entity with the given context and client set.
func (rrpi *ResourceRelationshipPatchInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := rrpi.ResourceRelationshipQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	q := cs.ResourceRelationships().Query()

	if rrpi.Dependency != nil {
		if err := rrpi.Dependency.ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rrpi.Dependency = nil
			}
		}
	}

	if rrpi.Refer != nil {
		if rrpi.Refer.IsID() {
			q.Where(
				resourcerelationship.ID(rrpi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of resourcerelationship")
		}
	} else if rrpi.ID != "" {
		q.Where(
			resourcerelationship.ID(rrpi.ID))
	} else {
		return errors.New("invalid identify of resourcerelationship")
	}

	q.Select(
		resourcerelationship.WithoutFields(
			resourcerelationship.FieldCreateTime,
			resourcerelationship.FieldPath,
			resourcerelationship.FieldType,
		)...,
	)

	var e *ResourceRelationship
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*ResourceRelationship)
		}
	}

	_pm := rrpi.PatchModel()

	_po, err := json.PatchObject(*e, *_pm)
	if err != nil {
		return err
	}

	_obj := _po.(*ResourceRelationship)

	if !reflect.DeepEqual(e.CreateTime, _obj.CreateTime) {
		return errors.New("field createTime is immutable")
	}
	if !reflect.DeepEqual(e.Path, _obj.Path) {
		return errors.New("field path is immutable")
	}
	if e.Type != _obj.Type {
		return errors.New("field type is immutable")
	}

	rrpi.patchedEntity = _obj
	return nil
}

// ResourceRelationshipQueryInput holds the query input of the ResourceRelationship entity,
// please tags with `path:",inline"` if embedding.
type ResourceRelationshipQueryInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Refer holds the route path reference of the ResourceRelationship entity.
	Refer *object.Refer `path:"resourcerelationship,default=" query:"-" json:"-"`
	// ID of the ResourceRelationship entity.
	ID object.ID `path:"-" query:"-" json:"id"`
}

// Model returns the ResourceRelationship entity for querying,
// after validating.
func (rrqi *ResourceRelationshipQueryInput) Model() *ResourceRelationship {
	if rrqi == nil {
		return nil
	}

	return &ResourceRelationship{
		ID: rrqi.ID,
	}
}

// Validate checks the ResourceRelationshipQueryInput entity.
func (rrqi *ResourceRelationshipQueryInput) Validate() error {
	if rrqi == nil {
		return errors.New("nil receiver")
	}

	return rrqi.ValidateWith(rrqi.inputConfig.Context, rrqi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceRelationshipQueryInput entity with the given context and client set.
func (rrqi *ResourceRelationshipQueryInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rrqi == nil {
		return errors.New("nil receiver")
	}

	if rrqi.Refer != nil && *rrqi.Refer == "" {
		return fmt.Errorf("model: %s : %w", resourcerelationship.Label, ErrBlankResourceRefer)
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceRelationships().Query()

	if rrqi.Refer != nil {
		if rrqi.Refer.IsID() {
			q.Where(
				resourcerelationship.ID(rrqi.Refer.ID()))
		} else {
			return errors.New("invalid identify refer of resourcerelationship")
		}
	} else if rrqi.ID != "" {
		q.Where(
			resourcerelationship.ID(rrqi.ID))
	} else {
		return errors.New("invalid identify of resourcerelationship")
	}

	q.Select(
		resourcerelationship.FieldID,
	)

	var e *ResourceRelationship
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*ResourceRelationship)
		}
	}

	rrqi.ID = e.ID
	return nil
}

// ResourceRelationshipQueryInputs holds the query input of the ResourceRelationship entities,
// please tags with `path:",inline" query:",inline"` if embedding.
type ResourceRelationshipQueryInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`
}

// Validate checks the ResourceRelationshipQueryInputs entity.
func (rrqi *ResourceRelationshipQueryInputs) Validate() error {
	if rrqi == nil {
		return errors.New("nil receiver")
	}

	return rrqi.ValidateWith(rrqi.inputConfig.Context, rrqi.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceRelationshipQueryInputs entity with the given context and client set.
func (rrqi *ResourceRelationshipQueryInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rrqi == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// ResourceRelationshipUpdateInput holds the modification input of the ResourceRelationship entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceRelationshipUpdateInput struct {
	ResourceRelationshipQueryInput `path:",inline" query:"-" json:"-"`

	// Dependency indicates replacing the stale Resource entity.
	Dependency *ResourceQueryInput `uri:"-" query:"-" json:"dependency"`
}

// Model returns the ResourceRelationship entity for modifying,
// after validating.
func (rrui *ResourceRelationshipUpdateInput) Model() *ResourceRelationship {
	if rrui == nil {
		return nil
	}

	_rr := &ResourceRelationship{
		ID: rrui.ID,
	}

	if rrui.Dependency != nil {
		_rr.DependencyID = rrui.Dependency.ID
	}
	return _rr
}

// Validate checks the ResourceRelationshipUpdateInput entity.
func (rrui *ResourceRelationshipUpdateInput) Validate() error {
	if rrui == nil {
		return errors.New("nil receiver")
	}

	return rrui.ValidateWith(rrui.inputConfig.Context, rrui.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceRelationshipUpdateInput entity with the given context and client set.
func (rrui *ResourceRelationshipUpdateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := rrui.ResourceRelationshipQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	if rrui.Dependency != nil {
		if err := rrui.Dependency.ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rrui.Dependency = nil
			}
		}
	}

	return nil
}

// ResourceRelationshipUpdateInputs holds the modification input item of the ResourceRelationship entities.
type ResourceRelationshipUpdateInputsItem struct {
	// ID of the ResourceRelationship entity.
	ID object.ID `path:"-" query:"-" json:"id"`

	// Dependency indicates replacing the stale Resource entity.
	Dependency *ResourceQueryInput `uri:"-" query:"-" json:"dependency"`
}

// ValidateWith checks the ResourceRelationshipUpdateInputsItem entity with the given context and client set.
func (rrui *ResourceRelationshipUpdateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rrui == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	if rrui.Dependency != nil {
		if err := rrui.Dependency.ValidateWith(ctx, cs, cache); err != nil {
			if !IsBlankResourceReferError(err) {
				return err
			} else {
				rrui.Dependency = nil
			}
		}
	}

	return nil
}

// ResourceRelationshipUpdateInputs holds the modification input of the ResourceRelationship entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type ResourceRelationshipUpdateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*ResourceRelationshipUpdateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the ResourceRelationship entities for modifying,
// after validating.
func (rrui *ResourceRelationshipUpdateInputs) Model() []*ResourceRelationship {
	if rrui == nil || len(rrui.Items) == 0 {
		return nil
	}

	_rrs := make([]*ResourceRelationship, len(rrui.Items))

	for i := range rrui.Items {
		_rr := &ResourceRelationship{
			ID: rrui.Items[i].ID,
		}

		if rrui.Items[i].Dependency != nil {
			_rr.DependencyID = rrui.Items[i].Dependency.ID
		}

		_rrs[i] = _rr
	}

	return _rrs
}

// IDs returns the ID list of the ResourceRelationship entities for modifying,
// after validating.
func (rrui *ResourceRelationshipUpdateInputs) IDs() []object.ID {
	if rrui == nil || len(rrui.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(rrui.Items))
	for i := range rrui.Items {
		ids[i] = rrui.Items[i].ID
	}
	return ids
}

// Validate checks the ResourceRelationshipUpdateInputs entity.
func (rrui *ResourceRelationshipUpdateInputs) Validate() error {
	if rrui == nil {
		return errors.New("nil receiver")
	}

	return rrui.ValidateWith(rrui.inputConfig.Context, rrui.inputConfig.Client, nil)
}

// ValidateWith checks the ResourceRelationshipUpdateInputs entity with the given context and client set.
func (rrui *ResourceRelationshipUpdateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if rrui == nil {
		return errors.New("nil receiver")
	}

	if len(rrui.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.ResourceRelationships().Query()

	ids := make([]object.ID, 0, len(rrui.Items))

	for i := range rrui.Items {
		if rrui.Items[i] == nil {
			return errors.New("nil item")
		}

		if rrui.Items[i].ID != "" {
			ids = append(ids, rrui.Items[i].ID)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	if len(ids) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	idsCnt, err := q.Where(resourcerelationship.IDIn(ids...)).
		Count(ctx)
	if err != nil {
		return err
	}

	if idsCnt != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range rrui.Items {
		if err := rrui.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// ResourceRelationshipOutput holds the output of the ResourceRelationship entity.
type ResourceRelationshipOutput struct {
	ID         object.ID   `json:"id,omitempty"`
	CreateTime *time.Time  `json:"createTime,omitempty"`
	Path       []object.ID `json:"path,omitempty"`
	Type       string      `json:"type,omitempty"`

	Dependency *ResourceOutput `json:"dependency,omitempty"`
}

// View returns the output of ResourceRelationship entity.
func (_rr *ResourceRelationship) View() *ResourceRelationshipOutput {
	return ExposeResourceRelationship(_rr)
}

// View returns the output of ResourceRelationship entities.
func (_rrs ResourceRelationships) View() []*ResourceRelationshipOutput {
	return ExposeResourceRelationships(_rrs)
}

// ExposeResourceRelationship converts the ResourceRelationship to ResourceRelationshipOutput.
func ExposeResourceRelationship(_rr *ResourceRelationship) *ResourceRelationshipOutput {
	if _rr == nil {
		return nil
	}

	rro := &ResourceRelationshipOutput{
		ID:         _rr.ID,
		CreateTime: _rr.CreateTime,
		Path:       _rr.Path,
		Type:       _rr.Type,
	}

	if _rr.Edges.Dependency != nil {
		rro.Dependency = ExposeResource(_rr.Edges.Dependency)
	} else if _rr.DependencyID != "" {
		rro.Dependency = &ResourceOutput{
			ID: _rr.DependencyID,
		}
	}
	return rro
}

// ExposeResourceRelationships converts the ResourceRelationship slice to ResourceRelationshipOutput pointer slice.
func ExposeResourceRelationships(_rrs []*ResourceRelationship) []*ResourceRelationshipOutput {
	if len(_rrs) == 0 {
		return nil
	}

	rros := make([]*ResourceRelationshipOutput, len(_rrs))
	for i := range _rrs {
		rros[i] = ExposeResourceRelationship(_rrs[i])
	}
	return rros
}
