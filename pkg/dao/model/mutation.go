// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"

	"github.com/seal-io/walrus/pkg/dao/model/catalog"
	"github.com/seal-io/walrus/pkg/dao/model/connector"
	"github.com/seal-io/walrus/pkg/dao/model/costreport"
	"github.com/seal-io/walrus/pkg/dao/model/distributelock"
	"github.com/seal-io/walrus/pkg/dao/model/environment"
	"github.com/seal-io/walrus/pkg/dao/model/environmentconnectorrelationship"
	"github.com/seal-io/walrus/pkg/dao/model/perspective"
	"github.com/seal-io/walrus/pkg/dao/model/predicate"
	"github.com/seal-io/walrus/pkg/dao/model/project"
	"github.com/seal-io/walrus/pkg/dao/model/role"
	"github.com/seal-io/walrus/pkg/dao/model/service"
	"github.com/seal-io/walrus/pkg/dao/model/servicerelationship"
	"github.com/seal-io/walrus/pkg/dao/model/serviceresource"
	"github.com/seal-io/walrus/pkg/dao/model/serviceresourcerelationship"
	"github.com/seal-io/walrus/pkg/dao/model/servicerevision"
	"github.com/seal-io/walrus/pkg/dao/model/setting"
	"github.com/seal-io/walrus/pkg/dao/model/subject"
	"github.com/seal-io/walrus/pkg/dao/model/subjectrolerelationship"
	"github.com/seal-io/walrus/pkg/dao/model/template"
	"github.com/seal-io/walrus/pkg/dao/model/templateversion"
	"github.com/seal-io/walrus/pkg/dao/model/token"
	"github.com/seal-io/walrus/pkg/dao/model/variable"
	"github.com/seal-io/walrus/pkg/dao/types"
	"github.com/seal-io/walrus/pkg/dao/types/crypto"
	"github.com/seal-io/walrus/pkg/dao/types/object"
	"github.com/seal-io/walrus/pkg/dao/types/property"
	"github.com/seal-io/walrus/pkg/dao/types/status"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCatalog                          = "Catalog"
	TypeConnector                        = "Connector"
	TypeCostReport                       = "CostReport"
	TypeDistributeLock                   = "DistributeLock"
	TypeEnvironment                      = "Environment"
	TypeEnvironmentConnectorRelationship = "EnvironmentConnectorRelationship"
	TypePerspective                      = "Perspective"
	TypeProject                          = "Project"
	TypeRole                             = "Role"
	TypeService                          = "Service"
	TypeServiceRelationship              = "ServiceRelationship"
	TypeServiceResource                  = "ServiceResource"
	TypeServiceResourceRelationship      = "ServiceResourceRelationship"
	TypeServiceRevision                  = "ServiceRevision"
	TypeSetting                          = "Setting"
	TypeSubject                          = "Subject"
	TypeSubjectRoleRelationship          = "SubjectRoleRelationship"
	TypeTemplate                         = "Template"
	TypeTemplateVersion                  = "TemplateVersion"
	TypeToken                            = "Token"
	TypeVariable                         = "Variable"
)

// CatalogMutation represents an operation that mutates the Catalog nodes in the graph.
type CatalogMutation struct {
	config
	op               Op
	typ              string
	id               *object.ID
	name             *string
	description      *string
	labels           *map[string]string
	annotations      *map[string]string
	create_time      *time.Time
	update_time      *time.Time
	status           *status.Status
	_type            *string
	source           *string
	sync             **types.CatalogSync
	clearedFields    map[string]struct{}
	templates        map[object.ID]struct{}
	removedtemplates map[object.ID]struct{}
	clearedtemplates bool
	project          *object.ID
	clearedproject   bool
	done             bool
	oldValue         func(context.Context) (*Catalog, error)
	predicates       []predicate.Catalog
}

var _ ent.Mutation = (*CatalogMutation)(nil)

// catalogOption allows management of the mutation configuration using functional options.
type catalogOption func(*CatalogMutation)

// newCatalogMutation creates new mutation for the Catalog entity.
func newCatalogMutation(c config, op Op, opts ...catalogOption) *CatalogMutation {
	m := &CatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCatalogID sets the ID field of the mutation.
func withCatalogID(id object.ID) catalogOption {
	return func(m *CatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *Catalog
		)
		m.oldValue = func(ctx context.Context) (*Catalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Catalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCatalog sets the old Catalog of the mutation.
func withCatalog(node *Catalog) catalogOption {
	return func(m *CatalogMutation) {
		m.oldValue = func(context.Context) (*Catalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Catalog entities.
func (m *CatalogMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CatalogMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CatalogMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Catalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CatalogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CatalogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CatalogMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CatalogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CatalogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CatalogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[catalog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CatalogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[catalog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CatalogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, catalog.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *CatalogMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *CatalogMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *CatalogMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[catalog.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *CatalogMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[catalog.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *CatalogMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, catalog.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *CatalogMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *CatalogMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *CatalogMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[catalog.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *CatalogMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[catalog.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *CatalogMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, catalog.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *CatalogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CatalogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CatalogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CatalogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CatalogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CatalogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *CatalogMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CatalogMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *CatalogMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[catalog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CatalogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[catalog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CatalogMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, catalog.FieldStatus)
}

// SetType sets the "type" field.
func (m *CatalogMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CatalogMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CatalogMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *CatalogMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *CatalogMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *CatalogMutation) ResetSource() {
	m.source = nil
}

// SetSync sets the "sync" field.
func (m *CatalogMutation) SetSync(ts *types.CatalogSync) {
	m.sync = &ts
}

// Sync returns the value of the "sync" field in the mutation.
func (m *CatalogMutation) Sync() (r *types.CatalogSync, exists bool) {
	v := m.sync
	if v == nil {
		return
	}
	return *v, true
}

// OldSync returns the old "sync" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldSync(ctx context.Context) (v *types.CatalogSync, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSync: %w", err)
	}
	return oldValue.Sync, nil
}

// ClearSync clears the value of the "sync" field.
func (m *CatalogMutation) ClearSync() {
	m.sync = nil
	m.clearedFields[catalog.FieldSync] = struct{}{}
}

// SyncCleared returns if the "sync" field was cleared in this mutation.
func (m *CatalogMutation) SyncCleared() bool {
	_, ok := m.clearedFields[catalog.FieldSync]
	return ok
}

// ResetSync resets all changes to the "sync" field.
func (m *CatalogMutation) ResetSync() {
	m.sync = nil
	delete(m.clearedFields, catalog.FieldSync)
}

// SetProjectID sets the "project_id" field.
func (m *CatalogMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *CatalogMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *CatalogMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[catalog.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *CatalogMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[catalog.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *CatalogMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, catalog.FieldProjectID)
}

// AddTemplateIDs adds the "templates" edge to the Template entity by ids.
func (m *CatalogMutation) AddTemplateIDs(ids ...object.ID) {
	if m.templates == nil {
		m.templates = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the "templates" edge to the Template entity.
func (m *CatalogMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared reports if the "templates" edge to the Template entity was cleared.
func (m *CatalogMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the "templates" edge to the Template entity by IDs.
func (m *CatalogMutation) RemoveTemplateIDs(ids ...object.ID) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.templates, ids[i])
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed IDs of the "templates" edge to the Template entity.
func (m *CatalogMutation) RemovedTemplatesIDs() (ids []object.ID) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the "templates" edge IDs in the mutation.
func (m *CatalogMutation) TemplatesIDs() (ids []object.ID) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates resets all changes to the "templates" edge.
func (m *CatalogMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *CatalogMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *CatalogMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *CatalogMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *CatalogMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the CatalogMutation builder.
func (m *CatalogMutation) Where(ps ...predicate.Catalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Catalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Catalog).
func (m *CatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CatalogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, catalog.FieldName)
	}
	if m.description != nil {
		fields = append(fields, catalog.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, catalog.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, catalog.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, catalog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, catalog.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, catalog.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, catalog.FieldType)
	}
	if m.source != nil {
		fields = append(fields, catalog.FieldSource)
	}
	if m.sync != nil {
		fields = append(fields, catalog.FieldSync)
	}
	if m.project != nil {
		fields = append(fields, catalog.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case catalog.FieldName:
		return m.Name()
	case catalog.FieldDescription:
		return m.Description()
	case catalog.FieldLabels:
		return m.Labels()
	case catalog.FieldAnnotations:
		return m.Annotations()
	case catalog.FieldCreateTime:
		return m.CreateTime()
	case catalog.FieldUpdateTime:
		return m.UpdateTime()
	case catalog.FieldStatus:
		return m.Status()
	case catalog.FieldType:
		return m.GetType()
	case catalog.FieldSource:
		return m.Source()
	case catalog.FieldSync:
		return m.Sync()
	case catalog.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case catalog.FieldName:
		return m.OldName(ctx)
	case catalog.FieldDescription:
		return m.OldDescription(ctx)
	case catalog.FieldLabels:
		return m.OldLabels(ctx)
	case catalog.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case catalog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case catalog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case catalog.FieldStatus:
		return m.OldStatus(ctx)
	case catalog.FieldType:
		return m.OldType(ctx)
	case catalog.FieldSource:
		return m.OldSource(ctx)
	case catalog.FieldSync:
		return m.OldSync(ctx)
	case catalog.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown Catalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case catalog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case catalog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case catalog.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case catalog.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case catalog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case catalog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case catalog.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case catalog.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case catalog.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case catalog.FieldSync:
		v, ok := value.(*types.CatalogSync)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSync(v)
		return nil
	case catalog.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Catalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CatalogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CatalogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Catalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(catalog.FieldDescription) {
		fields = append(fields, catalog.FieldDescription)
	}
	if m.FieldCleared(catalog.FieldLabels) {
		fields = append(fields, catalog.FieldLabels)
	}
	if m.FieldCleared(catalog.FieldAnnotations) {
		fields = append(fields, catalog.FieldAnnotations)
	}
	if m.FieldCleared(catalog.FieldStatus) {
		fields = append(fields, catalog.FieldStatus)
	}
	if m.FieldCleared(catalog.FieldSync) {
		fields = append(fields, catalog.FieldSync)
	}
	if m.FieldCleared(catalog.FieldProjectID) {
		fields = append(fields, catalog.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CatalogMutation) ClearField(name string) error {
	switch name {
	case catalog.FieldDescription:
		m.ClearDescription()
		return nil
	case catalog.FieldLabels:
		m.ClearLabels()
		return nil
	case catalog.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case catalog.FieldStatus:
		m.ClearStatus()
		return nil
	case catalog.FieldSync:
		m.ClearSync()
		return nil
	case catalog.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown Catalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CatalogMutation) ResetField(name string) error {
	switch name {
	case catalog.FieldName:
		m.ResetName()
		return nil
	case catalog.FieldDescription:
		m.ResetDescription()
		return nil
	case catalog.FieldLabels:
		m.ResetLabels()
		return nil
	case catalog.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case catalog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case catalog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case catalog.FieldStatus:
		m.ResetStatus()
		return nil
	case catalog.FieldType:
		m.ResetType()
		return nil
	case catalog.FieldSource:
		m.ResetSource()
		return nil
	case catalog.FieldSync:
		m.ResetSync()
		return nil
	case catalog.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown Catalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.templates != nil {
		edges = append(edges, catalog.EdgeTemplates)
	}
	if m.project != nil {
		edges = append(edges, catalog.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CatalogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case catalog.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	case catalog.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtemplates != nil {
		edges = append(edges, catalog.EdgeTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CatalogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case catalog.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtemplates {
		edges = append(edges, catalog.EdgeTemplates)
	}
	if m.clearedproject {
		edges = append(edges, catalog.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CatalogMutation) EdgeCleared(name string) bool {
	switch name {
	case catalog.EdgeTemplates:
		return m.clearedtemplates
	case catalog.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CatalogMutation) ClearEdge(name string) error {
	switch name {
	case catalog.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Catalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CatalogMutation) ResetEdge(name string) error {
	switch name {
	case catalog.EdgeTemplates:
		m.ResetTemplates()
		return nil
	case catalog.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Catalog edge %s", name)
}

// ConnectorMutation represents an operation that mutates the Connector nodes in the graph.
type ConnectorMutation struct {
	config
	op                          Op
	typ                         string
	id                          *object.ID
	name                        *string
	description                 *string
	labels                      *map[string]string
	annotations                 *map[string]string
	create_time                 *time.Time
	update_time                 *time.Time
	status                      *status.Status
	category                    *string
	_type                       *string
	applicable_environment_type *string
	config_version              *string
	config_data                 *crypto.Properties
	enable_fin_ops              *bool
	fin_ops_custom_pricing      **types.FinOpsCustomPricing
	clearedFields               map[string]struct{}
	project                     *object.ID
	clearedproject              bool
	environments                map[object.ID]struct{}
	removedenvironments         map[object.ID]struct{}
	clearedenvironments         bool
	resources                   map[object.ID]struct{}
	removedresources            map[object.ID]struct{}
	clearedresources            bool
	cost_reports                map[int]struct{}
	removedcost_reports         map[int]struct{}
	clearedcost_reports         bool
	done                        bool
	oldValue                    func(context.Context) (*Connector, error)
	predicates                  []predicate.Connector
}

var _ ent.Mutation = (*ConnectorMutation)(nil)

// connectorOption allows management of the mutation configuration using functional options.
type connectorOption func(*ConnectorMutation)

// newConnectorMutation creates new mutation for the Connector entity.
func newConnectorMutation(c config, op Op, opts ...connectorOption) *ConnectorMutation {
	m := &ConnectorMutation{
		config:        c,
		op:            op,
		typ:           TypeConnector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectorID sets the ID field of the mutation.
func withConnectorID(id object.ID) connectorOption {
	return func(m *ConnectorMutation) {
		var (
			err   error
			once  sync.Once
			value *Connector
		)
		m.oldValue = func(ctx context.Context) (*Connector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnector sets the old Connector of the mutation.
func withConnector(node *Connector) connectorOption {
	return func(m *ConnectorMutation) {
		m.oldValue = func(context.Context) (*Connector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connector entities.
func (m *ConnectorMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectorMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectorMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConnectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectorMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConnectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConnectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConnectorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[connector.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConnectorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[connector.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConnectorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, connector.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ConnectorMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ConnectorMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ConnectorMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[connector.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ConnectorMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[connector.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ConnectorMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, connector.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ConnectorMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ConnectorMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ConnectorMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[connector.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ConnectorMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[connector.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ConnectorMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, connector.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *ConnectorMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ConnectorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ConnectorMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ConnectorMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ConnectorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ConnectorMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *ConnectorMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConnectorMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ConnectorMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[connector.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ConnectorMutation) StatusCleared() bool {
	_, ok := m.clearedFields[connector.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ConnectorMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, connector.FieldStatus)
}

// SetProjectID sets the "project_id" field.
func (m *ConnectorMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ConnectorMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *ConnectorMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[connector.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *ConnectorMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[connector.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ConnectorMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, connector.FieldProjectID)
}

// SetCategory sets the "category" field.
func (m *ConnectorMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ConnectorMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ConnectorMutation) ResetCategory() {
	m.category = nil
}

// SetType sets the "type" field.
func (m *ConnectorMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConnectorMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ConnectorMutation) ResetType() {
	m._type = nil
}

// SetApplicableEnvironmentType sets the "applicable_environment_type" field.
func (m *ConnectorMutation) SetApplicableEnvironmentType(s string) {
	m.applicable_environment_type = &s
}

// ApplicableEnvironmentType returns the value of the "applicable_environment_type" field in the mutation.
func (m *ConnectorMutation) ApplicableEnvironmentType() (r string, exists bool) {
	v := m.applicable_environment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicableEnvironmentType returns the old "applicable_environment_type" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldApplicableEnvironmentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicableEnvironmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicableEnvironmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicableEnvironmentType: %w", err)
	}
	return oldValue.ApplicableEnvironmentType, nil
}

// ResetApplicableEnvironmentType resets all changes to the "applicable_environment_type" field.
func (m *ConnectorMutation) ResetApplicableEnvironmentType() {
	m.applicable_environment_type = nil
}

// SetConfigVersion sets the "config_version" field.
func (m *ConnectorMutation) SetConfigVersion(s string) {
	m.config_version = &s
}

// ConfigVersion returns the value of the "config_version" field in the mutation.
func (m *ConnectorMutation) ConfigVersion() (r string, exists bool) {
	v := m.config_version
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigVersion returns the old "config_version" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldConfigVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigVersion: %w", err)
	}
	return oldValue.ConfigVersion, nil
}

// ResetConfigVersion resets all changes to the "config_version" field.
func (m *ConnectorMutation) ResetConfigVersion() {
	m.config_version = nil
}

// SetConfigData sets the "config_data" field.
func (m *ConnectorMutation) SetConfigData(c crypto.Properties) {
	m.config_data = &c
}

// ConfigData returns the value of the "config_data" field in the mutation.
func (m *ConnectorMutation) ConfigData() (r crypto.Properties, exists bool) {
	v := m.config_data
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigData returns the old "config_data" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldConfigData(ctx context.Context) (v crypto.Properties, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigData: %w", err)
	}
	return oldValue.ConfigData, nil
}

// ClearConfigData clears the value of the "config_data" field.
func (m *ConnectorMutation) ClearConfigData() {
	m.config_data = nil
	m.clearedFields[connector.FieldConfigData] = struct{}{}
}

// ConfigDataCleared returns if the "config_data" field was cleared in this mutation.
func (m *ConnectorMutation) ConfigDataCleared() bool {
	_, ok := m.clearedFields[connector.FieldConfigData]
	return ok
}

// ResetConfigData resets all changes to the "config_data" field.
func (m *ConnectorMutation) ResetConfigData() {
	m.config_data = nil
	delete(m.clearedFields, connector.FieldConfigData)
}

// SetEnableFinOps sets the "enable_fin_ops" field.
func (m *ConnectorMutation) SetEnableFinOps(b bool) {
	m.enable_fin_ops = &b
}

// EnableFinOps returns the value of the "enable_fin_ops" field in the mutation.
func (m *ConnectorMutation) EnableFinOps() (r bool, exists bool) {
	v := m.enable_fin_ops
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableFinOps returns the old "enable_fin_ops" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldEnableFinOps(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableFinOps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableFinOps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableFinOps: %w", err)
	}
	return oldValue.EnableFinOps, nil
}

// ResetEnableFinOps resets all changes to the "enable_fin_ops" field.
func (m *ConnectorMutation) ResetEnableFinOps() {
	m.enable_fin_ops = nil
}

// SetFinOpsCustomPricing sets the "fin_ops_custom_pricing" field.
func (m *ConnectorMutation) SetFinOpsCustomPricing(tocp *types.FinOpsCustomPricing) {
	m.fin_ops_custom_pricing = &tocp
}

// FinOpsCustomPricing returns the value of the "fin_ops_custom_pricing" field in the mutation.
func (m *ConnectorMutation) FinOpsCustomPricing() (r *types.FinOpsCustomPricing, exists bool) {
	v := m.fin_ops_custom_pricing
	if v == nil {
		return
	}
	return *v, true
}

// OldFinOpsCustomPricing returns the old "fin_ops_custom_pricing" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldFinOpsCustomPricing(ctx context.Context) (v *types.FinOpsCustomPricing, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinOpsCustomPricing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinOpsCustomPricing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinOpsCustomPricing: %w", err)
	}
	return oldValue.FinOpsCustomPricing, nil
}

// ClearFinOpsCustomPricing clears the value of the "fin_ops_custom_pricing" field.
func (m *ConnectorMutation) ClearFinOpsCustomPricing() {
	m.fin_ops_custom_pricing = nil
	m.clearedFields[connector.FieldFinOpsCustomPricing] = struct{}{}
}

// FinOpsCustomPricingCleared returns if the "fin_ops_custom_pricing" field was cleared in this mutation.
func (m *ConnectorMutation) FinOpsCustomPricingCleared() bool {
	_, ok := m.clearedFields[connector.FieldFinOpsCustomPricing]
	return ok
}

// ResetFinOpsCustomPricing resets all changes to the "fin_ops_custom_pricing" field.
func (m *ConnectorMutation) ResetFinOpsCustomPricing() {
	m.fin_ops_custom_pricing = nil
	delete(m.clearedFields, connector.FieldFinOpsCustomPricing)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ConnectorMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ConnectorMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ConnectorMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ConnectorMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddEnvironmentIDs adds the "environments" edge to the EnvironmentConnectorRelationship entity by ids.
func (m *ConnectorMutation) AddEnvironmentIDs(ids ...object.ID) {
	if m.environments == nil {
		m.environments = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "environments" edge to the EnvironmentConnectorRelationship entity.
func (m *ConnectorMutation) ClearEnvironments() {
	m.clearedenvironments = true
}

// EnvironmentsCleared reports if the "environments" edge to the EnvironmentConnectorRelationship entity was cleared.
func (m *ConnectorMutation) EnvironmentsCleared() bool {
	return m.clearedenvironments
}

// RemoveEnvironmentIDs removes the "environments" edge to the EnvironmentConnectorRelationship entity by IDs.
func (m *ConnectorMutation) RemoveEnvironmentIDs(ids ...object.ID) {
	if m.removedenvironments == nil {
		m.removedenvironments = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.environments, ids[i])
		m.removedenvironments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "environments" edge to the EnvironmentConnectorRelationship entity.
func (m *ConnectorMutation) RemovedEnvironmentsIDs() (ids []object.ID) {
	for id := range m.removedenvironments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "environments" edge IDs in the mutation.
func (m *ConnectorMutation) EnvironmentsIDs() (ids []object.ID) {
	for id := range m.environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "environments" edge.
func (m *ConnectorMutation) ResetEnvironments() {
	m.environments = nil
	m.clearedenvironments = false
	m.removedenvironments = nil
}

// AddResourceIDs adds the "resources" edge to the ServiceResource entity by ids.
func (m *ConnectorMutation) AddResourceIDs(ids ...object.ID) {
	if m.resources == nil {
		m.resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the ServiceResource entity.
func (m *ConnectorMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the ServiceResource entity was cleared.
func (m *ConnectorMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the ServiceResource entity by IDs.
func (m *ConnectorMutation) RemoveResourceIDs(ids ...object.ID) {
	if m.removedresources == nil {
		m.removedresources = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the ServiceResource entity.
func (m *ConnectorMutation) RemovedResourcesIDs() (ids []object.ID) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *ConnectorMutation) ResourcesIDs() (ids []object.ID) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *ConnectorMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddCostReportIDs adds the "cost_reports" edge to the CostReport entity by ids.
func (m *ConnectorMutation) AddCostReportIDs(ids ...int) {
	if m.cost_reports == nil {
		m.cost_reports = make(map[int]struct{})
	}
	for i := range ids {
		m.cost_reports[ids[i]] = struct{}{}
	}
}

// ClearCostReports clears the "cost_reports" edge to the CostReport entity.
func (m *ConnectorMutation) ClearCostReports() {
	m.clearedcost_reports = true
}

// CostReportsCleared reports if the "cost_reports" edge to the CostReport entity was cleared.
func (m *ConnectorMutation) CostReportsCleared() bool {
	return m.clearedcost_reports
}

// RemoveCostReportIDs removes the "cost_reports" edge to the CostReport entity by IDs.
func (m *ConnectorMutation) RemoveCostReportIDs(ids ...int) {
	if m.removedcost_reports == nil {
		m.removedcost_reports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cost_reports, ids[i])
		m.removedcost_reports[ids[i]] = struct{}{}
	}
}

// RemovedCostReports returns the removed IDs of the "cost_reports" edge to the CostReport entity.
func (m *ConnectorMutation) RemovedCostReportsIDs() (ids []int) {
	for id := range m.removedcost_reports {
		ids = append(ids, id)
	}
	return
}

// CostReportsIDs returns the "cost_reports" edge IDs in the mutation.
func (m *ConnectorMutation) CostReportsIDs() (ids []int) {
	for id := range m.cost_reports {
		ids = append(ids, id)
	}
	return
}

// ResetCostReports resets all changes to the "cost_reports" edge.
func (m *ConnectorMutation) ResetCostReports() {
	m.cost_reports = nil
	m.clearedcost_reports = false
	m.removedcost_reports = nil
}

// Where appends a list predicates to the ConnectorMutation builder.
func (m *ConnectorMutation) Where(ps ...predicate.Connector) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Connector, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Connector).
func (m *ConnectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectorMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.name != nil {
		fields = append(fields, connector.FieldName)
	}
	if m.description != nil {
		fields = append(fields, connector.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, connector.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, connector.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, connector.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, connector.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, connector.FieldStatus)
	}
	if m.project != nil {
		fields = append(fields, connector.FieldProjectID)
	}
	if m.category != nil {
		fields = append(fields, connector.FieldCategory)
	}
	if m._type != nil {
		fields = append(fields, connector.FieldType)
	}
	if m.applicable_environment_type != nil {
		fields = append(fields, connector.FieldApplicableEnvironmentType)
	}
	if m.config_version != nil {
		fields = append(fields, connector.FieldConfigVersion)
	}
	if m.config_data != nil {
		fields = append(fields, connector.FieldConfigData)
	}
	if m.enable_fin_ops != nil {
		fields = append(fields, connector.FieldEnableFinOps)
	}
	if m.fin_ops_custom_pricing != nil {
		fields = append(fields, connector.FieldFinOpsCustomPricing)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connector.FieldName:
		return m.Name()
	case connector.FieldDescription:
		return m.Description()
	case connector.FieldLabels:
		return m.Labels()
	case connector.FieldAnnotations:
		return m.Annotations()
	case connector.FieldCreateTime:
		return m.CreateTime()
	case connector.FieldUpdateTime:
		return m.UpdateTime()
	case connector.FieldStatus:
		return m.Status()
	case connector.FieldProjectID:
		return m.ProjectID()
	case connector.FieldCategory:
		return m.Category()
	case connector.FieldType:
		return m.GetType()
	case connector.FieldApplicableEnvironmentType:
		return m.ApplicableEnvironmentType()
	case connector.FieldConfigVersion:
		return m.ConfigVersion()
	case connector.FieldConfigData:
		return m.ConfigData()
	case connector.FieldEnableFinOps:
		return m.EnableFinOps()
	case connector.FieldFinOpsCustomPricing:
		return m.FinOpsCustomPricing()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connector.FieldName:
		return m.OldName(ctx)
	case connector.FieldDescription:
		return m.OldDescription(ctx)
	case connector.FieldLabels:
		return m.OldLabels(ctx)
	case connector.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case connector.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case connector.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case connector.FieldStatus:
		return m.OldStatus(ctx)
	case connector.FieldProjectID:
		return m.OldProjectID(ctx)
	case connector.FieldCategory:
		return m.OldCategory(ctx)
	case connector.FieldType:
		return m.OldType(ctx)
	case connector.FieldApplicableEnvironmentType:
		return m.OldApplicableEnvironmentType(ctx)
	case connector.FieldConfigVersion:
		return m.OldConfigVersion(ctx)
	case connector.FieldConfigData:
		return m.OldConfigData(ctx)
	case connector.FieldEnableFinOps:
		return m.OldEnableFinOps(ctx)
	case connector.FieldFinOpsCustomPricing:
		return m.OldFinOpsCustomPricing(ctx)
	}
	return nil, fmt.Errorf("unknown Connector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case connector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case connector.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case connector.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case connector.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case connector.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case connector.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case connector.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case connector.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case connector.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case connector.FieldApplicableEnvironmentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicableEnvironmentType(v)
		return nil
	case connector.FieldConfigVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigVersion(v)
		return nil
	case connector.FieldConfigData:
		v, ok := value.(crypto.Properties)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigData(v)
		return nil
	case connector.FieldEnableFinOps:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableFinOps(v)
		return nil
	case connector.FieldFinOpsCustomPricing:
		v, ok := value.(*types.FinOpsCustomPricing)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinOpsCustomPricing(v)
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Connector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connector.FieldDescription) {
		fields = append(fields, connector.FieldDescription)
	}
	if m.FieldCleared(connector.FieldLabels) {
		fields = append(fields, connector.FieldLabels)
	}
	if m.FieldCleared(connector.FieldAnnotations) {
		fields = append(fields, connector.FieldAnnotations)
	}
	if m.FieldCleared(connector.FieldStatus) {
		fields = append(fields, connector.FieldStatus)
	}
	if m.FieldCleared(connector.FieldProjectID) {
		fields = append(fields, connector.FieldProjectID)
	}
	if m.FieldCleared(connector.FieldConfigData) {
		fields = append(fields, connector.FieldConfigData)
	}
	if m.FieldCleared(connector.FieldFinOpsCustomPricing) {
		fields = append(fields, connector.FieldFinOpsCustomPricing)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectorMutation) ClearField(name string) error {
	switch name {
	case connector.FieldDescription:
		m.ClearDescription()
		return nil
	case connector.FieldLabels:
		m.ClearLabels()
		return nil
	case connector.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case connector.FieldStatus:
		m.ClearStatus()
		return nil
	case connector.FieldProjectID:
		m.ClearProjectID()
		return nil
	case connector.FieldConfigData:
		m.ClearConfigData()
		return nil
	case connector.FieldFinOpsCustomPricing:
		m.ClearFinOpsCustomPricing()
		return nil
	}
	return fmt.Errorf("unknown Connector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectorMutation) ResetField(name string) error {
	switch name {
	case connector.FieldName:
		m.ResetName()
		return nil
	case connector.FieldDescription:
		m.ResetDescription()
		return nil
	case connector.FieldLabels:
		m.ResetLabels()
		return nil
	case connector.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case connector.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case connector.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case connector.FieldStatus:
		m.ResetStatus()
		return nil
	case connector.FieldProjectID:
		m.ResetProjectID()
		return nil
	case connector.FieldCategory:
		m.ResetCategory()
		return nil
	case connector.FieldType:
		m.ResetType()
		return nil
	case connector.FieldApplicableEnvironmentType:
		m.ResetApplicableEnvironmentType()
		return nil
	case connector.FieldConfigVersion:
		m.ResetConfigVersion()
		return nil
	case connector.FieldConfigData:
		m.ResetConfigData()
		return nil
	case connector.FieldEnableFinOps:
		m.ResetEnableFinOps()
		return nil
	case connector.FieldFinOpsCustomPricing:
		m.ResetFinOpsCustomPricing()
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.project != nil {
		edges = append(edges, connector.EdgeProject)
	}
	if m.environments != nil {
		edges = append(edges, connector.EdgeEnvironments)
	}
	if m.resources != nil {
		edges = append(edges, connector.EdgeResources)
	}
	if m.cost_reports != nil {
		edges = append(edges, connector.EdgeCostReports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connector.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case connector.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.environments))
		for id := range m.environments {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeCostReports:
		ids := make([]ent.Value, 0, len(m.cost_reports))
		for id := range m.cost_reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedenvironments != nil {
		edges = append(edges, connector.EdgeEnvironments)
	}
	if m.removedresources != nil {
		edges = append(edges, connector.EdgeResources)
	}
	if m.removedcost_reports != nil {
		edges = append(edges, connector.EdgeCostReports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connector.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removedenvironments))
		for id := range m.removedenvironments {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeCostReports:
		ids := make([]ent.Value, 0, len(m.removedcost_reports))
		for id := range m.removedcost_reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproject {
		edges = append(edges, connector.EdgeProject)
	}
	if m.clearedenvironments {
		edges = append(edges, connector.EdgeEnvironments)
	}
	if m.clearedresources {
		edges = append(edges, connector.EdgeResources)
	}
	if m.clearedcost_reports {
		edges = append(edges, connector.EdgeCostReports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectorMutation) EdgeCleared(name string) bool {
	switch name {
	case connector.EdgeProject:
		return m.clearedproject
	case connector.EdgeEnvironments:
		return m.clearedenvironments
	case connector.EdgeResources:
		return m.clearedresources
	case connector.EdgeCostReports:
		return m.clearedcost_reports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectorMutation) ClearEdge(name string) error {
	switch name {
	case connector.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Connector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectorMutation) ResetEdge(name string) error {
	switch name {
	case connector.EdgeProject:
		m.ResetProject()
		return nil
	case connector.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case connector.EdgeResources:
		m.ResetResources()
		return nil
	case connector.EdgeCostReports:
		m.ResetCostReports()
		return nil
	}
	return fmt.Errorf("unknown Connector edge %s", name)
}

// CostReportMutation represents an operation that mutates the CostReport nodes in the graph.
type CostReportMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	start_time                *time.Time
	end_time                  *time.Time
	minutes                   *float64
	addminutes                *float64
	name                      *string
	fingerprint               *string
	cluster_name              *string
	namespace                 *string
	node                      *string
	controller                *string
	controller_kind           *string
	pod                       *string
	container                 *string
	pvs                       *map[string]types.PVCost
	labels                    *map[string]string
	totalCost                 *float64
	addtotalCost              *float64
	currency                  *int
	addcurrency               *int
	cpu_cost                  *float64
	addcpu_cost               *float64
	cpu_core_request          *float64
	addcpu_core_request       *float64
	gpu_cost                  *float64
	addgpu_cost               *float64
	gpu_count                 *float64
	addgpu_count              *float64
	ram_cost                  *float64
	addram_cost               *float64
	ram_byte_request          *float64
	addram_byte_request       *float64
	pv_cost                   *float64
	addpv_cost                *float64
	pv_bytes                  *float64
	addpv_bytes               *float64
	load_balancer_cost        *float64
	addload_balancer_cost     *float64
	cpu_core_usage_average    *float64
	addcpu_core_usage_average *float64
	cpu_core_usage_max        *float64
	addcpu_core_usage_max     *float64
	ram_byte_usage_average    *float64
	addram_byte_usage_average *float64
	ram_byte_usage_max        *float64
	addram_byte_usage_max     *float64
	clearedFields             map[string]struct{}
	connector                 *object.ID
	clearedconnector          bool
	done                      bool
	oldValue                  func(context.Context) (*CostReport, error)
	predicates                []predicate.CostReport
}

var _ ent.Mutation = (*CostReportMutation)(nil)

// costReportOption allows management of the mutation configuration using functional options.
type costReportOption func(*CostReportMutation)

// newCostReportMutation creates new mutation for the CostReport entity.
func newCostReportMutation(c config, op Op, opts ...costReportOption) *CostReportMutation {
	m := &CostReportMutation{
		config:        c,
		op:            op,
		typ:           TypeCostReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostReportID sets the ID field of the mutation.
func withCostReportID(id int) costReportOption {
	return func(m *CostReportMutation) {
		var (
			err   error
			once  sync.Once
			value *CostReport
		)
		m.oldValue = func(ctx context.Context) (*CostReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostReport sets the old CostReport of the mutation.
func withCostReport(node *CostReport) costReportOption {
	return func(m *CostReportMutation) {
		m.oldValue = func(context.Context) (*CostReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CostReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartTime sets the "start_time" field.
func (m *CostReportMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CostReportMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CostReportMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *CostReportMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CostReportMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CostReportMutation) ResetEndTime() {
	m.end_time = nil
}

// SetMinutes sets the "minutes" field.
func (m *CostReportMutation) SetMinutes(f float64) {
	m.minutes = &f
	m.addminutes = nil
}

// Minutes returns the value of the "minutes" field in the mutation.
func (m *CostReportMutation) Minutes() (r float64, exists bool) {
	v := m.minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldMinutes returns the old "minutes" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldMinutes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinutes: %w", err)
	}
	return oldValue.Minutes, nil
}

// AddMinutes adds f to the "minutes" field.
func (m *CostReportMutation) AddMinutes(f float64) {
	if m.addminutes != nil {
		*m.addminutes += f
	} else {
		m.addminutes = &f
	}
}

// AddedMinutes returns the value that was added to the "minutes" field in this mutation.
func (m *CostReportMutation) AddedMinutes() (r float64, exists bool) {
	v := m.addminutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinutes resets all changes to the "minutes" field.
func (m *CostReportMutation) ResetMinutes() {
	m.minutes = nil
	m.addminutes = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *CostReportMutation) SetConnectorID(o object.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *CostReportMutation) ConnectorID() (r object.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldConnectorID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *CostReportMutation) ResetConnectorID() {
	m.connector = nil
}

// SetName sets the "name" field.
func (m *CostReportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CostReportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CostReportMutation) ResetName() {
	m.name = nil
}

// SetFingerprint sets the "fingerprint" field.
func (m *CostReportMutation) SetFingerprint(s string) {
	m.fingerprint = &s
}

// Fingerprint returns the value of the "fingerprint" field in the mutation.
func (m *CostReportMutation) Fingerprint() (r string, exists bool) {
	v := m.fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprint returns the old "fingerprint" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprint: %w", err)
	}
	return oldValue.Fingerprint, nil
}

// ResetFingerprint resets all changes to the "fingerprint" field.
func (m *CostReportMutation) ResetFingerprint() {
	m.fingerprint = nil
}

// SetClusterName sets the "cluster_name" field.
func (m *CostReportMutation) SetClusterName(s string) {
	m.cluster_name = &s
}

// ClusterName returns the value of the "cluster_name" field in the mutation.
func (m *CostReportMutation) ClusterName() (r string, exists bool) {
	v := m.cluster_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterName returns the old "cluster_name" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldClusterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClusterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClusterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterName: %w", err)
	}
	return oldValue.ClusterName, nil
}

// ClearClusterName clears the value of the "cluster_name" field.
func (m *CostReportMutation) ClearClusterName() {
	m.cluster_name = nil
	m.clearedFields[costreport.FieldClusterName] = struct{}{}
}

// ClusterNameCleared returns if the "cluster_name" field was cleared in this mutation.
func (m *CostReportMutation) ClusterNameCleared() bool {
	_, ok := m.clearedFields[costreport.FieldClusterName]
	return ok
}

// ResetClusterName resets all changes to the "cluster_name" field.
func (m *CostReportMutation) ResetClusterName() {
	m.cluster_name = nil
	delete(m.clearedFields, costreport.FieldClusterName)
}

// SetNamespace sets the "namespace" field.
func (m *CostReportMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *CostReportMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ClearNamespace clears the value of the "namespace" field.
func (m *CostReportMutation) ClearNamespace() {
	m.namespace = nil
	m.clearedFields[costreport.FieldNamespace] = struct{}{}
}

// NamespaceCleared returns if the "namespace" field was cleared in this mutation.
func (m *CostReportMutation) NamespaceCleared() bool {
	_, ok := m.clearedFields[costreport.FieldNamespace]
	return ok
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *CostReportMutation) ResetNamespace() {
	m.namespace = nil
	delete(m.clearedFields, costreport.FieldNamespace)
}

// SetNode sets the "node" field.
func (m *CostReportMutation) SetNode(s string) {
	m.node = &s
}

// Node returns the value of the "node" field in the mutation.
func (m *CostReportMutation) Node() (r string, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNode returns the old "node" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldNode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNode: %w", err)
	}
	return oldValue.Node, nil
}

// ClearNode clears the value of the "node" field.
func (m *CostReportMutation) ClearNode() {
	m.node = nil
	m.clearedFields[costreport.FieldNode] = struct{}{}
}

// NodeCleared returns if the "node" field was cleared in this mutation.
func (m *CostReportMutation) NodeCleared() bool {
	_, ok := m.clearedFields[costreport.FieldNode]
	return ok
}

// ResetNode resets all changes to the "node" field.
func (m *CostReportMutation) ResetNode() {
	m.node = nil
	delete(m.clearedFields, costreport.FieldNode)
}

// SetController sets the "controller" field.
func (m *CostReportMutation) SetController(s string) {
	m.controller = &s
}

// Controller returns the value of the "controller" field in the mutation.
func (m *CostReportMutation) Controller() (r string, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldController returns the old "controller" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldController(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldController: %w", err)
	}
	return oldValue.Controller, nil
}

// ClearController clears the value of the "controller" field.
func (m *CostReportMutation) ClearController() {
	m.controller = nil
	m.clearedFields[costreport.FieldController] = struct{}{}
}

// ControllerCleared returns if the "controller" field was cleared in this mutation.
func (m *CostReportMutation) ControllerCleared() bool {
	_, ok := m.clearedFields[costreport.FieldController]
	return ok
}

// ResetController resets all changes to the "controller" field.
func (m *CostReportMutation) ResetController() {
	m.controller = nil
	delete(m.clearedFields, costreport.FieldController)
}

// SetControllerKind sets the "controller_kind" field.
func (m *CostReportMutation) SetControllerKind(s string) {
	m.controller_kind = &s
}

// ControllerKind returns the value of the "controller_kind" field in the mutation.
func (m *CostReportMutation) ControllerKind() (r string, exists bool) {
	v := m.controller_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldControllerKind returns the old "controller_kind" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldControllerKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControllerKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControllerKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControllerKind: %w", err)
	}
	return oldValue.ControllerKind, nil
}

// ClearControllerKind clears the value of the "controller_kind" field.
func (m *CostReportMutation) ClearControllerKind() {
	m.controller_kind = nil
	m.clearedFields[costreport.FieldControllerKind] = struct{}{}
}

// ControllerKindCleared returns if the "controller_kind" field was cleared in this mutation.
func (m *CostReportMutation) ControllerKindCleared() bool {
	_, ok := m.clearedFields[costreport.FieldControllerKind]
	return ok
}

// ResetControllerKind resets all changes to the "controller_kind" field.
func (m *CostReportMutation) ResetControllerKind() {
	m.controller_kind = nil
	delete(m.clearedFields, costreport.FieldControllerKind)
}

// SetPod sets the "pod" field.
func (m *CostReportMutation) SetPod(s string) {
	m.pod = &s
}

// Pod returns the value of the "pod" field in the mutation.
func (m *CostReportMutation) Pod() (r string, exists bool) {
	v := m.pod
	if v == nil {
		return
	}
	return *v, true
}

// OldPod returns the old "pod" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldPod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPod: %w", err)
	}
	return oldValue.Pod, nil
}

// ClearPod clears the value of the "pod" field.
func (m *CostReportMutation) ClearPod() {
	m.pod = nil
	m.clearedFields[costreport.FieldPod] = struct{}{}
}

// PodCleared returns if the "pod" field was cleared in this mutation.
func (m *CostReportMutation) PodCleared() bool {
	_, ok := m.clearedFields[costreport.FieldPod]
	return ok
}

// ResetPod resets all changes to the "pod" field.
func (m *CostReportMutation) ResetPod() {
	m.pod = nil
	delete(m.clearedFields, costreport.FieldPod)
}

// SetContainer sets the "container" field.
func (m *CostReportMutation) SetContainer(s string) {
	m.container = &s
}

// Container returns the value of the "container" field in the mutation.
func (m *CostReportMutation) Container() (r string, exists bool) {
	v := m.container
	if v == nil {
		return
	}
	return *v, true
}

// OldContainer returns the old "container" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldContainer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainer: %w", err)
	}
	return oldValue.Container, nil
}

// ClearContainer clears the value of the "container" field.
func (m *CostReportMutation) ClearContainer() {
	m.container = nil
	m.clearedFields[costreport.FieldContainer] = struct{}{}
}

// ContainerCleared returns if the "container" field was cleared in this mutation.
func (m *CostReportMutation) ContainerCleared() bool {
	_, ok := m.clearedFields[costreport.FieldContainer]
	return ok
}

// ResetContainer resets all changes to the "container" field.
func (m *CostReportMutation) ResetContainer() {
	m.container = nil
	delete(m.clearedFields, costreport.FieldContainer)
}

// SetPvs sets the "pvs" field.
func (m *CostReportMutation) SetPvs(mc map[string]types.PVCost) {
	m.pvs = &mc
}

// Pvs returns the value of the "pvs" field in the mutation.
func (m *CostReportMutation) Pvs() (r map[string]types.PVCost, exists bool) {
	v := m.pvs
	if v == nil {
		return
	}
	return *v, true
}

// OldPvs returns the old "pvs" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldPvs(ctx context.Context) (v map[string]types.PVCost, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPvs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPvs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPvs: %w", err)
	}
	return oldValue.Pvs, nil
}

// ResetPvs resets all changes to the "pvs" field.
func (m *CostReportMutation) ResetPvs() {
	m.pvs = nil
}

// SetLabels sets the "labels" field.
func (m *CostReportMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *CostReportMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ResetLabels resets all changes to the "labels" field.
func (m *CostReportMutation) ResetLabels() {
	m.labels = nil
}

// SetTotalCost sets the "totalCost" field.
func (m *CostReportMutation) SetTotalCost(f float64) {
	m.totalCost = &f
	m.addtotalCost = nil
}

// TotalCost returns the value of the "totalCost" field in the mutation.
func (m *CostReportMutation) TotalCost() (r float64, exists bool) {
	v := m.totalCost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "totalCost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldTotalCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "totalCost" field.
func (m *CostReportMutation) AddTotalCost(f float64) {
	if m.addtotalCost != nil {
		*m.addtotalCost += f
	} else {
		m.addtotalCost = &f
	}
}

// AddedTotalCost returns the value that was added to the "totalCost" field in this mutation.
func (m *CostReportMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotalCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCost resets all changes to the "totalCost" field.
func (m *CostReportMutation) ResetTotalCost() {
	m.totalCost = nil
	m.addtotalCost = nil
}

// SetCurrency sets the "currency" field.
func (m *CostReportMutation) SetCurrency(i int) {
	m.currency = &i
	m.addcurrency = nil
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CostReportMutation) Currency() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// AddCurrency adds i to the "currency" field.
func (m *CostReportMutation) AddCurrency(i int) {
	if m.addcurrency != nil {
		*m.addcurrency += i
	} else {
		m.addcurrency = &i
	}
}

// AddedCurrency returns the value that was added to the "currency" field in this mutation.
func (m *CostReportMutation) AddedCurrency() (r int, exists bool) {
	v := m.addcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrency clears the value of the "currency" field.
func (m *CostReportMutation) ClearCurrency() {
	m.currency = nil
	m.addcurrency = nil
	m.clearedFields[costreport.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *CostReportMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[costreport.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CostReportMutation) ResetCurrency() {
	m.currency = nil
	m.addcurrency = nil
	delete(m.clearedFields, costreport.FieldCurrency)
}

// SetCPUCost sets the "cpu_cost" field.
func (m *CostReportMutation) SetCPUCost(f float64) {
	m.cpu_cost = &f
	m.addcpu_cost = nil
}

// CPUCost returns the value of the "cpu_cost" field in the mutation.
func (m *CostReportMutation) CPUCost() (r float64, exists bool) {
	v := m.cpu_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCost returns the old "cpu_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCPUCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCost: %w", err)
	}
	return oldValue.CPUCost, nil
}

// AddCPUCost adds f to the "cpu_cost" field.
func (m *CostReportMutation) AddCPUCost(f float64) {
	if m.addcpu_cost != nil {
		*m.addcpu_cost += f
	} else {
		m.addcpu_cost = &f
	}
}

// AddedCPUCost returns the value that was added to the "cpu_cost" field in this mutation.
func (m *CostReportMutation) AddedCPUCost() (r float64, exists bool) {
	v := m.addcpu_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCost resets all changes to the "cpu_cost" field.
func (m *CostReportMutation) ResetCPUCost() {
	m.cpu_cost = nil
	m.addcpu_cost = nil
}

// SetCPUCoreRequest sets the "cpu_core_request" field.
func (m *CostReportMutation) SetCPUCoreRequest(f float64) {
	m.cpu_core_request = &f
	m.addcpu_core_request = nil
}

// CPUCoreRequest returns the value of the "cpu_core_request" field in the mutation.
func (m *CostReportMutation) CPUCoreRequest() (r float64, exists bool) {
	v := m.cpu_core_request
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCoreRequest returns the old "cpu_core_request" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCPUCoreRequest(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCoreRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCoreRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCoreRequest: %w", err)
	}
	return oldValue.CPUCoreRequest, nil
}

// AddCPUCoreRequest adds f to the "cpu_core_request" field.
func (m *CostReportMutation) AddCPUCoreRequest(f float64) {
	if m.addcpu_core_request != nil {
		*m.addcpu_core_request += f
	} else {
		m.addcpu_core_request = &f
	}
}

// AddedCPUCoreRequest returns the value that was added to the "cpu_core_request" field in this mutation.
func (m *CostReportMutation) AddedCPUCoreRequest() (r float64, exists bool) {
	v := m.addcpu_core_request
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCoreRequest resets all changes to the "cpu_core_request" field.
func (m *CostReportMutation) ResetCPUCoreRequest() {
	m.cpu_core_request = nil
	m.addcpu_core_request = nil
}

// SetGPUCost sets the "gpu_cost" field.
func (m *CostReportMutation) SetGPUCost(f float64) {
	m.gpu_cost = &f
	m.addgpu_cost = nil
}

// GPUCost returns the value of the "gpu_cost" field in the mutation.
func (m *CostReportMutation) GPUCost() (r float64, exists bool) {
	v := m.gpu_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldGPUCost returns the old "gpu_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldGPUCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGPUCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGPUCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGPUCost: %w", err)
	}
	return oldValue.GPUCost, nil
}

// AddGPUCost adds f to the "gpu_cost" field.
func (m *CostReportMutation) AddGPUCost(f float64) {
	if m.addgpu_cost != nil {
		*m.addgpu_cost += f
	} else {
		m.addgpu_cost = &f
	}
}

// AddedGPUCost returns the value that was added to the "gpu_cost" field in this mutation.
func (m *CostReportMutation) AddedGPUCost() (r float64, exists bool) {
	v := m.addgpu_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetGPUCost resets all changes to the "gpu_cost" field.
func (m *CostReportMutation) ResetGPUCost() {
	m.gpu_cost = nil
	m.addgpu_cost = nil
}

// SetGPUCount sets the "gpu_count" field.
func (m *CostReportMutation) SetGPUCount(f float64) {
	m.gpu_count = &f
	m.addgpu_count = nil
}

// GPUCount returns the value of the "gpu_count" field in the mutation.
func (m *CostReportMutation) GPUCount() (r float64, exists bool) {
	v := m.gpu_count
	if v == nil {
		return
	}
	return *v, true
}

// OldGPUCount returns the old "gpu_count" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldGPUCount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGPUCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGPUCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGPUCount: %w", err)
	}
	return oldValue.GPUCount, nil
}

// AddGPUCount adds f to the "gpu_count" field.
func (m *CostReportMutation) AddGPUCount(f float64) {
	if m.addgpu_count != nil {
		*m.addgpu_count += f
	} else {
		m.addgpu_count = &f
	}
}

// AddedGPUCount returns the value that was added to the "gpu_count" field in this mutation.
func (m *CostReportMutation) AddedGPUCount() (r float64, exists bool) {
	v := m.addgpu_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetGPUCount resets all changes to the "gpu_count" field.
func (m *CostReportMutation) ResetGPUCount() {
	m.gpu_count = nil
	m.addgpu_count = nil
}

// SetRAMCost sets the "ram_cost" field.
func (m *CostReportMutation) SetRAMCost(f float64) {
	m.ram_cost = &f
	m.addram_cost = nil
}

// RAMCost returns the value of the "ram_cost" field in the mutation.
func (m *CostReportMutation) RAMCost() (r float64, exists bool) {
	v := m.ram_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMCost returns the old "ram_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldRAMCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMCost: %w", err)
	}
	return oldValue.RAMCost, nil
}

// AddRAMCost adds f to the "ram_cost" field.
func (m *CostReportMutation) AddRAMCost(f float64) {
	if m.addram_cost != nil {
		*m.addram_cost += f
	} else {
		m.addram_cost = &f
	}
}

// AddedRAMCost returns the value that was added to the "ram_cost" field in this mutation.
func (m *CostReportMutation) AddedRAMCost() (r float64, exists bool) {
	v := m.addram_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMCost resets all changes to the "ram_cost" field.
func (m *CostReportMutation) ResetRAMCost() {
	m.ram_cost = nil
	m.addram_cost = nil
}

// SetRAMByteRequest sets the "ram_byte_request" field.
func (m *CostReportMutation) SetRAMByteRequest(f float64) {
	m.ram_byte_request = &f
	m.addram_byte_request = nil
}

// RAMByteRequest returns the value of the "ram_byte_request" field in the mutation.
func (m *CostReportMutation) RAMByteRequest() (r float64, exists bool) {
	v := m.ram_byte_request
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMByteRequest returns the old "ram_byte_request" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldRAMByteRequest(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMByteRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMByteRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMByteRequest: %w", err)
	}
	return oldValue.RAMByteRequest, nil
}

// AddRAMByteRequest adds f to the "ram_byte_request" field.
func (m *CostReportMutation) AddRAMByteRequest(f float64) {
	if m.addram_byte_request != nil {
		*m.addram_byte_request += f
	} else {
		m.addram_byte_request = &f
	}
}

// AddedRAMByteRequest returns the value that was added to the "ram_byte_request" field in this mutation.
func (m *CostReportMutation) AddedRAMByteRequest() (r float64, exists bool) {
	v := m.addram_byte_request
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMByteRequest resets all changes to the "ram_byte_request" field.
func (m *CostReportMutation) ResetRAMByteRequest() {
	m.ram_byte_request = nil
	m.addram_byte_request = nil
}

// SetPVCost sets the "pv_cost" field.
func (m *CostReportMutation) SetPVCost(f float64) {
	m.pv_cost = &f
	m.addpv_cost = nil
}

// PVCost returns the value of the "pv_cost" field in the mutation.
func (m *CostReportMutation) PVCost() (r float64, exists bool) {
	v := m.pv_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldPVCost returns the old "pv_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldPVCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPVCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPVCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPVCost: %w", err)
	}
	return oldValue.PVCost, nil
}

// AddPVCost adds f to the "pv_cost" field.
func (m *CostReportMutation) AddPVCost(f float64) {
	if m.addpv_cost != nil {
		*m.addpv_cost += f
	} else {
		m.addpv_cost = &f
	}
}

// AddedPVCost returns the value that was added to the "pv_cost" field in this mutation.
func (m *CostReportMutation) AddedPVCost() (r float64, exists bool) {
	v := m.addpv_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetPVCost resets all changes to the "pv_cost" field.
func (m *CostReportMutation) ResetPVCost() {
	m.pv_cost = nil
	m.addpv_cost = nil
}

// SetPVBytes sets the "pv_bytes" field.
func (m *CostReportMutation) SetPVBytes(f float64) {
	m.pv_bytes = &f
	m.addpv_bytes = nil
}

// PVBytes returns the value of the "pv_bytes" field in the mutation.
func (m *CostReportMutation) PVBytes() (r float64, exists bool) {
	v := m.pv_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldPVBytes returns the old "pv_bytes" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldPVBytes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPVBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPVBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPVBytes: %w", err)
	}
	return oldValue.PVBytes, nil
}

// AddPVBytes adds f to the "pv_bytes" field.
func (m *CostReportMutation) AddPVBytes(f float64) {
	if m.addpv_bytes != nil {
		*m.addpv_bytes += f
	} else {
		m.addpv_bytes = &f
	}
}

// AddedPVBytes returns the value that was added to the "pv_bytes" field in this mutation.
func (m *CostReportMutation) AddedPVBytes() (r float64, exists bool) {
	v := m.addpv_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetPVBytes resets all changes to the "pv_bytes" field.
func (m *CostReportMutation) ResetPVBytes() {
	m.pv_bytes = nil
	m.addpv_bytes = nil
}

// SetLoadBalancerCost sets the "load_balancer_cost" field.
func (m *CostReportMutation) SetLoadBalancerCost(f float64) {
	m.load_balancer_cost = &f
	m.addload_balancer_cost = nil
}

// LoadBalancerCost returns the value of the "load_balancer_cost" field in the mutation.
func (m *CostReportMutation) LoadBalancerCost() (r float64, exists bool) {
	v := m.load_balancer_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadBalancerCost returns the old "load_balancer_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldLoadBalancerCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoadBalancerCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoadBalancerCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadBalancerCost: %w", err)
	}
	return oldValue.LoadBalancerCost, nil
}

// AddLoadBalancerCost adds f to the "load_balancer_cost" field.
func (m *CostReportMutation) AddLoadBalancerCost(f float64) {
	if m.addload_balancer_cost != nil {
		*m.addload_balancer_cost += f
	} else {
		m.addload_balancer_cost = &f
	}
}

// AddedLoadBalancerCost returns the value that was added to the "load_balancer_cost" field in this mutation.
func (m *CostReportMutation) AddedLoadBalancerCost() (r float64, exists bool) {
	v := m.addload_balancer_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoadBalancerCost resets all changes to the "load_balancer_cost" field.
func (m *CostReportMutation) ResetLoadBalancerCost() {
	m.load_balancer_cost = nil
	m.addload_balancer_cost = nil
}

// SetCPUCoreUsageAverage sets the "cpu_core_usage_average" field.
func (m *CostReportMutation) SetCPUCoreUsageAverage(f float64) {
	m.cpu_core_usage_average = &f
	m.addcpu_core_usage_average = nil
}

// CPUCoreUsageAverage returns the value of the "cpu_core_usage_average" field in the mutation.
func (m *CostReportMutation) CPUCoreUsageAverage() (r float64, exists bool) {
	v := m.cpu_core_usage_average
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCoreUsageAverage returns the old "cpu_core_usage_average" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCPUCoreUsageAverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCoreUsageAverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCoreUsageAverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCoreUsageAverage: %w", err)
	}
	return oldValue.CPUCoreUsageAverage, nil
}

// AddCPUCoreUsageAverage adds f to the "cpu_core_usage_average" field.
func (m *CostReportMutation) AddCPUCoreUsageAverage(f float64) {
	if m.addcpu_core_usage_average != nil {
		*m.addcpu_core_usage_average += f
	} else {
		m.addcpu_core_usage_average = &f
	}
}

// AddedCPUCoreUsageAverage returns the value that was added to the "cpu_core_usage_average" field in this mutation.
func (m *CostReportMutation) AddedCPUCoreUsageAverage() (r float64, exists bool) {
	v := m.addcpu_core_usage_average
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCoreUsageAverage resets all changes to the "cpu_core_usage_average" field.
func (m *CostReportMutation) ResetCPUCoreUsageAverage() {
	m.cpu_core_usage_average = nil
	m.addcpu_core_usage_average = nil
}

// SetCPUCoreUsageMax sets the "cpu_core_usage_max" field.
func (m *CostReportMutation) SetCPUCoreUsageMax(f float64) {
	m.cpu_core_usage_max = &f
	m.addcpu_core_usage_max = nil
}

// CPUCoreUsageMax returns the value of the "cpu_core_usage_max" field in the mutation.
func (m *CostReportMutation) CPUCoreUsageMax() (r float64, exists bool) {
	v := m.cpu_core_usage_max
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCoreUsageMax returns the old "cpu_core_usage_max" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCPUCoreUsageMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCoreUsageMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCoreUsageMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCoreUsageMax: %w", err)
	}
	return oldValue.CPUCoreUsageMax, nil
}

// AddCPUCoreUsageMax adds f to the "cpu_core_usage_max" field.
func (m *CostReportMutation) AddCPUCoreUsageMax(f float64) {
	if m.addcpu_core_usage_max != nil {
		*m.addcpu_core_usage_max += f
	} else {
		m.addcpu_core_usage_max = &f
	}
}

// AddedCPUCoreUsageMax returns the value that was added to the "cpu_core_usage_max" field in this mutation.
func (m *CostReportMutation) AddedCPUCoreUsageMax() (r float64, exists bool) {
	v := m.addcpu_core_usage_max
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCoreUsageMax resets all changes to the "cpu_core_usage_max" field.
func (m *CostReportMutation) ResetCPUCoreUsageMax() {
	m.cpu_core_usage_max = nil
	m.addcpu_core_usage_max = nil
}

// SetRAMByteUsageAverage sets the "ram_byte_usage_average" field.
func (m *CostReportMutation) SetRAMByteUsageAverage(f float64) {
	m.ram_byte_usage_average = &f
	m.addram_byte_usage_average = nil
}

// RAMByteUsageAverage returns the value of the "ram_byte_usage_average" field in the mutation.
func (m *CostReportMutation) RAMByteUsageAverage() (r float64, exists bool) {
	v := m.ram_byte_usage_average
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMByteUsageAverage returns the old "ram_byte_usage_average" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldRAMByteUsageAverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMByteUsageAverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMByteUsageAverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMByteUsageAverage: %w", err)
	}
	return oldValue.RAMByteUsageAverage, nil
}

// AddRAMByteUsageAverage adds f to the "ram_byte_usage_average" field.
func (m *CostReportMutation) AddRAMByteUsageAverage(f float64) {
	if m.addram_byte_usage_average != nil {
		*m.addram_byte_usage_average += f
	} else {
		m.addram_byte_usage_average = &f
	}
}

// AddedRAMByteUsageAverage returns the value that was added to the "ram_byte_usage_average" field in this mutation.
func (m *CostReportMutation) AddedRAMByteUsageAverage() (r float64, exists bool) {
	v := m.addram_byte_usage_average
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMByteUsageAverage resets all changes to the "ram_byte_usage_average" field.
func (m *CostReportMutation) ResetRAMByteUsageAverage() {
	m.ram_byte_usage_average = nil
	m.addram_byte_usage_average = nil
}

// SetRAMByteUsageMax sets the "ram_byte_usage_max" field.
func (m *CostReportMutation) SetRAMByteUsageMax(f float64) {
	m.ram_byte_usage_max = &f
	m.addram_byte_usage_max = nil
}

// RAMByteUsageMax returns the value of the "ram_byte_usage_max" field in the mutation.
func (m *CostReportMutation) RAMByteUsageMax() (r float64, exists bool) {
	v := m.ram_byte_usage_max
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMByteUsageMax returns the old "ram_byte_usage_max" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldRAMByteUsageMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMByteUsageMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMByteUsageMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMByteUsageMax: %w", err)
	}
	return oldValue.RAMByteUsageMax, nil
}

// AddRAMByteUsageMax adds f to the "ram_byte_usage_max" field.
func (m *CostReportMutation) AddRAMByteUsageMax(f float64) {
	if m.addram_byte_usage_max != nil {
		*m.addram_byte_usage_max += f
	} else {
		m.addram_byte_usage_max = &f
	}
}

// AddedRAMByteUsageMax returns the value that was added to the "ram_byte_usage_max" field in this mutation.
func (m *CostReportMutation) AddedRAMByteUsageMax() (r float64, exists bool) {
	v := m.addram_byte_usage_max
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMByteUsageMax resets all changes to the "ram_byte_usage_max" field.
func (m *CostReportMutation) ResetRAMByteUsageMax() {
	m.ram_byte_usage_max = nil
	m.addram_byte_usage_max = nil
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *CostReportMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *CostReportMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *CostReportMutation) ConnectorIDs() (ids []object.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *CostReportMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// Where appends a list predicates to the CostReportMutation builder.
func (m *CostReportMutation) Where(ps ...predicate.CostReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CostReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CostReport).
func (m *CostReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostReportMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.start_time != nil {
		fields = append(fields, costreport.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, costreport.FieldEndTime)
	}
	if m.minutes != nil {
		fields = append(fields, costreport.FieldMinutes)
	}
	if m.connector != nil {
		fields = append(fields, costreport.FieldConnectorID)
	}
	if m.name != nil {
		fields = append(fields, costreport.FieldName)
	}
	if m.fingerprint != nil {
		fields = append(fields, costreport.FieldFingerprint)
	}
	if m.cluster_name != nil {
		fields = append(fields, costreport.FieldClusterName)
	}
	if m.namespace != nil {
		fields = append(fields, costreport.FieldNamespace)
	}
	if m.node != nil {
		fields = append(fields, costreport.FieldNode)
	}
	if m.controller != nil {
		fields = append(fields, costreport.FieldController)
	}
	if m.controller_kind != nil {
		fields = append(fields, costreport.FieldControllerKind)
	}
	if m.pod != nil {
		fields = append(fields, costreport.FieldPod)
	}
	if m.container != nil {
		fields = append(fields, costreport.FieldContainer)
	}
	if m.pvs != nil {
		fields = append(fields, costreport.FieldPvs)
	}
	if m.labels != nil {
		fields = append(fields, costreport.FieldLabels)
	}
	if m.totalCost != nil {
		fields = append(fields, costreport.FieldTotalCost)
	}
	if m.currency != nil {
		fields = append(fields, costreport.FieldCurrency)
	}
	if m.cpu_cost != nil {
		fields = append(fields, costreport.FieldCPUCost)
	}
	if m.cpu_core_request != nil {
		fields = append(fields, costreport.FieldCPUCoreRequest)
	}
	if m.gpu_cost != nil {
		fields = append(fields, costreport.FieldGPUCost)
	}
	if m.gpu_count != nil {
		fields = append(fields, costreport.FieldGPUCount)
	}
	if m.ram_cost != nil {
		fields = append(fields, costreport.FieldRAMCost)
	}
	if m.ram_byte_request != nil {
		fields = append(fields, costreport.FieldRAMByteRequest)
	}
	if m.pv_cost != nil {
		fields = append(fields, costreport.FieldPVCost)
	}
	if m.pv_bytes != nil {
		fields = append(fields, costreport.FieldPVBytes)
	}
	if m.load_balancer_cost != nil {
		fields = append(fields, costreport.FieldLoadBalancerCost)
	}
	if m.cpu_core_usage_average != nil {
		fields = append(fields, costreport.FieldCPUCoreUsageAverage)
	}
	if m.cpu_core_usage_max != nil {
		fields = append(fields, costreport.FieldCPUCoreUsageMax)
	}
	if m.ram_byte_usage_average != nil {
		fields = append(fields, costreport.FieldRAMByteUsageAverage)
	}
	if m.ram_byte_usage_max != nil {
		fields = append(fields, costreport.FieldRAMByteUsageMax)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costreport.FieldStartTime:
		return m.StartTime()
	case costreport.FieldEndTime:
		return m.EndTime()
	case costreport.FieldMinutes:
		return m.Minutes()
	case costreport.FieldConnectorID:
		return m.ConnectorID()
	case costreport.FieldName:
		return m.Name()
	case costreport.FieldFingerprint:
		return m.Fingerprint()
	case costreport.FieldClusterName:
		return m.ClusterName()
	case costreport.FieldNamespace:
		return m.Namespace()
	case costreport.FieldNode:
		return m.Node()
	case costreport.FieldController:
		return m.Controller()
	case costreport.FieldControllerKind:
		return m.ControllerKind()
	case costreport.FieldPod:
		return m.Pod()
	case costreport.FieldContainer:
		return m.Container()
	case costreport.FieldPvs:
		return m.Pvs()
	case costreport.FieldLabels:
		return m.Labels()
	case costreport.FieldTotalCost:
		return m.TotalCost()
	case costreport.FieldCurrency:
		return m.Currency()
	case costreport.FieldCPUCost:
		return m.CPUCost()
	case costreport.FieldCPUCoreRequest:
		return m.CPUCoreRequest()
	case costreport.FieldGPUCost:
		return m.GPUCost()
	case costreport.FieldGPUCount:
		return m.GPUCount()
	case costreport.FieldRAMCost:
		return m.RAMCost()
	case costreport.FieldRAMByteRequest:
		return m.RAMByteRequest()
	case costreport.FieldPVCost:
		return m.PVCost()
	case costreport.FieldPVBytes:
		return m.PVBytes()
	case costreport.FieldLoadBalancerCost:
		return m.LoadBalancerCost()
	case costreport.FieldCPUCoreUsageAverage:
		return m.CPUCoreUsageAverage()
	case costreport.FieldCPUCoreUsageMax:
		return m.CPUCoreUsageMax()
	case costreport.FieldRAMByteUsageAverage:
		return m.RAMByteUsageAverage()
	case costreport.FieldRAMByteUsageMax:
		return m.RAMByteUsageMax()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costreport.FieldStartTime:
		return m.OldStartTime(ctx)
	case costreport.FieldEndTime:
		return m.OldEndTime(ctx)
	case costreport.FieldMinutes:
		return m.OldMinutes(ctx)
	case costreport.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case costreport.FieldName:
		return m.OldName(ctx)
	case costreport.FieldFingerprint:
		return m.OldFingerprint(ctx)
	case costreport.FieldClusterName:
		return m.OldClusterName(ctx)
	case costreport.FieldNamespace:
		return m.OldNamespace(ctx)
	case costreport.FieldNode:
		return m.OldNode(ctx)
	case costreport.FieldController:
		return m.OldController(ctx)
	case costreport.FieldControllerKind:
		return m.OldControllerKind(ctx)
	case costreport.FieldPod:
		return m.OldPod(ctx)
	case costreport.FieldContainer:
		return m.OldContainer(ctx)
	case costreport.FieldPvs:
		return m.OldPvs(ctx)
	case costreport.FieldLabels:
		return m.OldLabels(ctx)
	case costreport.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case costreport.FieldCurrency:
		return m.OldCurrency(ctx)
	case costreport.FieldCPUCost:
		return m.OldCPUCost(ctx)
	case costreport.FieldCPUCoreRequest:
		return m.OldCPUCoreRequest(ctx)
	case costreport.FieldGPUCost:
		return m.OldGPUCost(ctx)
	case costreport.FieldGPUCount:
		return m.OldGPUCount(ctx)
	case costreport.FieldRAMCost:
		return m.OldRAMCost(ctx)
	case costreport.FieldRAMByteRequest:
		return m.OldRAMByteRequest(ctx)
	case costreport.FieldPVCost:
		return m.OldPVCost(ctx)
	case costreport.FieldPVBytes:
		return m.OldPVBytes(ctx)
	case costreport.FieldLoadBalancerCost:
		return m.OldLoadBalancerCost(ctx)
	case costreport.FieldCPUCoreUsageAverage:
		return m.OldCPUCoreUsageAverage(ctx)
	case costreport.FieldCPUCoreUsageMax:
		return m.OldCPUCoreUsageMax(ctx)
	case costreport.FieldRAMByteUsageAverage:
		return m.OldRAMByteUsageAverage(ctx)
	case costreport.FieldRAMByteUsageMax:
		return m.OldRAMByteUsageMax(ctx)
	}
	return nil, fmt.Errorf("unknown CostReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costreport.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case costreport.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case costreport.FieldMinutes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinutes(v)
		return nil
	case costreport.FieldConnectorID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case costreport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case costreport.FieldFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprint(v)
		return nil
	case costreport.FieldClusterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterName(v)
		return nil
	case costreport.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case costreport.FieldNode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNode(v)
		return nil
	case costreport.FieldController:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetController(v)
		return nil
	case costreport.FieldControllerKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControllerKind(v)
		return nil
	case costreport.FieldPod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPod(v)
		return nil
	case costreport.FieldContainer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainer(v)
		return nil
	case costreport.FieldPvs:
		v, ok := value.(map[string]types.PVCost)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPvs(v)
		return nil
	case costreport.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case costreport.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case costreport.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case costreport.FieldCPUCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCost(v)
		return nil
	case costreport.FieldCPUCoreRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCoreRequest(v)
		return nil
	case costreport.FieldGPUCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGPUCost(v)
		return nil
	case costreport.FieldGPUCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGPUCount(v)
		return nil
	case costreport.FieldRAMCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMCost(v)
		return nil
	case costreport.FieldRAMByteRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMByteRequest(v)
		return nil
	case costreport.FieldPVCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPVCost(v)
		return nil
	case costreport.FieldPVBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPVBytes(v)
		return nil
	case costreport.FieldLoadBalancerCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadBalancerCost(v)
		return nil
	case costreport.FieldCPUCoreUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCoreUsageAverage(v)
		return nil
	case costreport.FieldCPUCoreUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCoreUsageMax(v)
		return nil
	case costreport.FieldRAMByteUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMByteUsageAverage(v)
		return nil
	case costreport.FieldRAMByteUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMByteUsageMax(v)
		return nil
	}
	return fmt.Errorf("unknown CostReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostReportMutation) AddedFields() []string {
	var fields []string
	if m.addminutes != nil {
		fields = append(fields, costreport.FieldMinutes)
	}
	if m.addtotalCost != nil {
		fields = append(fields, costreport.FieldTotalCost)
	}
	if m.addcurrency != nil {
		fields = append(fields, costreport.FieldCurrency)
	}
	if m.addcpu_cost != nil {
		fields = append(fields, costreport.FieldCPUCost)
	}
	if m.addcpu_core_request != nil {
		fields = append(fields, costreport.FieldCPUCoreRequest)
	}
	if m.addgpu_cost != nil {
		fields = append(fields, costreport.FieldGPUCost)
	}
	if m.addgpu_count != nil {
		fields = append(fields, costreport.FieldGPUCount)
	}
	if m.addram_cost != nil {
		fields = append(fields, costreport.FieldRAMCost)
	}
	if m.addram_byte_request != nil {
		fields = append(fields, costreport.FieldRAMByteRequest)
	}
	if m.addpv_cost != nil {
		fields = append(fields, costreport.FieldPVCost)
	}
	if m.addpv_bytes != nil {
		fields = append(fields, costreport.FieldPVBytes)
	}
	if m.addload_balancer_cost != nil {
		fields = append(fields, costreport.FieldLoadBalancerCost)
	}
	if m.addcpu_core_usage_average != nil {
		fields = append(fields, costreport.FieldCPUCoreUsageAverage)
	}
	if m.addcpu_core_usage_max != nil {
		fields = append(fields, costreport.FieldCPUCoreUsageMax)
	}
	if m.addram_byte_usage_average != nil {
		fields = append(fields, costreport.FieldRAMByteUsageAverage)
	}
	if m.addram_byte_usage_max != nil {
		fields = append(fields, costreport.FieldRAMByteUsageMax)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case costreport.FieldMinutes:
		return m.AddedMinutes()
	case costreport.FieldTotalCost:
		return m.AddedTotalCost()
	case costreport.FieldCurrency:
		return m.AddedCurrency()
	case costreport.FieldCPUCost:
		return m.AddedCPUCost()
	case costreport.FieldCPUCoreRequest:
		return m.AddedCPUCoreRequest()
	case costreport.FieldGPUCost:
		return m.AddedGPUCost()
	case costreport.FieldGPUCount:
		return m.AddedGPUCount()
	case costreport.FieldRAMCost:
		return m.AddedRAMCost()
	case costreport.FieldRAMByteRequest:
		return m.AddedRAMByteRequest()
	case costreport.FieldPVCost:
		return m.AddedPVCost()
	case costreport.FieldPVBytes:
		return m.AddedPVBytes()
	case costreport.FieldLoadBalancerCost:
		return m.AddedLoadBalancerCost()
	case costreport.FieldCPUCoreUsageAverage:
		return m.AddedCPUCoreUsageAverage()
	case costreport.FieldCPUCoreUsageMax:
		return m.AddedCPUCoreUsageMax()
	case costreport.FieldRAMByteUsageAverage:
		return m.AddedRAMByteUsageAverage()
	case costreport.FieldRAMByteUsageMax:
		return m.AddedRAMByteUsageMax()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case costreport.FieldMinutes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinutes(v)
		return nil
	case costreport.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	case costreport.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrency(v)
		return nil
	case costreport.FieldCPUCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCost(v)
		return nil
	case costreport.FieldCPUCoreRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCoreRequest(v)
		return nil
	case costreport.FieldGPUCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGPUCost(v)
		return nil
	case costreport.FieldGPUCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGPUCount(v)
		return nil
	case costreport.FieldRAMCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMCost(v)
		return nil
	case costreport.FieldRAMByteRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMByteRequest(v)
		return nil
	case costreport.FieldPVCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPVCost(v)
		return nil
	case costreport.FieldPVBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPVBytes(v)
		return nil
	case costreport.FieldLoadBalancerCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadBalancerCost(v)
		return nil
	case costreport.FieldCPUCoreUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCoreUsageAverage(v)
		return nil
	case costreport.FieldCPUCoreUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCoreUsageMax(v)
		return nil
	case costreport.FieldRAMByteUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMByteUsageAverage(v)
		return nil
	case costreport.FieldRAMByteUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMByteUsageMax(v)
		return nil
	}
	return fmt.Errorf("unknown CostReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(costreport.FieldClusterName) {
		fields = append(fields, costreport.FieldClusterName)
	}
	if m.FieldCleared(costreport.FieldNamespace) {
		fields = append(fields, costreport.FieldNamespace)
	}
	if m.FieldCleared(costreport.FieldNode) {
		fields = append(fields, costreport.FieldNode)
	}
	if m.FieldCleared(costreport.FieldController) {
		fields = append(fields, costreport.FieldController)
	}
	if m.FieldCleared(costreport.FieldControllerKind) {
		fields = append(fields, costreport.FieldControllerKind)
	}
	if m.FieldCleared(costreport.FieldPod) {
		fields = append(fields, costreport.FieldPod)
	}
	if m.FieldCleared(costreport.FieldContainer) {
		fields = append(fields, costreport.FieldContainer)
	}
	if m.FieldCleared(costreport.FieldCurrency) {
		fields = append(fields, costreport.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostReportMutation) ClearField(name string) error {
	switch name {
	case costreport.FieldClusterName:
		m.ClearClusterName()
		return nil
	case costreport.FieldNamespace:
		m.ClearNamespace()
		return nil
	case costreport.FieldNode:
		m.ClearNode()
		return nil
	case costreport.FieldController:
		m.ClearController()
		return nil
	case costreport.FieldControllerKind:
		m.ClearControllerKind()
		return nil
	case costreport.FieldPod:
		m.ClearPod()
		return nil
	case costreport.FieldContainer:
		m.ClearContainer()
		return nil
	case costreport.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown CostReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostReportMutation) ResetField(name string) error {
	switch name {
	case costreport.FieldStartTime:
		m.ResetStartTime()
		return nil
	case costreport.FieldEndTime:
		m.ResetEndTime()
		return nil
	case costreport.FieldMinutes:
		m.ResetMinutes()
		return nil
	case costreport.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case costreport.FieldName:
		m.ResetName()
		return nil
	case costreport.FieldFingerprint:
		m.ResetFingerprint()
		return nil
	case costreport.FieldClusterName:
		m.ResetClusterName()
		return nil
	case costreport.FieldNamespace:
		m.ResetNamespace()
		return nil
	case costreport.FieldNode:
		m.ResetNode()
		return nil
	case costreport.FieldController:
		m.ResetController()
		return nil
	case costreport.FieldControllerKind:
		m.ResetControllerKind()
		return nil
	case costreport.FieldPod:
		m.ResetPod()
		return nil
	case costreport.FieldContainer:
		m.ResetContainer()
		return nil
	case costreport.FieldPvs:
		m.ResetPvs()
		return nil
	case costreport.FieldLabels:
		m.ResetLabels()
		return nil
	case costreport.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case costreport.FieldCurrency:
		m.ResetCurrency()
		return nil
	case costreport.FieldCPUCost:
		m.ResetCPUCost()
		return nil
	case costreport.FieldCPUCoreRequest:
		m.ResetCPUCoreRequest()
		return nil
	case costreport.FieldGPUCost:
		m.ResetGPUCost()
		return nil
	case costreport.FieldGPUCount:
		m.ResetGPUCount()
		return nil
	case costreport.FieldRAMCost:
		m.ResetRAMCost()
		return nil
	case costreport.FieldRAMByteRequest:
		m.ResetRAMByteRequest()
		return nil
	case costreport.FieldPVCost:
		m.ResetPVCost()
		return nil
	case costreport.FieldPVBytes:
		m.ResetPVBytes()
		return nil
	case costreport.FieldLoadBalancerCost:
		m.ResetLoadBalancerCost()
		return nil
	case costreport.FieldCPUCoreUsageAverage:
		m.ResetCPUCoreUsageAverage()
		return nil
	case costreport.FieldCPUCoreUsageMax:
		m.ResetCPUCoreUsageMax()
		return nil
	case costreport.FieldRAMByteUsageAverage:
		m.ResetRAMByteUsageAverage()
		return nil
	case costreport.FieldRAMByteUsageMax:
		m.ResetRAMByteUsageMax()
		return nil
	}
	return fmt.Errorf("unknown CostReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connector != nil {
		edges = append(edges, costreport.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costreport.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnector {
		edges = append(edges, costreport.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostReportMutation) EdgeCleared(name string) bool {
	switch name {
	case costreport.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostReportMutation) ClearEdge(name string) error {
	switch name {
	case costreport.EdgeConnector:
		m.ClearConnector()
		return nil
	}
	return fmt.Errorf("unknown CostReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostReportMutation) ResetEdge(name string) error {
	switch name {
	case costreport.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown CostReport edge %s", name)
}

// DistributeLockMutation represents an operation that mutates the DistributeLock nodes in the graph.
type DistributeLockMutation struct {
	config
	op            Op
	typ           string
	id            *string
	expireAt      *int64
	addexpireAt   *int64
	holder        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DistributeLock, error)
	predicates    []predicate.DistributeLock
}

var _ ent.Mutation = (*DistributeLockMutation)(nil)

// distributeLockOption allows management of the mutation configuration using functional options.
type distributeLockOption func(*DistributeLockMutation)

// newDistributeLockMutation creates new mutation for the DistributeLock entity.
func newDistributeLockMutation(c config, op Op, opts ...distributeLockOption) *DistributeLockMutation {
	m := &DistributeLockMutation{
		config:        c,
		op:            op,
		typ:           TypeDistributeLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistributeLockID sets the ID field of the mutation.
func withDistributeLockID(id string) distributeLockOption {
	return func(m *DistributeLockMutation) {
		var (
			err   error
			once  sync.Once
			value *DistributeLock
		)
		m.oldValue = func(ctx context.Context) (*DistributeLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DistributeLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistributeLock sets the old DistributeLock of the mutation.
func withDistributeLock(node *DistributeLock) distributeLockOption {
	return func(m *DistributeLockMutation) {
		m.oldValue = func(context.Context) (*DistributeLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistributeLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistributeLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DistributeLock entities.
func (m *DistributeLockMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DistributeLockMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DistributeLockMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DistributeLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExpireAt sets the "expireAt" field.
func (m *DistributeLockMutation) SetExpireAt(i int64) {
	m.expireAt = &i
	m.addexpireAt = nil
}

// ExpireAt returns the value of the "expireAt" field in the mutation.
func (m *DistributeLockMutation) ExpireAt() (r int64, exists bool) {
	v := m.expireAt
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expireAt" field's value of the DistributeLock entity.
// If the DistributeLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistributeLockMutation) OldExpireAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// AddExpireAt adds i to the "expireAt" field.
func (m *DistributeLockMutation) AddExpireAt(i int64) {
	if m.addexpireAt != nil {
		*m.addexpireAt += i
	} else {
		m.addexpireAt = &i
	}
}

// AddedExpireAt returns the value that was added to the "expireAt" field in this mutation.
func (m *DistributeLockMutation) AddedExpireAt() (r int64, exists bool) {
	v := m.addexpireAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpireAt resets all changes to the "expireAt" field.
func (m *DistributeLockMutation) ResetExpireAt() {
	m.expireAt = nil
	m.addexpireAt = nil
}

// SetHolder sets the "holder" field.
func (m *DistributeLockMutation) SetHolder(s string) {
	m.holder = &s
}

// Holder returns the value of the "holder" field in the mutation.
func (m *DistributeLockMutation) Holder() (r string, exists bool) {
	v := m.holder
	if v == nil {
		return
	}
	return *v, true
}

// OldHolder returns the old "holder" field's value of the DistributeLock entity.
// If the DistributeLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistributeLockMutation) OldHolder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHolder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHolder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHolder: %w", err)
	}
	return oldValue.Holder, nil
}

// ResetHolder resets all changes to the "holder" field.
func (m *DistributeLockMutation) ResetHolder() {
	m.holder = nil
}

// Where appends a list predicates to the DistributeLockMutation builder.
func (m *DistributeLockMutation) Where(ps ...predicate.DistributeLock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DistributeLockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DistributeLockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DistributeLock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DistributeLockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DistributeLockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DistributeLock).
func (m *DistributeLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistributeLockMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.expireAt != nil {
		fields = append(fields, distributelock.FieldExpireAt)
	}
	if m.holder != nil {
		fields = append(fields, distributelock.FieldHolder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistributeLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case distributelock.FieldExpireAt:
		return m.ExpireAt()
	case distributelock.FieldHolder:
		return m.Holder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistributeLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case distributelock.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case distributelock.FieldHolder:
		return m.OldHolder(ctx)
	}
	return nil, fmt.Errorf("unknown DistributeLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistributeLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case distributelock.FieldExpireAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case distributelock.FieldHolder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHolder(v)
		return nil
	}
	return fmt.Errorf("unknown DistributeLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistributeLockMutation) AddedFields() []string {
	var fields []string
	if m.addexpireAt != nil {
		fields = append(fields, distributelock.FieldExpireAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistributeLockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case distributelock.FieldExpireAt:
		return m.AddedExpireAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistributeLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case distributelock.FieldExpireAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireAt(v)
		return nil
	}
	return fmt.Errorf("unknown DistributeLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistributeLockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistributeLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistributeLockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DistributeLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistributeLockMutation) ResetField(name string) error {
	switch name {
	case distributelock.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case distributelock.FieldHolder:
		m.ResetHolder()
		return nil
	}
	return fmt.Errorf("unknown DistributeLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistributeLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistributeLockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistributeLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistributeLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistributeLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistributeLockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistributeLockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DistributeLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistributeLockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DistributeLock edge %s", name)
}

// EnvironmentMutation represents an operation that mutates the Environment nodes in the graph.
type EnvironmentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *object.ID
	name                     *string
	description              *string
	labels                   *map[string]string
	annotations              *map[string]string
	create_time              *time.Time
	update_time              *time.Time
	_type                    *string
	clearedFields            map[string]struct{}
	project                  *object.ID
	clearedproject           bool
	connectors               map[object.ID]struct{}
	removedconnectors        map[object.ID]struct{}
	clearedconnectors        bool
	services                 map[object.ID]struct{}
	removedservices          map[object.ID]struct{}
	clearedservices          bool
	service_revisions        map[object.ID]struct{}
	removedservice_revisions map[object.ID]struct{}
	clearedservice_revisions bool
	service_resources        map[object.ID]struct{}
	removedservice_resources map[object.ID]struct{}
	clearedservice_resources bool
	variables                map[object.ID]struct{}
	removedvariables         map[object.ID]struct{}
	clearedvariables         bool
	done                     bool
	oldValue                 func(context.Context) (*Environment, error)
	predicates               []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows management of the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for the Environment entity.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the ID field of the mutation.
func withEnvironmentID(id object.ID) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Environment entities.
func (m *EnvironmentMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Environment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EnvironmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EnvironmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EnvironmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[environment.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EnvironmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[environment.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EnvironmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, environment.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *EnvironmentMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *EnvironmentMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *EnvironmentMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[environment.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *EnvironmentMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[environment.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *EnvironmentMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, environment.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *EnvironmentMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *EnvironmentMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *EnvironmentMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[environment.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *EnvironmentMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[environment.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *EnvironmentMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, environment.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *EnvironmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EnvironmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EnvironmentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EnvironmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EnvironmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EnvironmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *EnvironmentMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *EnvironmentMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *EnvironmentMutation) ResetProjectID() {
	m.project = nil
}

// SetType sets the "type" field.
func (m *EnvironmentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *EnvironmentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EnvironmentMutation) ResetType() {
	m._type = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *EnvironmentMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *EnvironmentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *EnvironmentMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *EnvironmentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddConnectorIDs adds the "connectors" edge to the EnvironmentConnectorRelationship entity by ids.
func (m *EnvironmentMutation) AddConnectorIDs(ids ...object.ID) {
	if m.connectors == nil {
		m.connectors = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.connectors[ids[i]] = struct{}{}
	}
}

// ClearConnectors clears the "connectors" edge to the EnvironmentConnectorRelationship entity.
func (m *EnvironmentMutation) ClearConnectors() {
	m.clearedconnectors = true
}

// ConnectorsCleared reports if the "connectors" edge to the EnvironmentConnectorRelationship entity was cleared.
func (m *EnvironmentMutation) ConnectorsCleared() bool {
	return m.clearedconnectors
}

// RemoveConnectorIDs removes the "connectors" edge to the EnvironmentConnectorRelationship entity by IDs.
func (m *EnvironmentMutation) RemoveConnectorIDs(ids ...object.ID) {
	if m.removedconnectors == nil {
		m.removedconnectors = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.connectors, ids[i])
		m.removedconnectors[ids[i]] = struct{}{}
	}
}

// RemovedConnectors returns the removed IDs of the "connectors" edge to the EnvironmentConnectorRelationship entity.
func (m *EnvironmentMutation) RemovedConnectorsIDs() (ids []object.ID) {
	for id := range m.removedconnectors {
		ids = append(ids, id)
	}
	return
}

// ConnectorsIDs returns the "connectors" edge IDs in the mutation.
func (m *EnvironmentMutation) ConnectorsIDs() (ids []object.ID) {
	for id := range m.connectors {
		ids = append(ids, id)
	}
	return
}

// ResetConnectors resets all changes to the "connectors" edge.
func (m *EnvironmentMutation) ResetConnectors() {
	m.connectors = nil
	m.clearedconnectors = false
	m.removedconnectors = nil
}

// AddServiceIDs adds the "services" edge to the Service entity by ids.
func (m *EnvironmentMutation) AddServiceIDs(ids ...object.ID) {
	if m.services == nil {
		m.services = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Service entity.
func (m *EnvironmentMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *EnvironmentMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Service entity by IDs.
func (m *EnvironmentMutation) RemoveServiceIDs(ids ...object.ID) {
	if m.removedservices == nil {
		m.removedservices = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Service entity.
func (m *EnvironmentMutation) RemovedServicesIDs() (ids []object.ID) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *EnvironmentMutation) ServicesIDs() (ids []object.ID) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *EnvironmentMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// AddServiceRevisionIDs adds the "service_revisions" edge to the ServiceRevision entity by ids.
func (m *EnvironmentMutation) AddServiceRevisionIDs(ids ...object.ID) {
	if m.service_revisions == nil {
		m.service_revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.service_revisions[ids[i]] = struct{}{}
	}
}

// ClearServiceRevisions clears the "service_revisions" edge to the ServiceRevision entity.
func (m *EnvironmentMutation) ClearServiceRevisions() {
	m.clearedservice_revisions = true
}

// ServiceRevisionsCleared reports if the "service_revisions" edge to the ServiceRevision entity was cleared.
func (m *EnvironmentMutation) ServiceRevisionsCleared() bool {
	return m.clearedservice_revisions
}

// RemoveServiceRevisionIDs removes the "service_revisions" edge to the ServiceRevision entity by IDs.
func (m *EnvironmentMutation) RemoveServiceRevisionIDs(ids ...object.ID) {
	if m.removedservice_revisions == nil {
		m.removedservice_revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.service_revisions, ids[i])
		m.removedservice_revisions[ids[i]] = struct{}{}
	}
}

// RemovedServiceRevisions returns the removed IDs of the "service_revisions" edge to the ServiceRevision entity.
func (m *EnvironmentMutation) RemovedServiceRevisionsIDs() (ids []object.ID) {
	for id := range m.removedservice_revisions {
		ids = append(ids, id)
	}
	return
}

// ServiceRevisionsIDs returns the "service_revisions" edge IDs in the mutation.
func (m *EnvironmentMutation) ServiceRevisionsIDs() (ids []object.ID) {
	for id := range m.service_revisions {
		ids = append(ids, id)
	}
	return
}

// ResetServiceRevisions resets all changes to the "service_revisions" edge.
func (m *EnvironmentMutation) ResetServiceRevisions() {
	m.service_revisions = nil
	m.clearedservice_revisions = false
	m.removedservice_revisions = nil
}

// AddServiceResourceIDs adds the "service_resources" edge to the ServiceResource entity by ids.
func (m *EnvironmentMutation) AddServiceResourceIDs(ids ...object.ID) {
	if m.service_resources == nil {
		m.service_resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.service_resources[ids[i]] = struct{}{}
	}
}

// ClearServiceResources clears the "service_resources" edge to the ServiceResource entity.
func (m *EnvironmentMutation) ClearServiceResources() {
	m.clearedservice_resources = true
}

// ServiceResourcesCleared reports if the "service_resources" edge to the ServiceResource entity was cleared.
func (m *EnvironmentMutation) ServiceResourcesCleared() bool {
	return m.clearedservice_resources
}

// RemoveServiceResourceIDs removes the "service_resources" edge to the ServiceResource entity by IDs.
func (m *EnvironmentMutation) RemoveServiceResourceIDs(ids ...object.ID) {
	if m.removedservice_resources == nil {
		m.removedservice_resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.service_resources, ids[i])
		m.removedservice_resources[ids[i]] = struct{}{}
	}
}

// RemovedServiceResources returns the removed IDs of the "service_resources" edge to the ServiceResource entity.
func (m *EnvironmentMutation) RemovedServiceResourcesIDs() (ids []object.ID) {
	for id := range m.removedservice_resources {
		ids = append(ids, id)
	}
	return
}

// ServiceResourcesIDs returns the "service_resources" edge IDs in the mutation.
func (m *EnvironmentMutation) ServiceResourcesIDs() (ids []object.ID) {
	for id := range m.service_resources {
		ids = append(ids, id)
	}
	return
}

// ResetServiceResources resets all changes to the "service_resources" edge.
func (m *EnvironmentMutation) ResetServiceResources() {
	m.service_resources = nil
	m.clearedservice_resources = false
	m.removedservice_resources = nil
}

// AddVariableIDs adds the "variables" edge to the Variable entity by ids.
func (m *EnvironmentMutation) AddVariableIDs(ids ...object.ID) {
	if m.variables == nil {
		m.variables = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.variables[ids[i]] = struct{}{}
	}
}

// ClearVariables clears the "variables" edge to the Variable entity.
func (m *EnvironmentMutation) ClearVariables() {
	m.clearedvariables = true
}

// VariablesCleared reports if the "variables" edge to the Variable entity was cleared.
func (m *EnvironmentMutation) VariablesCleared() bool {
	return m.clearedvariables
}

// RemoveVariableIDs removes the "variables" edge to the Variable entity by IDs.
func (m *EnvironmentMutation) RemoveVariableIDs(ids ...object.ID) {
	if m.removedvariables == nil {
		m.removedvariables = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.variables, ids[i])
		m.removedvariables[ids[i]] = struct{}{}
	}
}

// RemovedVariables returns the removed IDs of the "variables" edge to the Variable entity.
func (m *EnvironmentMutation) RemovedVariablesIDs() (ids []object.ID) {
	for id := range m.removedvariables {
		ids = append(ids, id)
	}
	return
}

// VariablesIDs returns the "variables" edge IDs in the mutation.
func (m *EnvironmentMutation) VariablesIDs() (ids []object.ID) {
	for id := range m.variables {
		ids = append(ids, id)
	}
	return
}

// ResetVariables resets all changes to the "variables" edge.
func (m *EnvironmentMutation) ResetVariables() {
	m.variables = nil
	m.clearedvariables = false
	m.removedvariables = nil
}

// Where appends a list predicates to the EnvironmentMutation builder.
func (m *EnvironmentMutation) Where(ps ...predicate.Environment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Environment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	if m.description != nil {
		fields = append(fields, environment.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, environment.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, environment.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, environment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, environment.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, environment.FieldProjectID)
	}
	if m._type != nil {
		fields = append(fields, environment.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldName:
		return m.Name()
	case environment.FieldDescription:
		return m.Description()
	case environment.FieldLabels:
		return m.Labels()
	case environment.FieldAnnotations:
		return m.Annotations()
	case environment.FieldCreateTime:
		return m.CreateTime()
	case environment.FieldUpdateTime:
		return m.UpdateTime()
	case environment.FieldProjectID:
		return m.ProjectID()
	case environment.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldName:
		return m.OldName(ctx)
	case environment.FieldDescription:
		return m.OldDescription(ctx)
	case environment.FieldLabels:
		return m.OldLabels(ctx)
	case environment.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case environment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case environment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case environment.FieldProjectID:
		return m.OldProjectID(ctx)
	case environment.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case environment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case environment.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case environment.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case environment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case environment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case environment.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case environment.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(environment.FieldDescription) {
		fields = append(fields, environment.FieldDescription)
	}
	if m.FieldCleared(environment.FieldLabels) {
		fields = append(fields, environment.FieldLabels)
	}
	if m.FieldCleared(environment.FieldAnnotations) {
		fields = append(fields, environment.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	switch name {
	case environment.FieldDescription:
		m.ClearDescription()
		return nil
	case environment.FieldLabels:
		m.ClearLabels()
		return nil
	case environment.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldName:
		m.ResetName()
		return nil
	case environment.FieldDescription:
		m.ResetDescription()
		return nil
	case environment.FieldLabels:
		m.ResetLabels()
		return nil
	case environment.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case environment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case environment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case environment.FieldProjectID:
		m.ResetProjectID()
		return nil
	case environment.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.project != nil {
		edges = append(edges, environment.EdgeProject)
	}
	if m.connectors != nil {
		edges = append(edges, environment.EdgeConnectors)
	}
	if m.services != nil {
		edges = append(edges, environment.EdgeServices)
	}
	if m.service_revisions != nil {
		edges = append(edges, environment.EdgeServiceRevisions)
	}
	if m.service_resources != nil {
		edges = append(edges, environment.EdgeServiceResources)
	}
	if m.variables != nil {
		edges = append(edges, environment.EdgeVariables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case environment.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.connectors))
		for id := range m.connectors {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServiceRevisions:
		ids := make([]ent.Value, 0, len(m.service_revisions))
		for id := range m.service_revisions {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServiceResources:
		ids := make([]ent.Value, 0, len(m.service_resources))
		for id := range m.service_resources {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeVariables:
		ids := make([]ent.Value, 0, len(m.variables))
		for id := range m.variables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedconnectors != nil {
		edges = append(edges, environment.EdgeConnectors)
	}
	if m.removedservices != nil {
		edges = append(edges, environment.EdgeServices)
	}
	if m.removedservice_revisions != nil {
		edges = append(edges, environment.EdgeServiceRevisions)
	}
	if m.removedservice_resources != nil {
		edges = append(edges, environment.EdgeServiceResources)
	}
	if m.removedvariables != nil {
		edges = append(edges, environment.EdgeVariables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.removedconnectors))
		for id := range m.removedconnectors {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServiceRevisions:
		ids := make([]ent.Value, 0, len(m.removedservice_revisions))
		for id := range m.removedservice_revisions {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServiceResources:
		ids := make([]ent.Value, 0, len(m.removedservice_resources))
		for id := range m.removedservice_resources {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeVariables:
		ids := make([]ent.Value, 0, len(m.removedvariables))
		for id := range m.removedvariables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedproject {
		edges = append(edges, environment.EdgeProject)
	}
	if m.clearedconnectors {
		edges = append(edges, environment.EdgeConnectors)
	}
	if m.clearedservices {
		edges = append(edges, environment.EdgeServices)
	}
	if m.clearedservice_revisions {
		edges = append(edges, environment.EdgeServiceRevisions)
	}
	if m.clearedservice_resources {
		edges = append(edges, environment.EdgeServiceResources)
	}
	if m.clearedvariables {
		edges = append(edges, environment.EdgeVariables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeProject:
		return m.clearedproject
	case environment.EdgeConnectors:
		return m.clearedconnectors
	case environment.EdgeServices:
		return m.clearedservices
	case environment.EdgeServiceRevisions:
		return m.clearedservice_revisions
	case environment.EdgeServiceResources:
		return m.clearedservice_resources
	case environment.EdgeVariables:
		return m.clearedvariables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	case environment.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeProject:
		m.ResetProject()
		return nil
	case environment.EdgeConnectors:
		m.ResetConnectors()
		return nil
	case environment.EdgeServices:
		m.ResetServices()
		return nil
	case environment.EdgeServiceRevisions:
		m.ResetServiceRevisions()
		return nil
	case environment.EdgeServiceResources:
		m.ResetServiceResources()
		return nil
	case environment.EdgeVariables:
		m.ResetVariables()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// EnvironmentConnectorRelationshipMutation represents an operation that mutates the EnvironmentConnectorRelationship nodes in the graph.
type EnvironmentConnectorRelationshipMutation struct {
	config
	op                 Op
	typ                string
	id                 *object.ID
	create_time        *time.Time
	clearedFields      map[string]struct{}
	environment        *object.ID
	clearedenvironment bool
	connector          *object.ID
	clearedconnector   bool
	done               bool
	oldValue           func(context.Context) (*EnvironmentConnectorRelationship, error)
	predicates         []predicate.EnvironmentConnectorRelationship
}

var _ ent.Mutation = (*EnvironmentConnectorRelationshipMutation)(nil)

// environmentConnectorRelationshipOption allows management of the mutation configuration using functional options.
type environmentConnectorRelationshipOption func(*EnvironmentConnectorRelationshipMutation)

// newEnvironmentConnectorRelationshipMutation creates new mutation for the EnvironmentConnectorRelationship entity.
func newEnvironmentConnectorRelationshipMutation(c config, op Op, opts ...environmentConnectorRelationshipOption) *EnvironmentConnectorRelationshipMutation {
	m := &EnvironmentConnectorRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironmentConnectorRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentConnectorRelationshipID sets the ID field of the mutation.
func withEnvironmentConnectorRelationshipID(id object.ID) environmentConnectorRelationshipOption {
	return func(m *EnvironmentConnectorRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *EnvironmentConnectorRelationship
		)
		m.oldValue = func(ctx context.Context) (*EnvironmentConnectorRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnvironmentConnectorRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironmentConnectorRelationship sets the old EnvironmentConnectorRelationship of the mutation.
func withEnvironmentConnectorRelationship(node *EnvironmentConnectorRelationship) environmentConnectorRelationshipOption {
	return func(m *EnvironmentConnectorRelationshipMutation) {
		m.oldValue = func(context.Context) (*EnvironmentConnectorRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentConnectorRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentConnectorRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnvironmentConnectorRelationship entities.
func (m *EnvironmentConnectorRelationshipMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentConnectorRelationshipMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentConnectorRelationshipMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnvironmentConnectorRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EnvironmentConnectorRelationshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the EnvironmentConnectorRelationship entity.
// If the EnvironmentConnectorRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentConnectorRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *EnvironmentConnectorRelationshipMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the EnvironmentConnectorRelationship entity.
// If the EnvironmentConnectorRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentConnectorRelationshipMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *EnvironmentConnectorRelationshipMutation) SetConnectorID(o object.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorID() (r object.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the EnvironmentConnectorRelationship entity.
// If the EnvironmentConnectorRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentConnectorRelationshipMutation) OldConnectorID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetConnectorID() {
	m.connector = nil
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *EnvironmentConnectorRelationshipMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *EnvironmentConnectorRelationshipMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *EnvironmentConnectorRelationshipMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorIDs() (ids []object.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *EnvironmentConnectorRelationshipMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// Where appends a list predicates to the EnvironmentConnectorRelationshipMutation builder.
func (m *EnvironmentConnectorRelationshipMutation) Where(ps ...predicate.EnvironmentConnectorRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentConnectorRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentConnectorRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnvironmentConnectorRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentConnectorRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentConnectorRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnvironmentConnectorRelationship).
func (m *EnvironmentConnectorRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentConnectorRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, environmentconnectorrelationship.FieldCreateTime)
	}
	if m.environment != nil {
		fields = append(fields, environmentconnectorrelationship.FieldEnvironmentID)
	}
	if m.connector != nil {
		fields = append(fields, environmentconnectorrelationship.FieldConnectorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentConnectorRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		return m.CreateTime()
	case environmentconnectorrelationship.FieldEnvironmentID:
		return m.EnvironmentID()
	case environmentconnectorrelationship.FieldConnectorID:
		return m.ConnectorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentConnectorRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case environmentconnectorrelationship.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case environmentconnectorrelationship.FieldConnectorID:
		return m.OldConnectorID(ctx)
	}
	return nil, fmt.Errorf("unknown EnvironmentConnectorRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentConnectorRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case environmentconnectorrelationship.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case environmentconnectorrelationship.FieldConnectorID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentConnectorRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentConnectorRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnvironmentConnectorRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ResetField(name string) error {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case environmentconnectorrelationship.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case environmentconnectorrelationship.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.environment != nil {
		edges = append(edges, environmentconnectorrelationship.EdgeEnvironment)
	}
	if m.connector != nil {
		edges = append(edges, environmentconnectorrelationship.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case environmentconnectorrelationship.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenvironment {
		edges = append(edges, environmentconnectorrelationship.EdgeEnvironment)
	}
	if m.clearedconnector {
		edges = append(edges, environmentconnectorrelationship.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		return m.clearedenvironment
	case environmentconnectorrelationship.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case environmentconnectorrelationship.EdgeConnector:
		m.ClearConnector()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case environmentconnectorrelationship.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship edge %s", name)
}

// PerspectiveMutation represents an operation that mutates the Perspective nodes in the graph.
type PerspectiveMutation struct {
	config
	op                 Op
	typ                string
	id                 *object.ID
	name               *string
	description        *string
	labels             *map[string]string
	annotations        *map[string]string
	create_time        *time.Time
	update_time        *time.Time
	start_time         *string
	end_time           *string
	builtin            *bool
	cost_queries       *[]types.QueryCondition
	appendcost_queries []types.QueryCondition
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Perspective, error)
	predicates         []predicate.Perspective
}

var _ ent.Mutation = (*PerspectiveMutation)(nil)

// perspectiveOption allows management of the mutation configuration using functional options.
type perspectiveOption func(*PerspectiveMutation)

// newPerspectiveMutation creates new mutation for the Perspective entity.
func newPerspectiveMutation(c config, op Op, opts ...perspectiveOption) *PerspectiveMutation {
	m := &PerspectiveMutation{
		config:        c,
		op:            op,
		typ:           TypePerspective,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPerspectiveID sets the ID field of the mutation.
func withPerspectiveID(id object.ID) perspectiveOption {
	return func(m *PerspectiveMutation) {
		var (
			err   error
			once  sync.Once
			value *Perspective
		)
		m.oldValue = func(ctx context.Context) (*Perspective, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Perspective.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerspective sets the old Perspective of the mutation.
func withPerspective(node *Perspective) perspectiveOption {
	return func(m *PerspectiveMutation) {
		m.oldValue = func(context.Context) (*Perspective, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PerspectiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PerspectiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Perspective entities.
func (m *PerspectiveMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PerspectiveMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PerspectiveMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Perspective.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PerspectiveMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PerspectiveMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PerspectiveMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PerspectiveMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PerspectiveMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PerspectiveMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[perspective.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PerspectiveMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[perspective.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PerspectiveMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, perspective.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *PerspectiveMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *PerspectiveMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *PerspectiveMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[perspective.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *PerspectiveMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[perspective.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *PerspectiveMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, perspective.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *PerspectiveMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *PerspectiveMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *PerspectiveMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[perspective.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *PerspectiveMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[perspective.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *PerspectiveMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, perspective.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *PerspectiveMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PerspectiveMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PerspectiveMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PerspectiveMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PerspectiveMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PerspectiveMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStartTime sets the "start_time" field.
func (m *PerspectiveMutation) SetStartTime(s string) {
	m.start_time = &s
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *PerspectiveMutation) StartTime() (r string, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldStartTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *PerspectiveMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *PerspectiveMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *PerspectiveMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *PerspectiveMutation) ResetEndTime() {
	m.end_time = nil
}

// SetBuiltin sets the "builtin" field.
func (m *PerspectiveMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *PerspectiveMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *PerspectiveMutation) ResetBuiltin() {
	m.builtin = nil
}

// SetCostQueries sets the "cost_queries" field.
func (m *PerspectiveMutation) SetCostQueries(tc []types.QueryCondition) {
	m.cost_queries = &tc
	m.appendcost_queries = nil
}

// CostQueries returns the value of the "cost_queries" field in the mutation.
func (m *PerspectiveMutation) CostQueries() (r []types.QueryCondition, exists bool) {
	v := m.cost_queries
	if v == nil {
		return
	}
	return *v, true
}

// OldCostQueries returns the old "cost_queries" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldCostQueries(ctx context.Context) (v []types.QueryCondition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostQueries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostQueries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostQueries: %w", err)
	}
	return oldValue.CostQueries, nil
}

// AppendCostQueries adds tc to the "cost_queries" field.
func (m *PerspectiveMutation) AppendCostQueries(tc []types.QueryCondition) {
	m.appendcost_queries = append(m.appendcost_queries, tc...)
}

// AppendedCostQueries returns the list of values that were appended to the "cost_queries" field in this mutation.
func (m *PerspectiveMutation) AppendedCostQueries() ([]types.QueryCondition, bool) {
	if len(m.appendcost_queries) == 0 {
		return nil, false
	}
	return m.appendcost_queries, true
}

// ResetCostQueries resets all changes to the "cost_queries" field.
func (m *PerspectiveMutation) ResetCostQueries() {
	m.cost_queries = nil
	m.appendcost_queries = nil
}

// Where appends a list predicates to the PerspectiveMutation builder.
func (m *PerspectiveMutation) Where(ps ...predicate.Perspective) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PerspectiveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PerspectiveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Perspective, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PerspectiveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PerspectiveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Perspective).
func (m *PerspectiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PerspectiveMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, perspective.FieldName)
	}
	if m.description != nil {
		fields = append(fields, perspective.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, perspective.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, perspective.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, perspective.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, perspective.FieldUpdateTime)
	}
	if m.start_time != nil {
		fields = append(fields, perspective.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, perspective.FieldEndTime)
	}
	if m.builtin != nil {
		fields = append(fields, perspective.FieldBuiltin)
	}
	if m.cost_queries != nil {
		fields = append(fields, perspective.FieldCostQueries)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PerspectiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case perspective.FieldName:
		return m.Name()
	case perspective.FieldDescription:
		return m.Description()
	case perspective.FieldLabels:
		return m.Labels()
	case perspective.FieldAnnotations:
		return m.Annotations()
	case perspective.FieldCreateTime:
		return m.CreateTime()
	case perspective.FieldUpdateTime:
		return m.UpdateTime()
	case perspective.FieldStartTime:
		return m.StartTime()
	case perspective.FieldEndTime:
		return m.EndTime()
	case perspective.FieldBuiltin:
		return m.Builtin()
	case perspective.FieldCostQueries:
		return m.CostQueries()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PerspectiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case perspective.FieldName:
		return m.OldName(ctx)
	case perspective.FieldDescription:
		return m.OldDescription(ctx)
	case perspective.FieldLabels:
		return m.OldLabels(ctx)
	case perspective.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case perspective.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case perspective.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case perspective.FieldStartTime:
		return m.OldStartTime(ctx)
	case perspective.FieldEndTime:
		return m.OldEndTime(ctx)
	case perspective.FieldBuiltin:
		return m.OldBuiltin(ctx)
	case perspective.FieldCostQueries:
		return m.OldCostQueries(ctx)
	}
	return nil, fmt.Errorf("unknown Perspective field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PerspectiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case perspective.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case perspective.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case perspective.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case perspective.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case perspective.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case perspective.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case perspective.FieldStartTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case perspective.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case perspective.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	case perspective.FieldCostQueries:
		v, ok := value.([]types.QueryCondition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostQueries(v)
		return nil
	}
	return fmt.Errorf("unknown Perspective field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PerspectiveMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PerspectiveMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PerspectiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Perspective numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PerspectiveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(perspective.FieldDescription) {
		fields = append(fields, perspective.FieldDescription)
	}
	if m.FieldCleared(perspective.FieldLabels) {
		fields = append(fields, perspective.FieldLabels)
	}
	if m.FieldCleared(perspective.FieldAnnotations) {
		fields = append(fields, perspective.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PerspectiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PerspectiveMutation) ClearField(name string) error {
	switch name {
	case perspective.FieldDescription:
		m.ClearDescription()
		return nil
	case perspective.FieldLabels:
		m.ClearLabels()
		return nil
	case perspective.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Perspective nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PerspectiveMutation) ResetField(name string) error {
	switch name {
	case perspective.FieldName:
		m.ResetName()
		return nil
	case perspective.FieldDescription:
		m.ResetDescription()
		return nil
	case perspective.FieldLabels:
		m.ResetLabels()
		return nil
	case perspective.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case perspective.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case perspective.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case perspective.FieldStartTime:
		m.ResetStartTime()
		return nil
	case perspective.FieldEndTime:
		m.ResetEndTime()
		return nil
	case perspective.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	case perspective.FieldCostQueries:
		m.ResetCostQueries()
		return nil
	}
	return fmt.Errorf("unknown Perspective field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PerspectiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PerspectiveMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PerspectiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PerspectiveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PerspectiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PerspectiveMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PerspectiveMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Perspective unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PerspectiveMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Perspective edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                       Op
	typ                      string
	id                       *object.ID
	name                     *string
	description              *string
	labels                   *map[string]string
	annotations              *map[string]string
	create_time              *time.Time
	update_time              *time.Time
	clearedFields            map[string]struct{}
	environments             map[object.ID]struct{}
	removedenvironments      map[object.ID]struct{}
	clearedenvironments      bool
	connectors               map[object.ID]struct{}
	removedconnectors        map[object.ID]struct{}
	clearedconnectors        bool
	subject_roles            map[object.ID]struct{}
	removedsubject_roles     map[object.ID]struct{}
	clearedsubject_roles     bool
	services                 map[object.ID]struct{}
	removedservices          map[object.ID]struct{}
	clearedservices          bool
	service_resources        map[object.ID]struct{}
	removedservice_resources map[object.ID]struct{}
	clearedservice_resources bool
	service_revisions        map[object.ID]struct{}
	removedservice_revisions map[object.ID]struct{}
	clearedservice_revisions bool
	variables                map[object.ID]struct{}
	removedvariables         map[object.ID]struct{}
	clearedvariables         bool
	templates                map[object.ID]struct{}
	removedtemplates         map[object.ID]struct{}
	clearedtemplates         bool
	template_versions        map[object.ID]struct{}
	removedtemplate_versions map[object.ID]struct{}
	clearedtemplate_versions bool
	catalogs                 map[object.ID]struct{}
	removedcatalogs          map[object.ID]struct{}
	clearedcatalogs          bool
	done                     bool
	oldValue                 func(context.Context) (*Project, error)
	predicates               []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id object.ID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ProjectMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ProjectMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ProjectMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[project.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ProjectMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[project.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ProjectMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, project.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ProjectMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ProjectMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ProjectMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[project.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ProjectMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[project.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ProjectMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, project.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *ProjectMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProjectMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProjectMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProjectMutation) ResetUpdateTime() {
	m.update_time = nil
}

// AddEnvironmentIDs adds the "environments" edge to the Environment entity by ids.
func (m *ProjectMutation) AddEnvironmentIDs(ids ...object.ID) {
	if m.environments == nil {
		m.environments = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "environments" edge to the Environment entity.
func (m *ProjectMutation) ClearEnvironments() {
	m.clearedenvironments = true
}

// EnvironmentsCleared reports if the "environments" edge to the Environment entity was cleared.
func (m *ProjectMutation) EnvironmentsCleared() bool {
	return m.clearedenvironments
}

// RemoveEnvironmentIDs removes the "environments" edge to the Environment entity by IDs.
func (m *ProjectMutation) RemoveEnvironmentIDs(ids ...object.ID) {
	if m.removedenvironments == nil {
		m.removedenvironments = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.environments, ids[i])
		m.removedenvironments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "environments" edge to the Environment entity.
func (m *ProjectMutation) RemovedEnvironmentsIDs() (ids []object.ID) {
	for id := range m.removedenvironments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "environments" edge IDs in the mutation.
func (m *ProjectMutation) EnvironmentsIDs() (ids []object.ID) {
	for id := range m.environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "environments" edge.
func (m *ProjectMutation) ResetEnvironments() {
	m.environments = nil
	m.clearedenvironments = false
	m.removedenvironments = nil
}

// AddConnectorIDs adds the "connectors" edge to the Connector entity by ids.
func (m *ProjectMutation) AddConnectorIDs(ids ...object.ID) {
	if m.connectors == nil {
		m.connectors = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.connectors[ids[i]] = struct{}{}
	}
}

// ClearConnectors clears the "connectors" edge to the Connector entity.
func (m *ProjectMutation) ClearConnectors() {
	m.clearedconnectors = true
}

// ConnectorsCleared reports if the "connectors" edge to the Connector entity was cleared.
func (m *ProjectMutation) ConnectorsCleared() bool {
	return m.clearedconnectors
}

// RemoveConnectorIDs removes the "connectors" edge to the Connector entity by IDs.
func (m *ProjectMutation) RemoveConnectorIDs(ids ...object.ID) {
	if m.removedconnectors == nil {
		m.removedconnectors = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.connectors, ids[i])
		m.removedconnectors[ids[i]] = struct{}{}
	}
}

// RemovedConnectors returns the removed IDs of the "connectors" edge to the Connector entity.
func (m *ProjectMutation) RemovedConnectorsIDs() (ids []object.ID) {
	for id := range m.removedconnectors {
		ids = append(ids, id)
	}
	return
}

// ConnectorsIDs returns the "connectors" edge IDs in the mutation.
func (m *ProjectMutation) ConnectorsIDs() (ids []object.ID) {
	for id := range m.connectors {
		ids = append(ids, id)
	}
	return
}

// ResetConnectors resets all changes to the "connectors" edge.
func (m *ProjectMutation) ResetConnectors() {
	m.connectors = nil
	m.clearedconnectors = false
	m.removedconnectors = nil
}

// AddSubjectRoleIDs adds the "subject_roles" edge to the SubjectRoleRelationship entity by ids.
func (m *ProjectMutation) AddSubjectRoleIDs(ids ...object.ID) {
	if m.subject_roles == nil {
		m.subject_roles = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.subject_roles[ids[i]] = struct{}{}
	}
}

// ClearSubjectRoles clears the "subject_roles" edge to the SubjectRoleRelationship entity.
func (m *ProjectMutation) ClearSubjectRoles() {
	m.clearedsubject_roles = true
}

// SubjectRolesCleared reports if the "subject_roles" edge to the SubjectRoleRelationship entity was cleared.
func (m *ProjectMutation) SubjectRolesCleared() bool {
	return m.clearedsubject_roles
}

// RemoveSubjectRoleIDs removes the "subject_roles" edge to the SubjectRoleRelationship entity by IDs.
func (m *ProjectMutation) RemoveSubjectRoleIDs(ids ...object.ID) {
	if m.removedsubject_roles == nil {
		m.removedsubject_roles = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.subject_roles, ids[i])
		m.removedsubject_roles[ids[i]] = struct{}{}
	}
}

// RemovedSubjectRoles returns the removed IDs of the "subject_roles" edge to the SubjectRoleRelationship entity.
func (m *ProjectMutation) RemovedSubjectRolesIDs() (ids []object.ID) {
	for id := range m.removedsubject_roles {
		ids = append(ids, id)
	}
	return
}

// SubjectRolesIDs returns the "subject_roles" edge IDs in the mutation.
func (m *ProjectMutation) SubjectRolesIDs() (ids []object.ID) {
	for id := range m.subject_roles {
		ids = append(ids, id)
	}
	return
}

// ResetSubjectRoles resets all changes to the "subject_roles" edge.
func (m *ProjectMutation) ResetSubjectRoles() {
	m.subject_roles = nil
	m.clearedsubject_roles = false
	m.removedsubject_roles = nil
}

// AddServiceIDs adds the "services" edge to the Service entity by ids.
func (m *ProjectMutation) AddServiceIDs(ids ...object.ID) {
	if m.services == nil {
		m.services = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Service entity.
func (m *ProjectMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *ProjectMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Service entity by IDs.
func (m *ProjectMutation) RemoveServiceIDs(ids ...object.ID) {
	if m.removedservices == nil {
		m.removedservices = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Service entity.
func (m *ProjectMutation) RemovedServicesIDs() (ids []object.ID) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *ProjectMutation) ServicesIDs() (ids []object.ID) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *ProjectMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// AddServiceResourceIDs adds the "service_resources" edge to the ServiceResource entity by ids.
func (m *ProjectMutation) AddServiceResourceIDs(ids ...object.ID) {
	if m.service_resources == nil {
		m.service_resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.service_resources[ids[i]] = struct{}{}
	}
}

// ClearServiceResources clears the "service_resources" edge to the ServiceResource entity.
func (m *ProjectMutation) ClearServiceResources() {
	m.clearedservice_resources = true
}

// ServiceResourcesCleared reports if the "service_resources" edge to the ServiceResource entity was cleared.
func (m *ProjectMutation) ServiceResourcesCleared() bool {
	return m.clearedservice_resources
}

// RemoveServiceResourceIDs removes the "service_resources" edge to the ServiceResource entity by IDs.
func (m *ProjectMutation) RemoveServiceResourceIDs(ids ...object.ID) {
	if m.removedservice_resources == nil {
		m.removedservice_resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.service_resources, ids[i])
		m.removedservice_resources[ids[i]] = struct{}{}
	}
}

// RemovedServiceResources returns the removed IDs of the "service_resources" edge to the ServiceResource entity.
func (m *ProjectMutation) RemovedServiceResourcesIDs() (ids []object.ID) {
	for id := range m.removedservice_resources {
		ids = append(ids, id)
	}
	return
}

// ServiceResourcesIDs returns the "service_resources" edge IDs in the mutation.
func (m *ProjectMutation) ServiceResourcesIDs() (ids []object.ID) {
	for id := range m.service_resources {
		ids = append(ids, id)
	}
	return
}

// ResetServiceResources resets all changes to the "service_resources" edge.
func (m *ProjectMutation) ResetServiceResources() {
	m.service_resources = nil
	m.clearedservice_resources = false
	m.removedservice_resources = nil
}

// AddServiceRevisionIDs adds the "service_revisions" edge to the ServiceRevision entity by ids.
func (m *ProjectMutation) AddServiceRevisionIDs(ids ...object.ID) {
	if m.service_revisions == nil {
		m.service_revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.service_revisions[ids[i]] = struct{}{}
	}
}

// ClearServiceRevisions clears the "service_revisions" edge to the ServiceRevision entity.
func (m *ProjectMutation) ClearServiceRevisions() {
	m.clearedservice_revisions = true
}

// ServiceRevisionsCleared reports if the "service_revisions" edge to the ServiceRevision entity was cleared.
func (m *ProjectMutation) ServiceRevisionsCleared() bool {
	return m.clearedservice_revisions
}

// RemoveServiceRevisionIDs removes the "service_revisions" edge to the ServiceRevision entity by IDs.
func (m *ProjectMutation) RemoveServiceRevisionIDs(ids ...object.ID) {
	if m.removedservice_revisions == nil {
		m.removedservice_revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.service_revisions, ids[i])
		m.removedservice_revisions[ids[i]] = struct{}{}
	}
}

// RemovedServiceRevisions returns the removed IDs of the "service_revisions" edge to the ServiceRevision entity.
func (m *ProjectMutation) RemovedServiceRevisionsIDs() (ids []object.ID) {
	for id := range m.removedservice_revisions {
		ids = append(ids, id)
	}
	return
}

// ServiceRevisionsIDs returns the "service_revisions" edge IDs in the mutation.
func (m *ProjectMutation) ServiceRevisionsIDs() (ids []object.ID) {
	for id := range m.service_revisions {
		ids = append(ids, id)
	}
	return
}

// ResetServiceRevisions resets all changes to the "service_revisions" edge.
func (m *ProjectMutation) ResetServiceRevisions() {
	m.service_revisions = nil
	m.clearedservice_revisions = false
	m.removedservice_revisions = nil
}

// AddVariableIDs adds the "variables" edge to the Variable entity by ids.
func (m *ProjectMutation) AddVariableIDs(ids ...object.ID) {
	if m.variables == nil {
		m.variables = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.variables[ids[i]] = struct{}{}
	}
}

// ClearVariables clears the "variables" edge to the Variable entity.
func (m *ProjectMutation) ClearVariables() {
	m.clearedvariables = true
}

// VariablesCleared reports if the "variables" edge to the Variable entity was cleared.
func (m *ProjectMutation) VariablesCleared() bool {
	return m.clearedvariables
}

// RemoveVariableIDs removes the "variables" edge to the Variable entity by IDs.
func (m *ProjectMutation) RemoveVariableIDs(ids ...object.ID) {
	if m.removedvariables == nil {
		m.removedvariables = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.variables, ids[i])
		m.removedvariables[ids[i]] = struct{}{}
	}
}

// RemovedVariables returns the removed IDs of the "variables" edge to the Variable entity.
func (m *ProjectMutation) RemovedVariablesIDs() (ids []object.ID) {
	for id := range m.removedvariables {
		ids = append(ids, id)
	}
	return
}

// VariablesIDs returns the "variables" edge IDs in the mutation.
func (m *ProjectMutation) VariablesIDs() (ids []object.ID) {
	for id := range m.variables {
		ids = append(ids, id)
	}
	return
}

// ResetVariables resets all changes to the "variables" edge.
func (m *ProjectMutation) ResetVariables() {
	m.variables = nil
	m.clearedvariables = false
	m.removedvariables = nil
}

// AddTemplateIDs adds the "templates" edge to the Template entity by ids.
func (m *ProjectMutation) AddTemplateIDs(ids ...object.ID) {
	if m.templates == nil {
		m.templates = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the "templates" edge to the Template entity.
func (m *ProjectMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared reports if the "templates" edge to the Template entity was cleared.
func (m *ProjectMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the "templates" edge to the Template entity by IDs.
func (m *ProjectMutation) RemoveTemplateIDs(ids ...object.ID) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.templates, ids[i])
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed IDs of the "templates" edge to the Template entity.
func (m *ProjectMutation) RemovedTemplatesIDs() (ids []object.ID) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the "templates" edge IDs in the mutation.
func (m *ProjectMutation) TemplatesIDs() (ids []object.ID) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates resets all changes to the "templates" edge.
func (m *ProjectMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// AddTemplateVersionIDs adds the "template_versions" edge to the TemplateVersion entity by ids.
func (m *ProjectMutation) AddTemplateVersionIDs(ids ...object.ID) {
	if m.template_versions == nil {
		m.template_versions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.template_versions[ids[i]] = struct{}{}
	}
}

// ClearTemplateVersions clears the "template_versions" edge to the TemplateVersion entity.
func (m *ProjectMutation) ClearTemplateVersions() {
	m.clearedtemplate_versions = true
}

// TemplateVersionsCleared reports if the "template_versions" edge to the TemplateVersion entity was cleared.
func (m *ProjectMutation) TemplateVersionsCleared() bool {
	return m.clearedtemplate_versions
}

// RemoveTemplateVersionIDs removes the "template_versions" edge to the TemplateVersion entity by IDs.
func (m *ProjectMutation) RemoveTemplateVersionIDs(ids ...object.ID) {
	if m.removedtemplate_versions == nil {
		m.removedtemplate_versions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.template_versions, ids[i])
		m.removedtemplate_versions[ids[i]] = struct{}{}
	}
}

// RemovedTemplateVersions returns the removed IDs of the "template_versions" edge to the TemplateVersion entity.
func (m *ProjectMutation) RemovedTemplateVersionsIDs() (ids []object.ID) {
	for id := range m.removedtemplate_versions {
		ids = append(ids, id)
	}
	return
}

// TemplateVersionsIDs returns the "template_versions" edge IDs in the mutation.
func (m *ProjectMutation) TemplateVersionsIDs() (ids []object.ID) {
	for id := range m.template_versions {
		ids = append(ids, id)
	}
	return
}

// ResetTemplateVersions resets all changes to the "template_versions" edge.
func (m *ProjectMutation) ResetTemplateVersions() {
	m.template_versions = nil
	m.clearedtemplate_versions = false
	m.removedtemplate_versions = nil
}

// AddCatalogIDs adds the "catalogs" edge to the Catalog entity by ids.
func (m *ProjectMutation) AddCatalogIDs(ids ...object.ID) {
	if m.catalogs == nil {
		m.catalogs = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.catalogs[ids[i]] = struct{}{}
	}
}

// ClearCatalogs clears the "catalogs" edge to the Catalog entity.
func (m *ProjectMutation) ClearCatalogs() {
	m.clearedcatalogs = true
}

// CatalogsCleared reports if the "catalogs" edge to the Catalog entity was cleared.
func (m *ProjectMutation) CatalogsCleared() bool {
	return m.clearedcatalogs
}

// RemoveCatalogIDs removes the "catalogs" edge to the Catalog entity by IDs.
func (m *ProjectMutation) RemoveCatalogIDs(ids ...object.ID) {
	if m.removedcatalogs == nil {
		m.removedcatalogs = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.catalogs, ids[i])
		m.removedcatalogs[ids[i]] = struct{}{}
	}
}

// RemovedCatalogs returns the removed IDs of the "catalogs" edge to the Catalog entity.
func (m *ProjectMutation) RemovedCatalogsIDs() (ids []object.ID) {
	for id := range m.removedcatalogs {
		ids = append(ids, id)
	}
	return
}

// CatalogsIDs returns the "catalogs" edge IDs in the mutation.
func (m *ProjectMutation) CatalogsIDs() (ids []object.ID) {
	for id := range m.catalogs {
		ids = append(ids, id)
	}
	return
}

// ResetCatalogs resets all changes to the "catalogs" edge.
func (m *ProjectMutation) ResetCatalogs() {
	m.catalogs = nil
	m.clearedcatalogs = false
	m.removedcatalogs = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, project.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, project.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, project.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, project.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldLabels:
		return m.Labels()
	case project.FieldAnnotations:
		return m.Annotations()
	case project.FieldCreateTime:
		return m.CreateTime()
	case project.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldLabels:
		return m.OldLabels(ctx)
	case project.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case project.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case project.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case project.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case project.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case project.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldLabels) {
		fields = append(fields, project.FieldLabels)
	}
	if m.FieldCleared(project.FieldAnnotations) {
		fields = append(fields, project.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldLabels:
		m.ClearLabels()
		return nil
	case project.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldLabels:
		m.ResetLabels()
		return nil
	case project.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case project.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case project.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.environments != nil {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.connectors != nil {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.subject_roles != nil {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.services != nil {
		edges = append(edges, project.EdgeServices)
	}
	if m.service_resources != nil {
		edges = append(edges, project.EdgeServiceResources)
	}
	if m.service_revisions != nil {
		edges = append(edges, project.EdgeServiceRevisions)
	}
	if m.variables != nil {
		edges = append(edges, project.EdgeVariables)
	}
	if m.templates != nil {
		edges = append(edges, project.EdgeTemplates)
	}
	if m.template_versions != nil {
		edges = append(edges, project.EdgeTemplateVersions)
	}
	if m.catalogs != nil {
		edges = append(edges, project.EdgeCatalogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.environments))
		for id := range m.environments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.connectors))
		for id := range m.connectors {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSubjectRoles:
		ids := make([]ent.Value, 0, len(m.subject_roles))
		for id := range m.subject_roles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServiceResources:
		ids := make([]ent.Value, 0, len(m.service_resources))
		for id := range m.service_resources {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServiceRevisions:
		ids := make([]ent.Value, 0, len(m.service_revisions))
		for id := range m.service_revisions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeVariables:
		ids := make([]ent.Value, 0, len(m.variables))
		for id := range m.variables {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplateVersions:
		ids := make([]ent.Value, 0, len(m.template_versions))
		for id := range m.template_versions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCatalogs:
		ids := make([]ent.Value, 0, len(m.catalogs))
		for id := range m.catalogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedenvironments != nil {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.removedconnectors != nil {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.removedsubject_roles != nil {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.removedservices != nil {
		edges = append(edges, project.EdgeServices)
	}
	if m.removedservice_resources != nil {
		edges = append(edges, project.EdgeServiceResources)
	}
	if m.removedservice_revisions != nil {
		edges = append(edges, project.EdgeServiceRevisions)
	}
	if m.removedvariables != nil {
		edges = append(edges, project.EdgeVariables)
	}
	if m.removedtemplates != nil {
		edges = append(edges, project.EdgeTemplates)
	}
	if m.removedtemplate_versions != nil {
		edges = append(edges, project.EdgeTemplateVersions)
	}
	if m.removedcatalogs != nil {
		edges = append(edges, project.EdgeCatalogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removedenvironments))
		for id := range m.removedenvironments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.removedconnectors))
		for id := range m.removedconnectors {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSubjectRoles:
		ids := make([]ent.Value, 0, len(m.removedsubject_roles))
		for id := range m.removedsubject_roles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServiceResources:
		ids := make([]ent.Value, 0, len(m.removedservice_resources))
		for id := range m.removedservice_resources {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServiceRevisions:
		ids := make([]ent.Value, 0, len(m.removedservice_revisions))
		for id := range m.removedservice_revisions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeVariables:
		ids := make([]ent.Value, 0, len(m.removedvariables))
		for id := range m.removedvariables {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplateVersions:
		ids := make([]ent.Value, 0, len(m.removedtemplate_versions))
		for id := range m.removedtemplate_versions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCatalogs:
		ids := make([]ent.Value, 0, len(m.removedcatalogs))
		for id := range m.removedcatalogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedenvironments {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.clearedconnectors {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.clearedsubject_roles {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.clearedservices {
		edges = append(edges, project.EdgeServices)
	}
	if m.clearedservice_resources {
		edges = append(edges, project.EdgeServiceResources)
	}
	if m.clearedservice_revisions {
		edges = append(edges, project.EdgeServiceRevisions)
	}
	if m.clearedvariables {
		edges = append(edges, project.EdgeVariables)
	}
	if m.clearedtemplates {
		edges = append(edges, project.EdgeTemplates)
	}
	if m.clearedtemplate_versions {
		edges = append(edges, project.EdgeTemplateVersions)
	}
	if m.clearedcatalogs {
		edges = append(edges, project.EdgeCatalogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeEnvironments:
		return m.clearedenvironments
	case project.EdgeConnectors:
		return m.clearedconnectors
	case project.EdgeSubjectRoles:
		return m.clearedsubject_roles
	case project.EdgeServices:
		return m.clearedservices
	case project.EdgeServiceResources:
		return m.clearedservice_resources
	case project.EdgeServiceRevisions:
		return m.clearedservice_revisions
	case project.EdgeVariables:
		return m.clearedvariables
	case project.EdgeTemplates:
		return m.clearedtemplates
	case project.EdgeTemplateVersions:
		return m.clearedtemplate_versions
	case project.EdgeCatalogs:
		return m.clearedcatalogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case project.EdgeConnectors:
		m.ResetConnectors()
		return nil
	case project.EdgeSubjectRoles:
		m.ResetSubjectRoles()
		return nil
	case project.EdgeServices:
		m.ResetServices()
		return nil
	case project.EdgeServiceResources:
		m.ResetServiceResources()
		return nil
	case project.EdgeServiceRevisions:
		m.ResetServiceRevisions()
		return nil
	case project.EdgeVariables:
		m.ResetVariables()
		return nil
	case project.EdgeTemplates:
		m.ResetTemplates()
		return nil
	case project.EdgeTemplateVersions:
		m.ResetTemplateVersions()
		return nil
	case project.EdgeCatalogs:
		m.ResetCatalogs()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *string
	create_time                        *time.Time
	update_time                        *time.Time
	kind                               *string
	description                        *string
	policies                           *types.RolePolicies
	appendpolicies                     types.RolePolicies
	applicable_environment_types       *[]string
	appendapplicable_environment_types []string
	session                            *bool
	builtin                            *bool
	clearedFields                      map[string]struct{}
	subjects                           map[object.ID]struct{}
	removedsubjects                    map[object.ID]struct{}
	clearedsubjects                    bool
	done                               bool
	oldValue                           func(context.Context) (*Role, error)
	predicates                         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id string) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetKind sets the "kind" field.
func (m *RoleMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *RoleMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *RoleMutation) ResetKind() {
	m.kind = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetPolicies sets the "policies" field.
func (m *RoleMutation) SetPolicies(tp types.RolePolicies) {
	m.policies = &tp
	m.appendpolicies = nil
}

// Policies returns the value of the "policies" field in the mutation.
func (m *RoleMutation) Policies() (r types.RolePolicies, exists bool) {
	v := m.policies
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicies returns the old "policies" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPolicies(ctx context.Context) (v types.RolePolicies, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicies: %w", err)
	}
	return oldValue.Policies, nil
}

// AppendPolicies adds tp to the "policies" field.
func (m *RoleMutation) AppendPolicies(tp types.RolePolicies) {
	m.appendpolicies = append(m.appendpolicies, tp...)
}

// AppendedPolicies returns the list of values that were appended to the "policies" field in this mutation.
func (m *RoleMutation) AppendedPolicies() (types.RolePolicies, bool) {
	if len(m.appendpolicies) == 0 {
		return nil, false
	}
	return m.appendpolicies, true
}

// ResetPolicies resets all changes to the "policies" field.
func (m *RoleMutation) ResetPolicies() {
	m.policies = nil
	m.appendpolicies = nil
}

// SetApplicableEnvironmentTypes sets the "applicable_environment_types" field.
func (m *RoleMutation) SetApplicableEnvironmentTypes(s []string) {
	m.applicable_environment_types = &s
	m.appendapplicable_environment_types = nil
}

// ApplicableEnvironmentTypes returns the value of the "applicable_environment_types" field in the mutation.
func (m *RoleMutation) ApplicableEnvironmentTypes() (r []string, exists bool) {
	v := m.applicable_environment_types
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicableEnvironmentTypes returns the old "applicable_environment_types" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApplicableEnvironmentTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicableEnvironmentTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicableEnvironmentTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicableEnvironmentTypes: %w", err)
	}
	return oldValue.ApplicableEnvironmentTypes, nil
}

// AppendApplicableEnvironmentTypes adds s to the "applicable_environment_types" field.
func (m *RoleMutation) AppendApplicableEnvironmentTypes(s []string) {
	m.appendapplicable_environment_types = append(m.appendapplicable_environment_types, s...)
}

// AppendedApplicableEnvironmentTypes returns the list of values that were appended to the "applicable_environment_types" field in this mutation.
func (m *RoleMutation) AppendedApplicableEnvironmentTypes() ([]string, bool) {
	if len(m.appendapplicable_environment_types) == 0 {
		return nil, false
	}
	return m.appendapplicable_environment_types, true
}

// ClearApplicableEnvironmentTypes clears the value of the "applicable_environment_types" field.
func (m *RoleMutation) ClearApplicableEnvironmentTypes() {
	m.applicable_environment_types = nil
	m.appendapplicable_environment_types = nil
	m.clearedFields[role.FieldApplicableEnvironmentTypes] = struct{}{}
}

// ApplicableEnvironmentTypesCleared returns if the "applicable_environment_types" field was cleared in this mutation.
func (m *RoleMutation) ApplicableEnvironmentTypesCleared() bool {
	_, ok := m.clearedFields[role.FieldApplicableEnvironmentTypes]
	return ok
}

// ResetApplicableEnvironmentTypes resets all changes to the "applicable_environment_types" field.
func (m *RoleMutation) ResetApplicableEnvironmentTypes() {
	m.applicable_environment_types = nil
	m.appendapplicable_environment_types = nil
	delete(m.clearedFields, role.FieldApplicableEnvironmentTypes)
}

// SetSession sets the "session" field.
func (m *RoleMutation) SetSession(b bool) {
	m.session = &b
}

// Session returns the value of the "session" field in the mutation.
func (m *RoleMutation) Session() (r bool, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSession returns the old "session" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSession(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSession is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSession requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSession: %w", err)
	}
	return oldValue.Session, nil
}

// ResetSession resets all changes to the "session" field.
func (m *RoleMutation) ResetSession() {
	m.session = nil
}

// SetBuiltin sets the "builtin" field.
func (m *RoleMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *RoleMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *RoleMutation) ResetBuiltin() {
	m.builtin = nil
}

// AddSubjectIDs adds the "subjects" edge to the SubjectRoleRelationship entity by ids.
func (m *RoleMutation) AddSubjectIDs(ids ...object.ID) {
	if m.subjects == nil {
		m.subjects = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the SubjectRoleRelationship entity.
func (m *RoleMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the SubjectRoleRelationship entity was cleared.
func (m *RoleMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the SubjectRoleRelationship entity by IDs.
func (m *RoleMutation) RemoveSubjectIDs(ids ...object.ID) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the SubjectRoleRelationship entity.
func (m *RoleMutation) RemovedSubjectsIDs() (ids []object.ID) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *RoleMutation) SubjectsIDs() (ids []object.ID) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *RoleMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, role.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, role.FieldUpdateTime)
	}
	if m.kind != nil {
		fields = append(fields, role.FieldKind)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.policies != nil {
		fields = append(fields, role.FieldPolicies)
	}
	if m.applicable_environment_types != nil {
		fields = append(fields, role.FieldApplicableEnvironmentTypes)
	}
	if m.session != nil {
		fields = append(fields, role.FieldSession)
	}
	if m.builtin != nil {
		fields = append(fields, role.FieldBuiltin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreateTime:
		return m.CreateTime()
	case role.FieldUpdateTime:
		return m.UpdateTime()
	case role.FieldKind:
		return m.Kind()
	case role.FieldDescription:
		return m.Description()
	case role.FieldPolicies:
		return m.Policies()
	case role.FieldApplicableEnvironmentTypes:
		return m.ApplicableEnvironmentTypes()
	case role.FieldSession:
		return m.Session()
	case role.FieldBuiltin:
		return m.Builtin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case role.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case role.FieldKind:
		return m.OldKind(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldPolicies:
		return m.OldPolicies(ctx)
	case role.FieldApplicableEnvironmentTypes:
		return m.OldApplicableEnvironmentTypes(ctx)
	case role.FieldSession:
		return m.OldSession(ctx)
	case role.FieldBuiltin:
		return m.OldBuiltin(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case role.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case role.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldPolicies:
		v, ok := value.(types.RolePolicies)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicies(v)
		return nil
	case role.FieldApplicableEnvironmentTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicableEnvironmentTypes(v)
		return nil
	case role.FieldSession:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSession(v)
		return nil
	case role.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldApplicableEnvironmentTypes) {
		fields = append(fields, role.FieldApplicableEnvironmentTypes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldApplicableEnvironmentTypes:
		m.ClearApplicableEnvironmentTypes()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case role.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case role.FieldKind:
		m.ResetKind()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldPolicies:
		m.ResetPolicies()
		return nil
	case role.FieldApplicableEnvironmentTypes:
		m.ResetApplicableEnvironmentTypes()
		return nil
	case role.FieldSession:
		m.ResetSession()
		return nil
	case role.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subjects != nil {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubjects != nil {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubjects {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeSubjects:
		return m.clearedsubjects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeSubjects:
		m.ResetSubjects()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *object.ID
	name                *string
	description         *string
	labels              *map[string]string
	annotations         *map[string]string
	create_time         *time.Time
	update_time         *time.Time
	status              *status.Status
	attributes          *property.Values
	clearedFields       map[string]struct{}
	project             *object.ID
	clearedproject      bool
	environment         *object.ID
	clearedenvironment  bool
	template            *object.ID
	clearedtemplate     bool
	revisions           map[object.ID]struct{}
	removedrevisions    map[object.ID]struct{}
	clearedrevisions    bool
	resources           map[object.ID]struct{}
	removedresources    map[object.ID]struct{}
	clearedresources    bool
	dependencies        map[object.ID]struct{}
	removeddependencies map[object.ID]struct{}
	cleareddependencies bool
	done                bool
	oldValue            func(context.Context) (*Service, error)
	predicates          []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id object.ID) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Service entities.
func (m *ServiceMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServiceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[service.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[service.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, service.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ServiceMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ServiceMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ServiceMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[service.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ServiceMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[service.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ServiceMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, service.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ServiceMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ServiceMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ServiceMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[service.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ServiceMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[service.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ServiceMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, service.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *ServiceMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ServiceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[service.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ServiceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[service.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, service.FieldStatus)
}

// SetProjectID sets the "project_id" field.
func (m *ServiceMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ServiceMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ServiceMutation) ResetProjectID() {
	m.project = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *ServiceMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *ServiceMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *ServiceMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetTemplateID sets the "template_id" field.
func (m *ServiceMutation) SetTemplateID(o object.ID) {
	m.template = &o
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *ServiceMutation) TemplateID() (r object.ID, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldTemplateID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *ServiceMutation) ResetTemplateID() {
	m.template = nil
}

// SetAttributes sets the "attributes" field.
func (m *ServiceMutation) SetAttributes(pr property.Values) {
	m.attributes = &pr
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ServiceMutation) Attributes() (r property.Values, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldAttributes(ctx context.Context) (v property.Values, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ServiceMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[service.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ServiceMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[service.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ServiceMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, service.FieldAttributes)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ServiceMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ServiceMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ServiceMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *ServiceMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *ServiceMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *ServiceMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearTemplate clears the "template" edge to the TemplateVersion entity.
func (m *ServiceMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared reports if the "template" edge to the TemplateVersion entity was cleared.
func (m *ServiceMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) TemplateIDs() (ids []object.ID) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *ServiceMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// AddRevisionIDs adds the "revisions" edge to the ServiceRevision entity by ids.
func (m *ServiceMutation) AddRevisionIDs(ids ...object.ID) {
	if m.revisions == nil {
		m.revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.revisions[ids[i]] = struct{}{}
	}
}

// ClearRevisions clears the "revisions" edge to the ServiceRevision entity.
func (m *ServiceMutation) ClearRevisions() {
	m.clearedrevisions = true
}

// RevisionsCleared reports if the "revisions" edge to the ServiceRevision entity was cleared.
func (m *ServiceMutation) RevisionsCleared() bool {
	return m.clearedrevisions
}

// RemoveRevisionIDs removes the "revisions" edge to the ServiceRevision entity by IDs.
func (m *ServiceMutation) RemoveRevisionIDs(ids ...object.ID) {
	if m.removedrevisions == nil {
		m.removedrevisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.revisions, ids[i])
		m.removedrevisions[ids[i]] = struct{}{}
	}
}

// RemovedRevisions returns the removed IDs of the "revisions" edge to the ServiceRevision entity.
func (m *ServiceMutation) RemovedRevisionsIDs() (ids []object.ID) {
	for id := range m.removedrevisions {
		ids = append(ids, id)
	}
	return
}

// RevisionsIDs returns the "revisions" edge IDs in the mutation.
func (m *ServiceMutation) RevisionsIDs() (ids []object.ID) {
	for id := range m.revisions {
		ids = append(ids, id)
	}
	return
}

// ResetRevisions resets all changes to the "revisions" edge.
func (m *ServiceMutation) ResetRevisions() {
	m.revisions = nil
	m.clearedrevisions = false
	m.removedrevisions = nil
}

// AddResourceIDs adds the "resources" edge to the ServiceResource entity by ids.
func (m *ServiceMutation) AddResourceIDs(ids ...object.ID) {
	if m.resources == nil {
		m.resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the ServiceResource entity.
func (m *ServiceMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the ServiceResource entity was cleared.
func (m *ServiceMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the ServiceResource entity by IDs.
func (m *ServiceMutation) RemoveResourceIDs(ids ...object.ID) {
	if m.removedresources == nil {
		m.removedresources = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the ServiceResource entity.
func (m *ServiceMutation) RemovedResourcesIDs() (ids []object.ID) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *ServiceMutation) ResourcesIDs() (ids []object.ID) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *ServiceMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddDependencyIDs adds the "dependencies" edge to the ServiceRelationship entity by ids.
func (m *ServiceMutation) AddDependencyIDs(ids ...object.ID) {
	if m.dependencies == nil {
		m.dependencies = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the ServiceRelationship entity.
func (m *ServiceMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the ServiceRelationship entity was cleared.
func (m *ServiceMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the ServiceRelationship entity by IDs.
func (m *ServiceMutation) RemoveDependencyIDs(ids ...object.ID) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the ServiceRelationship entity.
func (m *ServiceMutation) RemovedDependenciesIDs() (ids []object.ID) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ServiceMutation) DependenciesIDs() (ids []object.ID) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ServiceMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Service, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.description != nil {
		fields = append(fields, service.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, service.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, service.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, service.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, service.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, service.FieldStatus)
	}
	if m.project != nil {
		fields = append(fields, service.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, service.FieldEnvironmentID)
	}
	if m.template != nil {
		fields = append(fields, service.FieldTemplateID)
	}
	if m.attributes != nil {
		fields = append(fields, service.FieldAttributes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldName:
		return m.Name()
	case service.FieldDescription:
		return m.Description()
	case service.FieldLabels:
		return m.Labels()
	case service.FieldAnnotations:
		return m.Annotations()
	case service.FieldCreateTime:
		return m.CreateTime()
	case service.FieldUpdateTime:
		return m.UpdateTime()
	case service.FieldStatus:
		return m.Status()
	case service.FieldProjectID:
		return m.ProjectID()
	case service.FieldEnvironmentID:
		return m.EnvironmentID()
	case service.FieldTemplateID:
		return m.TemplateID()
	case service.FieldAttributes:
		return m.Attributes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldDescription:
		return m.OldDescription(ctx)
	case service.FieldLabels:
		return m.OldLabels(ctx)
	case service.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case service.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case service.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case service.FieldStatus:
		return m.OldStatus(ctx)
	case service.FieldProjectID:
		return m.OldProjectID(ctx)
	case service.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case service.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case service.FieldAttributes:
		return m.OldAttributes(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case service.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case service.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case service.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case service.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case service.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case service.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case service.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case service.FieldTemplateID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case service.FieldAttributes:
		v, ok := value.(property.Values)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(service.FieldDescription) {
		fields = append(fields, service.FieldDescription)
	}
	if m.FieldCleared(service.FieldLabels) {
		fields = append(fields, service.FieldLabels)
	}
	if m.FieldCleared(service.FieldAnnotations) {
		fields = append(fields, service.FieldAnnotations)
	}
	if m.FieldCleared(service.FieldStatus) {
		fields = append(fields, service.FieldStatus)
	}
	if m.FieldCleared(service.FieldAttributes) {
		fields = append(fields, service.FieldAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	switch name {
	case service.FieldDescription:
		m.ClearDescription()
		return nil
	case service.FieldLabels:
		m.ClearLabels()
		return nil
	case service.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case service.FieldStatus:
		m.ClearStatus()
		return nil
	case service.FieldAttributes:
		m.ClearAttributes()
		return nil
	}
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldDescription:
		m.ResetDescription()
		return nil
	case service.FieldLabels:
		m.ResetLabels()
		return nil
	case service.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case service.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case service.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case service.FieldStatus:
		m.ResetStatus()
		return nil
	case service.FieldProjectID:
		m.ResetProjectID()
		return nil
	case service.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case service.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case service.FieldAttributes:
		m.ResetAttributes()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.project != nil {
		edges = append(edges, service.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, service.EdgeEnvironment)
	}
	if m.template != nil {
		edges = append(edges, service.EdgeTemplate)
	}
	if m.revisions != nil {
		edges = append(edges, service.EdgeRevisions)
	}
	if m.resources != nil {
		edges = append(edges, service.EdgeResources)
	}
	if m.dependencies != nil {
		edges = append(edges, service.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.revisions))
		for id := range m.revisions {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedrevisions != nil {
		edges = append(edges, service.EdgeRevisions)
	}
	if m.removedresources != nil {
		edges = append(edges, service.EdgeResources)
	}
	if m.removeddependencies != nil {
		edges = append(edges, service.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.removedrevisions))
		for id := range m.removedrevisions {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedproject {
		edges = append(edges, service.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, service.EdgeEnvironment)
	}
	if m.clearedtemplate {
		edges = append(edges, service.EdgeTemplate)
	}
	if m.clearedrevisions {
		edges = append(edges, service.EdgeRevisions)
	}
	if m.clearedresources {
		edges = append(edges, service.EdgeResources)
	}
	if m.cleareddependencies {
		edges = append(edges, service.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeProject:
		return m.clearedproject
	case service.EdgeEnvironment:
		return m.clearedenvironment
	case service.EdgeTemplate:
		return m.clearedtemplate
	case service.EdgeRevisions:
		return m.clearedrevisions
	case service.EdgeResources:
		return m.clearedresources
	case service.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeProject:
		m.ClearProject()
		return nil
	case service.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case service.EdgeTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeProject:
		m.ResetProject()
		return nil
	case service.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case service.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case service.EdgeRevisions:
		m.ResetRevisions()
		return nil
	case service.EdgeResources:
		m.ResetResources()
		return nil
	case service.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// ServiceRelationshipMutation represents an operation that mutates the ServiceRelationship nodes in the graph.
type ServiceRelationshipMutation struct {
	config
	op                Op
	typ               string
	id                *object.ID
	create_time       *time.Time
	_path             *[]object.ID
	append_path       []object.ID
	_type             *string
	clearedFields     map[string]struct{}
	service           *object.ID
	clearedservice    bool
	dependency        *object.ID
	cleareddependency bool
	done              bool
	oldValue          func(context.Context) (*ServiceRelationship, error)
	predicates        []predicate.ServiceRelationship
}

var _ ent.Mutation = (*ServiceRelationshipMutation)(nil)

// serviceRelationshipOption allows management of the mutation configuration using functional options.
type serviceRelationshipOption func(*ServiceRelationshipMutation)

// newServiceRelationshipMutation creates new mutation for the ServiceRelationship entity.
func newServiceRelationshipMutation(c config, op Op, opts ...serviceRelationshipOption) *ServiceRelationshipMutation {
	m := &ServiceRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceRelationshipID sets the ID field of the mutation.
func withServiceRelationshipID(id object.ID) serviceRelationshipOption {
	return func(m *ServiceRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceRelationship
		)
		m.oldValue = func(ctx context.Context) (*ServiceRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceRelationship sets the old ServiceRelationship of the mutation.
func withServiceRelationship(node *ServiceRelationship) serviceRelationshipOption {
	return func(m *ServiceRelationshipMutation) {
		m.oldValue = func(context.Context) (*ServiceRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceRelationship entities.
func (m *ServiceRelationshipMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceRelationshipMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceRelationshipMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceRelationshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceRelationship entity.
// If the ServiceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceRelationshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetServiceID sets the "service_id" field.
func (m *ServiceRelationshipMutation) SetServiceID(o object.ID) {
	m.service = &o
}

// ServiceID returns the value of the "service_id" field in the mutation.
func (m *ServiceRelationshipMutation) ServiceID() (r object.ID, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "service_id" field's value of the ServiceRelationship entity.
// If the ServiceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRelationshipMutation) OldServiceID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID resets all changes to the "service_id" field.
func (m *ServiceRelationshipMutation) ResetServiceID() {
	m.service = nil
}

// SetDependencyID sets the "dependency_id" field.
func (m *ServiceRelationshipMutation) SetDependencyID(o object.ID) {
	m.dependency = &o
}

// DependencyID returns the value of the "dependency_id" field in the mutation.
func (m *ServiceRelationshipMutation) DependencyID() (r object.ID, exists bool) {
	v := m.dependency
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyID returns the old "dependency_id" field's value of the ServiceRelationship entity.
// If the ServiceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRelationshipMutation) OldDependencyID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyID: %w", err)
	}
	return oldValue.DependencyID, nil
}

// ResetDependencyID resets all changes to the "dependency_id" field.
func (m *ServiceRelationshipMutation) ResetDependencyID() {
	m.dependency = nil
}

// SetPath sets the "path" field.
func (m *ServiceRelationshipMutation) SetPath(o []object.ID) {
	m._path = &o
	m.append_path = nil
}

// Path returns the value of the "path" field in the mutation.
func (m *ServiceRelationshipMutation) Path() (r []object.ID, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the ServiceRelationship entity.
// If the ServiceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRelationshipMutation) OldPath(ctx context.Context) (v []object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// AppendPath adds o to the "path" field.
func (m *ServiceRelationshipMutation) AppendPath(o []object.ID) {
	m.append_path = append(m.append_path, o...)
}

// AppendedPath returns the list of values that were appended to the "path" field in this mutation.
func (m *ServiceRelationshipMutation) AppendedPath() ([]object.ID, bool) {
	if len(m.append_path) == 0 {
		return nil, false
	}
	return m.append_path, true
}

// ResetPath resets all changes to the "path" field.
func (m *ServiceRelationshipMutation) ResetPath() {
	m._path = nil
	m.append_path = nil
}

// SetType sets the "type" field.
func (m *ServiceRelationshipMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServiceRelationshipMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ServiceRelationship entity.
// If the ServiceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRelationshipMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServiceRelationshipMutation) ResetType() {
	m._type = nil
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceRelationshipMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceRelationshipMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceRelationshipMutation) ServiceIDs() (ids []object.ID) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceRelationshipMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// ClearDependency clears the "dependency" edge to the Service entity.
func (m *ServiceRelationshipMutation) ClearDependency() {
	m.cleareddependency = true
}

// DependencyCleared reports if the "dependency" edge to the Service entity was cleared.
func (m *ServiceRelationshipMutation) DependencyCleared() bool {
	return m.cleareddependency
}

// DependencyIDs returns the "dependency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependencyID instead. It exists only for internal usage by the builders.
func (m *ServiceRelationshipMutation) DependencyIDs() (ids []object.ID) {
	if id := m.dependency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependency resets all changes to the "dependency" edge.
func (m *ServiceRelationshipMutation) ResetDependency() {
	m.dependency = nil
	m.cleareddependency = false
}

// Where appends a list predicates to the ServiceRelationshipMutation builder.
func (m *ServiceRelationshipMutation) Where(ps ...predicate.ServiceRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceRelationship).
func (m *ServiceRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, servicerelationship.FieldCreateTime)
	}
	if m.service != nil {
		fields = append(fields, servicerelationship.FieldServiceID)
	}
	if m.dependency != nil {
		fields = append(fields, servicerelationship.FieldDependencyID)
	}
	if m._path != nil {
		fields = append(fields, servicerelationship.FieldPath)
	}
	if m._type != nil {
		fields = append(fields, servicerelationship.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicerelationship.FieldCreateTime:
		return m.CreateTime()
	case servicerelationship.FieldServiceID:
		return m.ServiceID()
	case servicerelationship.FieldDependencyID:
		return m.DependencyID()
	case servicerelationship.FieldPath:
		return m.Path()
	case servicerelationship.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicerelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case servicerelationship.FieldServiceID:
		return m.OldServiceID(ctx)
	case servicerelationship.FieldDependencyID:
		return m.OldDependencyID(ctx)
	case servicerelationship.FieldPath:
		return m.OldPath(ctx)
	case servicerelationship.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicerelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case servicerelationship.FieldServiceID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case servicerelationship.FieldDependencyID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyID(v)
		return nil
	case servicerelationship.FieldPath:
		v, ok := value.([]object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case servicerelationship.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceRelationshipMutation) ResetField(name string) error {
	switch name {
	case servicerelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case servicerelationship.FieldServiceID:
		m.ResetServiceID()
		return nil
	case servicerelationship.FieldDependencyID:
		m.ResetDependencyID()
		return nil
	case servicerelationship.FieldPath:
		m.ResetPath()
		return nil
	case servicerelationship.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ServiceRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.service != nil {
		edges = append(edges, servicerelationship.EdgeService)
	}
	if m.dependency != nil {
		edges = append(edges, servicerelationship.EdgeDependency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicerelationship.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case servicerelationship.EdgeDependency:
		if id := m.dependency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedservice {
		edges = append(edges, servicerelationship.EdgeService)
	}
	if m.cleareddependency {
		edges = append(edges, servicerelationship.EdgeDependency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case servicerelationship.EdgeService:
		return m.clearedservice
	case servicerelationship.EdgeDependency:
		return m.cleareddependency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case servicerelationship.EdgeService:
		m.ClearService()
		return nil
	case servicerelationship.EdgeDependency:
		m.ClearDependency()
		return nil
	}
	return fmt.Errorf("unknown ServiceRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case servicerelationship.EdgeService:
		m.ResetService()
		return nil
	case servicerelationship.EdgeDependency:
		m.ResetDependency()
		return nil
	}
	return fmt.Errorf("unknown ServiceRelationship edge %s", name)
}

// ServiceResourceMutation represents an operation that mutates the ServiceResource nodes in the graph.
type ServiceResourceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *object.ID
	create_time         *time.Time
	update_time         *time.Time
	mode                *string
	_type               *string
	name                *string
	deployer_type       *string
	shape               *string
	status              *types.ServiceResourceStatus
	clearedFields       map[string]struct{}
	project             *object.ID
	clearedproject      bool
	environment         *object.ID
	clearedenvironment  bool
	service             *object.ID
	clearedservice      bool
	connector           *object.ID
	clearedconnector    bool
	composition         *object.ID
	clearedcomposition  bool
	components          map[object.ID]struct{}
	removedcomponents   map[object.ID]struct{}
	clearedcomponents   bool
	class               *object.ID
	clearedclass        bool
	instances           map[object.ID]struct{}
	removedinstances    map[object.ID]struct{}
	clearedinstances    bool
	dependencies        map[object.ID]struct{}
	removeddependencies map[object.ID]struct{}
	cleareddependencies bool
	done                bool
	oldValue            func(context.Context) (*ServiceResource, error)
	predicates          []predicate.ServiceResource
}

var _ ent.Mutation = (*ServiceResourceMutation)(nil)

// serviceResourceOption allows management of the mutation configuration using functional options.
type serviceResourceOption func(*ServiceResourceMutation)

// newServiceResourceMutation creates new mutation for the ServiceResource entity.
func newServiceResourceMutation(c config, op Op, opts ...serviceResourceOption) *ServiceResourceMutation {
	m := &ServiceResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceResourceID sets the ID field of the mutation.
func withServiceResourceID(id object.ID) serviceResourceOption {
	return func(m *ServiceResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceResource
		)
		m.oldValue = func(ctx context.Context) (*ServiceResource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceResource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceResource sets the old ServiceResource of the mutation.
func withServiceResource(node *ServiceResource) serviceResourceOption {
	return func(m *ServiceResourceMutation) {
		m.oldValue = func(context.Context) (*ServiceResource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceResource entities.
func (m *ServiceResourceMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceResourceMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceResourceMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceResource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceResourceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceResourceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceResourceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceResourceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceResourceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceResourceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *ServiceResourceMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ServiceResourceMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ServiceResourceMutation) ResetProjectID() {
	m.project = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *ServiceResourceMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *ServiceResourceMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *ServiceResourceMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetServiceID sets the "service_id" field.
func (m *ServiceResourceMutation) SetServiceID(o object.ID) {
	m.service = &o
}

// ServiceID returns the value of the "service_id" field in the mutation.
func (m *ServiceResourceMutation) ServiceID() (r object.ID, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "service_id" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldServiceID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID resets all changes to the "service_id" field.
func (m *ServiceResourceMutation) ResetServiceID() {
	m.service = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *ServiceResourceMutation) SetConnectorID(o object.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *ServiceResourceMutation) ConnectorID() (r object.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldConnectorID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *ServiceResourceMutation) ResetConnectorID() {
	m.connector = nil
}

// SetCompositionID sets the "composition_id" field.
func (m *ServiceResourceMutation) SetCompositionID(o object.ID) {
	m.composition = &o
}

// CompositionID returns the value of the "composition_id" field in the mutation.
func (m *ServiceResourceMutation) CompositionID() (r object.ID, exists bool) {
	v := m.composition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompositionID returns the old "composition_id" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldCompositionID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompositionID: %w", err)
	}
	return oldValue.CompositionID, nil
}

// ClearCompositionID clears the value of the "composition_id" field.
func (m *ServiceResourceMutation) ClearCompositionID() {
	m.composition = nil
	m.clearedFields[serviceresource.FieldCompositionID] = struct{}{}
}

// CompositionIDCleared returns if the "composition_id" field was cleared in this mutation.
func (m *ServiceResourceMutation) CompositionIDCleared() bool {
	_, ok := m.clearedFields[serviceresource.FieldCompositionID]
	return ok
}

// ResetCompositionID resets all changes to the "composition_id" field.
func (m *ServiceResourceMutation) ResetCompositionID() {
	m.composition = nil
	delete(m.clearedFields, serviceresource.FieldCompositionID)
}

// SetClassID sets the "class_id" field.
func (m *ServiceResourceMutation) SetClassID(o object.ID) {
	m.class = &o
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *ServiceResourceMutation) ClassID() (r object.ID, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldClassID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ClearClassID clears the value of the "class_id" field.
func (m *ServiceResourceMutation) ClearClassID() {
	m.class = nil
	m.clearedFields[serviceresource.FieldClassID] = struct{}{}
}

// ClassIDCleared returns if the "class_id" field was cleared in this mutation.
func (m *ServiceResourceMutation) ClassIDCleared() bool {
	_, ok := m.clearedFields[serviceresource.FieldClassID]
	return ok
}

// ResetClassID resets all changes to the "class_id" field.
func (m *ServiceResourceMutation) ResetClassID() {
	m.class = nil
	delete(m.clearedFields, serviceresource.FieldClassID)
}

// SetMode sets the "mode" field.
func (m *ServiceResourceMutation) SetMode(s string) {
	m.mode = &s
}

// Mode returns the value of the "mode" field in the mutation.
func (m *ServiceResourceMutation) Mode() (r string, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *ServiceResourceMutation) ResetMode() {
	m.mode = nil
}

// SetType sets the "type" field.
func (m *ServiceResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServiceResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServiceResourceMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ServiceResourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceResourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceResourceMutation) ResetName() {
	m.name = nil
}

// SetDeployerType sets the "deployer_type" field.
func (m *ServiceResourceMutation) SetDeployerType(s string) {
	m.deployer_type = &s
}

// DeployerType returns the value of the "deployer_type" field in the mutation.
func (m *ServiceResourceMutation) DeployerType() (r string, exists bool) {
	v := m.deployer_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployerType returns the old "deployer_type" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldDeployerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployerType: %w", err)
	}
	return oldValue.DeployerType, nil
}

// ResetDeployerType resets all changes to the "deployer_type" field.
func (m *ServiceResourceMutation) ResetDeployerType() {
	m.deployer_type = nil
}

// SetShape sets the "shape" field.
func (m *ServiceResourceMutation) SetShape(s string) {
	m.shape = &s
}

// Shape returns the value of the "shape" field in the mutation.
func (m *ServiceResourceMutation) Shape() (r string, exists bool) {
	v := m.shape
	if v == nil {
		return
	}
	return *v, true
}

// OldShape returns the old "shape" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldShape(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShape is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShape requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShape: %w", err)
	}
	return oldValue.Shape, nil
}

// ResetShape resets all changes to the "shape" field.
func (m *ServiceResourceMutation) ResetShape() {
	m.shape = nil
}

// SetStatus sets the "status" field.
func (m *ServiceResourceMutation) SetStatus(trs types.ServiceResourceStatus) {
	m.status = &trs
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceResourceMutation) Status() (r types.ServiceResourceStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldStatus(ctx context.Context) (v types.ServiceResourceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ServiceResourceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[serviceresource.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ServiceResourceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[serviceresource.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceResourceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, serviceresource.FieldStatus)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ServiceResourceMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ServiceResourceMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ServiceResourceMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *ServiceResourceMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *ServiceResourceMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *ServiceResourceMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceResourceMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceResourceMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) ServiceIDs() (ids []object.ID) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceResourceMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *ServiceResourceMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *ServiceResourceMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) ConnectorIDs() (ids []object.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *ServiceResourceMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// ClearComposition clears the "composition" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) ClearComposition() {
	m.clearedcomposition = true
}

// CompositionCleared reports if the "composition" edge to the ServiceResource entity was cleared.
func (m *ServiceResourceMutation) CompositionCleared() bool {
	return m.CompositionIDCleared() || m.clearedcomposition
}

// CompositionIDs returns the "composition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompositionID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) CompositionIDs() (ids []object.ID) {
	if id := m.composition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComposition resets all changes to the "composition" edge.
func (m *ServiceResourceMutation) ResetComposition() {
	m.composition = nil
	m.clearedcomposition = false
}

// AddComponentIDs adds the "components" edge to the ServiceResource entity by ids.
func (m *ServiceResourceMutation) AddComponentIDs(ids ...object.ID) {
	if m.components == nil {
		m.components = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ServiceResource entity was cleared.
func (m *ServiceResourceMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ServiceResource entity by IDs.
func (m *ServiceResourceMutation) RemoveComponentIDs(ids ...object.ID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) RemovedComponentsIDs() (ids []object.ID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ServiceResourceMutation) ComponentsIDs() (ids []object.ID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ServiceResourceMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// ClearClass clears the "class" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the ServiceResource entity was cleared.
func (m *ServiceResourceMutation) ClassCleared() bool {
	return m.ClassIDCleared() || m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) ClassIDs() (ids []object.ID) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ServiceResourceMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// AddInstanceIDs adds the "instances" edge to the ServiceResource entity by ids.
func (m *ServiceResourceMutation) AddInstanceIDs(ids ...object.ID) {
	if m.instances == nil {
		m.instances = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the ServiceResource entity was cleared.
func (m *ServiceResourceMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the ServiceResource entity by IDs.
func (m *ServiceResourceMutation) RemoveInstanceIDs(ids ...object.ID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) RemovedInstancesIDs() (ids []object.ID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *ServiceResourceMutation) InstancesIDs() (ids []object.ID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *ServiceResourceMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// AddDependencyIDs adds the "dependencies" edge to the ServiceResourceRelationship entity by ids.
func (m *ServiceResourceMutation) AddDependencyIDs(ids ...object.ID) {
	if m.dependencies == nil {
		m.dependencies = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the ServiceResourceRelationship entity.
func (m *ServiceResourceMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the ServiceResourceRelationship entity was cleared.
func (m *ServiceResourceMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the ServiceResourceRelationship entity by IDs.
func (m *ServiceResourceMutation) RemoveDependencyIDs(ids ...object.ID) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the ServiceResourceRelationship entity.
func (m *ServiceResourceMutation) RemovedDependenciesIDs() (ids []object.ID) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ServiceResourceMutation) DependenciesIDs() (ids []object.ID) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ServiceResourceMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the ServiceResourceMutation builder.
func (m *ServiceResourceMutation) Where(ps ...predicate.ServiceResource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceResource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceResource).
func (m *ServiceResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceResourceMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, serviceresource.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serviceresource.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, serviceresource.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, serviceresource.FieldEnvironmentID)
	}
	if m.service != nil {
		fields = append(fields, serviceresource.FieldServiceID)
	}
	if m.connector != nil {
		fields = append(fields, serviceresource.FieldConnectorID)
	}
	if m.composition != nil {
		fields = append(fields, serviceresource.FieldCompositionID)
	}
	if m.class != nil {
		fields = append(fields, serviceresource.FieldClassID)
	}
	if m.mode != nil {
		fields = append(fields, serviceresource.FieldMode)
	}
	if m._type != nil {
		fields = append(fields, serviceresource.FieldType)
	}
	if m.name != nil {
		fields = append(fields, serviceresource.FieldName)
	}
	if m.deployer_type != nil {
		fields = append(fields, serviceresource.FieldDeployerType)
	}
	if m.shape != nil {
		fields = append(fields, serviceresource.FieldShape)
	}
	if m.status != nil {
		fields = append(fields, serviceresource.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceresource.FieldCreateTime:
		return m.CreateTime()
	case serviceresource.FieldUpdateTime:
		return m.UpdateTime()
	case serviceresource.FieldProjectID:
		return m.ProjectID()
	case serviceresource.FieldEnvironmentID:
		return m.EnvironmentID()
	case serviceresource.FieldServiceID:
		return m.ServiceID()
	case serviceresource.FieldConnectorID:
		return m.ConnectorID()
	case serviceresource.FieldCompositionID:
		return m.CompositionID()
	case serviceresource.FieldClassID:
		return m.ClassID()
	case serviceresource.FieldMode:
		return m.Mode()
	case serviceresource.FieldType:
		return m.GetType()
	case serviceresource.FieldName:
		return m.Name()
	case serviceresource.FieldDeployerType:
		return m.DeployerType()
	case serviceresource.FieldShape:
		return m.Shape()
	case serviceresource.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceresource.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceresource.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serviceresource.FieldProjectID:
		return m.OldProjectID(ctx)
	case serviceresource.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case serviceresource.FieldServiceID:
		return m.OldServiceID(ctx)
	case serviceresource.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case serviceresource.FieldCompositionID:
		return m.OldCompositionID(ctx)
	case serviceresource.FieldClassID:
		return m.OldClassID(ctx)
	case serviceresource.FieldMode:
		return m.OldMode(ctx)
	case serviceresource.FieldType:
		return m.OldType(ctx)
	case serviceresource.FieldName:
		return m.OldName(ctx)
	case serviceresource.FieldDeployerType:
		return m.OldDeployerType(ctx)
	case serviceresource.FieldShape:
		return m.OldShape(ctx)
	case serviceresource.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceResource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceresource.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceresource.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serviceresource.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case serviceresource.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case serviceresource.FieldServiceID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case serviceresource.FieldConnectorID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case serviceresource.FieldCompositionID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompositionID(v)
		return nil
	case serviceresource.FieldClassID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	case serviceresource.FieldMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case serviceresource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case serviceresource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case serviceresource.FieldDeployerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployerType(v)
		return nil
	case serviceresource.FieldShape:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShape(v)
		return nil
	case serviceresource.FieldStatus:
		v, ok := value.(types.ServiceResourceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceResource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceResource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceresource.FieldCompositionID) {
		fields = append(fields, serviceresource.FieldCompositionID)
	}
	if m.FieldCleared(serviceresource.FieldClassID) {
		fields = append(fields, serviceresource.FieldClassID)
	}
	if m.FieldCleared(serviceresource.FieldStatus) {
		fields = append(fields, serviceresource.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceResourceMutation) ClearField(name string) error {
	switch name {
	case serviceresource.FieldCompositionID:
		m.ClearCompositionID()
		return nil
	case serviceresource.FieldClassID:
		m.ClearClassID()
		return nil
	case serviceresource.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown ServiceResource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceResourceMutation) ResetField(name string) error {
	switch name {
	case serviceresource.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceresource.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serviceresource.FieldProjectID:
		m.ResetProjectID()
		return nil
	case serviceresource.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case serviceresource.FieldServiceID:
		m.ResetServiceID()
		return nil
	case serviceresource.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case serviceresource.FieldCompositionID:
		m.ResetCompositionID()
		return nil
	case serviceresource.FieldClassID:
		m.ResetClassID()
		return nil
	case serviceresource.FieldMode:
		m.ResetMode()
		return nil
	case serviceresource.FieldType:
		m.ResetType()
		return nil
	case serviceresource.FieldName:
		m.ResetName()
		return nil
	case serviceresource.FieldDeployerType:
		m.ResetDeployerType()
		return nil
	case serviceresource.FieldShape:
		m.ResetShape()
		return nil
	case serviceresource.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ServiceResource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.project != nil {
		edges = append(edges, serviceresource.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, serviceresource.EdgeEnvironment)
	}
	if m.service != nil {
		edges = append(edges, serviceresource.EdgeService)
	}
	if m.connector != nil {
		edges = append(edges, serviceresource.EdgeConnector)
	}
	if m.composition != nil {
		edges = append(edges, serviceresource.EdgeComposition)
	}
	if m.components != nil {
		edges = append(edges, serviceresource.EdgeComponents)
	}
	if m.class != nil {
		edges = append(edges, serviceresource.EdgeClass)
	}
	if m.instances != nil {
		edges = append(edges, serviceresource.EdgeInstances)
	}
	if m.dependencies != nil {
		edges = append(edges, serviceresource.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceresource.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeComposition:
		if id := m.composition; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case serviceresource.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case serviceresource.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedcomponents != nil {
		edges = append(edges, serviceresource.EdgeComponents)
	}
	if m.removedinstances != nil {
		edges = append(edges, serviceresource.EdgeInstances)
	}
	if m.removeddependencies != nil {
		edges = append(edges, serviceresource.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceresource.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case serviceresource.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case serviceresource.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedproject {
		edges = append(edges, serviceresource.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, serviceresource.EdgeEnvironment)
	}
	if m.clearedservice {
		edges = append(edges, serviceresource.EdgeService)
	}
	if m.clearedconnector {
		edges = append(edges, serviceresource.EdgeConnector)
	}
	if m.clearedcomposition {
		edges = append(edges, serviceresource.EdgeComposition)
	}
	if m.clearedcomponents {
		edges = append(edges, serviceresource.EdgeComponents)
	}
	if m.clearedclass {
		edges = append(edges, serviceresource.EdgeClass)
	}
	if m.clearedinstances {
		edges = append(edges, serviceresource.EdgeInstances)
	}
	if m.cleareddependencies {
		edges = append(edges, serviceresource.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceresource.EdgeProject:
		return m.clearedproject
	case serviceresource.EdgeEnvironment:
		return m.clearedenvironment
	case serviceresource.EdgeService:
		return m.clearedservice
	case serviceresource.EdgeConnector:
		return m.clearedconnector
	case serviceresource.EdgeComposition:
		return m.clearedcomposition
	case serviceresource.EdgeComponents:
		return m.clearedcomponents
	case serviceresource.EdgeClass:
		return m.clearedclass
	case serviceresource.EdgeInstances:
		return m.clearedinstances
	case serviceresource.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceResourceMutation) ClearEdge(name string) error {
	switch name {
	case serviceresource.EdgeProject:
		m.ClearProject()
		return nil
	case serviceresource.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case serviceresource.EdgeService:
		m.ClearService()
		return nil
	case serviceresource.EdgeConnector:
		m.ClearConnector()
		return nil
	case serviceresource.EdgeComposition:
		m.ClearComposition()
		return nil
	case serviceresource.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown ServiceResource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceResourceMutation) ResetEdge(name string) error {
	switch name {
	case serviceresource.EdgeProject:
		m.ResetProject()
		return nil
	case serviceresource.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case serviceresource.EdgeService:
		m.ResetService()
		return nil
	case serviceresource.EdgeConnector:
		m.ResetConnector()
		return nil
	case serviceresource.EdgeComposition:
		m.ResetComposition()
		return nil
	case serviceresource.EdgeComponents:
		m.ResetComponents()
		return nil
	case serviceresource.EdgeClass:
		m.ResetClass()
		return nil
	case serviceresource.EdgeInstances:
		m.ResetInstances()
		return nil
	case serviceresource.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown ServiceResource edge %s", name)
}

// ServiceResourceRelationshipMutation represents an operation that mutates the ServiceResourceRelationship nodes in the graph.
type ServiceResourceRelationshipMutation struct {
	config
	op                     Op
	typ                    string
	id                     *object.ID
	create_time            *time.Time
	_type                  *string
	clearedFields          map[string]struct{}
	serviceResource        *object.ID
	clearedserviceResource bool
	dependency             *object.ID
	cleareddependency      bool
	done                   bool
	oldValue               func(context.Context) (*ServiceResourceRelationship, error)
	predicates             []predicate.ServiceResourceRelationship
}

var _ ent.Mutation = (*ServiceResourceRelationshipMutation)(nil)

// serviceResourceRelationshipOption allows management of the mutation configuration using functional options.
type serviceResourceRelationshipOption func(*ServiceResourceRelationshipMutation)

// newServiceResourceRelationshipMutation creates new mutation for the ServiceResourceRelationship entity.
func newServiceResourceRelationshipMutation(c config, op Op, opts ...serviceResourceRelationshipOption) *ServiceResourceRelationshipMutation {
	m := &ServiceResourceRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceResourceRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceResourceRelationshipID sets the ID field of the mutation.
func withServiceResourceRelationshipID(id object.ID) serviceResourceRelationshipOption {
	return func(m *ServiceResourceRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceResourceRelationship
		)
		m.oldValue = func(ctx context.Context) (*ServiceResourceRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceResourceRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceResourceRelationship sets the old ServiceResourceRelationship of the mutation.
func withServiceResourceRelationship(node *ServiceResourceRelationship) serviceResourceRelationshipOption {
	return func(m *ServiceResourceRelationshipMutation) {
		m.oldValue = func(context.Context) (*ServiceResourceRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceResourceRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceResourceRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceResourceRelationship entities.
func (m *ServiceResourceRelationshipMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceResourceRelationshipMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceResourceRelationshipMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceResourceRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceResourceRelationshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceResourceRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceResourceRelationship entity.
// If the ServiceResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceResourceRelationshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetServiceResourceID sets the "service_resource_id" field.
func (m *ServiceResourceRelationshipMutation) SetServiceResourceID(o object.ID) {
	m.serviceResource = &o
}

// ServiceResourceID returns the value of the "service_resource_id" field in the mutation.
func (m *ServiceResourceRelationshipMutation) ServiceResourceID() (r object.ID, exists bool) {
	v := m.serviceResource
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceResourceID returns the old "service_resource_id" field's value of the ServiceResourceRelationship entity.
// If the ServiceResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceRelationshipMutation) OldServiceResourceID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceResourceID: %w", err)
	}
	return oldValue.ServiceResourceID, nil
}

// ResetServiceResourceID resets all changes to the "service_resource_id" field.
func (m *ServiceResourceRelationshipMutation) ResetServiceResourceID() {
	m.serviceResource = nil
}

// SetDependencyID sets the "dependency_id" field.
func (m *ServiceResourceRelationshipMutation) SetDependencyID(o object.ID) {
	m.dependency = &o
}

// DependencyID returns the value of the "dependency_id" field in the mutation.
func (m *ServiceResourceRelationshipMutation) DependencyID() (r object.ID, exists bool) {
	v := m.dependency
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyID returns the old "dependency_id" field's value of the ServiceResourceRelationship entity.
// If the ServiceResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceRelationshipMutation) OldDependencyID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyID: %w", err)
	}
	return oldValue.DependencyID, nil
}

// ResetDependencyID resets all changes to the "dependency_id" field.
func (m *ServiceResourceRelationshipMutation) ResetDependencyID() {
	m.dependency = nil
}

// SetType sets the "type" field.
func (m *ServiceResourceRelationshipMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServiceResourceRelationshipMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ServiceResourceRelationship entity.
// If the ServiceResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceRelationshipMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServiceResourceRelationshipMutation) ResetType() {
	m._type = nil
}

// ClearServiceResource clears the "serviceResource" edge to the ServiceResource entity.
func (m *ServiceResourceRelationshipMutation) ClearServiceResource() {
	m.clearedserviceResource = true
}

// ServiceResourceCleared reports if the "serviceResource" edge to the ServiceResource entity was cleared.
func (m *ServiceResourceRelationshipMutation) ServiceResourceCleared() bool {
	return m.clearedserviceResource
}

// ServiceResourceIDs returns the "serviceResource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceResourceID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceRelationshipMutation) ServiceResourceIDs() (ids []object.ID) {
	if id := m.serviceResource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceResource resets all changes to the "serviceResource" edge.
func (m *ServiceResourceRelationshipMutation) ResetServiceResource() {
	m.serviceResource = nil
	m.clearedserviceResource = false
}

// ClearDependency clears the "dependency" edge to the ServiceResource entity.
func (m *ServiceResourceRelationshipMutation) ClearDependency() {
	m.cleareddependency = true
}

// DependencyCleared reports if the "dependency" edge to the ServiceResource entity was cleared.
func (m *ServiceResourceRelationshipMutation) DependencyCleared() bool {
	return m.cleareddependency
}

// DependencyIDs returns the "dependency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependencyID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceRelationshipMutation) DependencyIDs() (ids []object.ID) {
	if id := m.dependency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependency resets all changes to the "dependency" edge.
func (m *ServiceResourceRelationshipMutation) ResetDependency() {
	m.dependency = nil
	m.cleareddependency = false
}

// Where appends a list predicates to the ServiceResourceRelationshipMutation builder.
func (m *ServiceResourceRelationshipMutation) Where(ps ...predicate.ServiceResourceRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceResourceRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceResourceRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceResourceRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceResourceRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceResourceRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceResourceRelationship).
func (m *ServiceResourceRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceResourceRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, serviceresourcerelationship.FieldCreateTime)
	}
	if m.serviceResource != nil {
		fields = append(fields, serviceresourcerelationship.FieldServiceResourceID)
	}
	if m.dependency != nil {
		fields = append(fields, serviceresourcerelationship.FieldDependencyID)
	}
	if m._type != nil {
		fields = append(fields, serviceresourcerelationship.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceResourceRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceresourcerelationship.FieldCreateTime:
		return m.CreateTime()
	case serviceresourcerelationship.FieldServiceResourceID:
		return m.ServiceResourceID()
	case serviceresourcerelationship.FieldDependencyID:
		return m.DependencyID()
	case serviceresourcerelationship.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceResourceRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceresourcerelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceresourcerelationship.FieldServiceResourceID:
		return m.OldServiceResourceID(ctx)
	case serviceresourcerelationship.FieldDependencyID:
		return m.OldDependencyID(ctx)
	case serviceresourcerelationship.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceResourceRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceResourceRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceresourcerelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceresourcerelationship.FieldServiceResourceID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceResourceID(v)
		return nil
	case serviceresourcerelationship.FieldDependencyID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyID(v)
		return nil
	case serviceresourcerelationship.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceResourceRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceResourceRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceResourceRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceResourceRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceResourceRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceResourceRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceResourceRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceResourceRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceResourceRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceResourceRelationshipMutation) ResetField(name string) error {
	switch name {
	case serviceresourcerelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceresourcerelationship.FieldServiceResourceID:
		m.ResetServiceResourceID()
		return nil
	case serviceresourcerelationship.FieldDependencyID:
		m.ResetDependencyID()
		return nil
	case serviceresourcerelationship.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ServiceResourceRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceResourceRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.serviceResource != nil {
		edges = append(edges, serviceresourcerelationship.EdgeServiceResource)
	}
	if m.dependency != nil {
		edges = append(edges, serviceresourcerelationship.EdgeDependency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceResourceRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceresourcerelationship.EdgeServiceResource:
		if id := m.serviceResource; id != nil {
			return []ent.Value{*id}
		}
	case serviceresourcerelationship.EdgeDependency:
		if id := m.dependency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceResourceRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceResourceRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceResourceRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedserviceResource {
		edges = append(edges, serviceresourcerelationship.EdgeServiceResource)
	}
	if m.cleareddependency {
		edges = append(edges, serviceresourcerelationship.EdgeDependency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceResourceRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceresourcerelationship.EdgeServiceResource:
		return m.clearedserviceResource
	case serviceresourcerelationship.EdgeDependency:
		return m.cleareddependency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceResourceRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case serviceresourcerelationship.EdgeServiceResource:
		m.ClearServiceResource()
		return nil
	case serviceresourcerelationship.EdgeDependency:
		m.ClearDependency()
		return nil
	}
	return fmt.Errorf("unknown ServiceResourceRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceResourceRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case serviceresourcerelationship.EdgeServiceResource:
		m.ResetServiceResource()
		return nil
	case serviceresourcerelationship.EdgeDependency:
		m.ResetDependency()
		return nil
	}
	return fmt.Errorf("unknown ServiceResourceRelationship edge %s", name)
}

// ServiceRevisionMutation represents an operation that mutates the ServiceRevision nodes in the graph.
type ServiceRevisionMutation struct {
	config
	op                                Op
	typ                               string
	id                                *object.ID
	create_time                       *time.Time
	status                            *status.Status
	template_name                     *string
	template_version                  *string
	template_id                       *object.ID
	attributes                        *property.Values
	variables                         *crypto.Map[string, string]
	input_plan                        *string
	output                            *string
	deployer_type                     *string
	duration                          *int
	addduration                       *int
	previous_required_providers       *[]types.ProviderRequirement
	appendprevious_required_providers []types.ProviderRequirement
	record                            *string
	clearedFields                     map[string]struct{}
	project                           *object.ID
	clearedproject                    bool
	environment                       *object.ID
	clearedenvironment                bool
	service                           *object.ID
	clearedservice                    bool
	done                              bool
	oldValue                          func(context.Context) (*ServiceRevision, error)
	predicates                        []predicate.ServiceRevision
}

var _ ent.Mutation = (*ServiceRevisionMutation)(nil)

// serviceRevisionOption allows management of the mutation configuration using functional options.
type serviceRevisionOption func(*ServiceRevisionMutation)

// newServiceRevisionMutation creates new mutation for the ServiceRevision entity.
func newServiceRevisionMutation(c config, op Op, opts ...serviceRevisionOption) *ServiceRevisionMutation {
	m := &ServiceRevisionMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceRevision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceRevisionID sets the ID field of the mutation.
func withServiceRevisionID(id object.ID) serviceRevisionOption {
	return func(m *ServiceRevisionMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceRevision
		)
		m.oldValue = func(ctx context.Context) (*ServiceRevision, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceRevision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceRevision sets the old ServiceRevision of the mutation.
func withServiceRevision(node *ServiceRevision) serviceRevisionOption {
	return func(m *ServiceRevisionMutation) {
		m.oldValue = func(context.Context) (*ServiceRevision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceRevisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceRevisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceRevision entities.
func (m *ServiceRevisionMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceRevisionMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceRevisionMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceRevision.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceRevisionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceRevisionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceRevisionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetStatus sets the "status" field.
func (m *ServiceRevisionMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceRevisionMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ServiceRevisionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[servicerevision.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ServiceRevisionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[servicerevision.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceRevisionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, servicerevision.FieldStatus)
}

// SetProjectID sets the "project_id" field.
func (m *ServiceRevisionMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ServiceRevisionMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ServiceRevisionMutation) ResetProjectID() {
	m.project = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *ServiceRevisionMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *ServiceRevisionMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *ServiceRevisionMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetServiceID sets the "service_id" field.
func (m *ServiceRevisionMutation) SetServiceID(o object.ID) {
	m.service = &o
}

// ServiceID returns the value of the "service_id" field in the mutation.
func (m *ServiceRevisionMutation) ServiceID() (r object.ID, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "service_id" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldServiceID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID resets all changes to the "service_id" field.
func (m *ServiceRevisionMutation) ResetServiceID() {
	m.service = nil
}

// SetTemplateName sets the "template_name" field.
func (m *ServiceRevisionMutation) SetTemplateName(s string) {
	m.template_name = &s
}

// TemplateName returns the value of the "template_name" field in the mutation.
func (m *ServiceRevisionMutation) TemplateName() (r string, exists bool) {
	v := m.template_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateName returns the old "template_name" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldTemplateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateName: %w", err)
	}
	return oldValue.TemplateName, nil
}

// ResetTemplateName resets all changes to the "template_name" field.
func (m *ServiceRevisionMutation) ResetTemplateName() {
	m.template_name = nil
}

// SetTemplateVersion sets the "template_version" field.
func (m *ServiceRevisionMutation) SetTemplateVersion(s string) {
	m.template_version = &s
}

// TemplateVersion returns the value of the "template_version" field in the mutation.
func (m *ServiceRevisionMutation) TemplateVersion() (r string, exists bool) {
	v := m.template_version
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateVersion returns the old "template_version" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldTemplateVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateVersion: %w", err)
	}
	return oldValue.TemplateVersion, nil
}

// ResetTemplateVersion resets all changes to the "template_version" field.
func (m *ServiceRevisionMutation) ResetTemplateVersion() {
	m.template_version = nil
}

// SetTemplateID sets the "template_id" field.
func (m *ServiceRevisionMutation) SetTemplateID(o object.ID) {
	m.template_id = &o
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *ServiceRevisionMutation) TemplateID() (r object.ID, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldTemplateID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *ServiceRevisionMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetAttributes sets the "attributes" field.
func (m *ServiceRevisionMutation) SetAttributes(pr property.Values) {
	m.attributes = &pr
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ServiceRevisionMutation) Attributes() (r property.Values, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldAttributes(ctx context.Context) (v property.Values, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ServiceRevisionMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[servicerevision.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ServiceRevisionMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[servicerevision.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ServiceRevisionMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, servicerevision.FieldAttributes)
}

// SetVariables sets the "variables" field.
func (m *ServiceRevisionMutation) SetVariables(c crypto.Map[string, string]) {
	m.variables = &c
}

// Variables returns the value of the "variables" field in the mutation.
func (m *ServiceRevisionMutation) Variables() (r crypto.Map[string, string], exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldVariables(ctx context.Context) (v crypto.Map[string, string], err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ResetVariables resets all changes to the "variables" field.
func (m *ServiceRevisionMutation) ResetVariables() {
	m.variables = nil
}

// SetInputPlan sets the "input_plan" field.
func (m *ServiceRevisionMutation) SetInputPlan(s string) {
	m.input_plan = &s
}

// InputPlan returns the value of the "input_plan" field in the mutation.
func (m *ServiceRevisionMutation) InputPlan() (r string, exists bool) {
	v := m.input_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldInputPlan returns the old "input_plan" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldInputPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputPlan: %w", err)
	}
	return oldValue.InputPlan, nil
}

// ResetInputPlan resets all changes to the "input_plan" field.
func (m *ServiceRevisionMutation) ResetInputPlan() {
	m.input_plan = nil
}

// SetOutput sets the "output" field.
func (m *ServiceRevisionMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *ServiceRevisionMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *ServiceRevisionMutation) ResetOutput() {
	m.output = nil
}

// SetDeployerType sets the "deployer_type" field.
func (m *ServiceRevisionMutation) SetDeployerType(s string) {
	m.deployer_type = &s
}

// DeployerType returns the value of the "deployer_type" field in the mutation.
func (m *ServiceRevisionMutation) DeployerType() (r string, exists bool) {
	v := m.deployer_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployerType returns the old "deployer_type" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldDeployerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployerType: %w", err)
	}
	return oldValue.DeployerType, nil
}

// ResetDeployerType resets all changes to the "deployer_type" field.
func (m *ServiceRevisionMutation) ResetDeployerType() {
	m.deployer_type = nil
}

// SetDuration sets the "duration" field.
func (m *ServiceRevisionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ServiceRevisionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ServiceRevisionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ServiceRevisionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *ServiceRevisionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetPreviousRequiredProviders sets the "previous_required_providers" field.
func (m *ServiceRevisionMutation) SetPreviousRequiredProviders(tr []types.ProviderRequirement) {
	m.previous_required_providers = &tr
	m.appendprevious_required_providers = nil
}

// PreviousRequiredProviders returns the value of the "previous_required_providers" field in the mutation.
func (m *ServiceRevisionMutation) PreviousRequiredProviders() (r []types.ProviderRequirement, exists bool) {
	v := m.previous_required_providers
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousRequiredProviders returns the old "previous_required_providers" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldPreviousRequiredProviders(ctx context.Context) (v []types.ProviderRequirement, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousRequiredProviders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousRequiredProviders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousRequiredProviders: %w", err)
	}
	return oldValue.PreviousRequiredProviders, nil
}

// AppendPreviousRequiredProviders adds tr to the "previous_required_providers" field.
func (m *ServiceRevisionMutation) AppendPreviousRequiredProviders(tr []types.ProviderRequirement) {
	m.appendprevious_required_providers = append(m.appendprevious_required_providers, tr...)
}

// AppendedPreviousRequiredProviders returns the list of values that were appended to the "previous_required_providers" field in this mutation.
func (m *ServiceRevisionMutation) AppendedPreviousRequiredProviders() ([]types.ProviderRequirement, bool) {
	if len(m.appendprevious_required_providers) == 0 {
		return nil, false
	}
	return m.appendprevious_required_providers, true
}

// ResetPreviousRequiredProviders resets all changes to the "previous_required_providers" field.
func (m *ServiceRevisionMutation) ResetPreviousRequiredProviders() {
	m.previous_required_providers = nil
	m.appendprevious_required_providers = nil
}

// SetRecord sets the "record" field.
func (m *ServiceRevisionMutation) SetRecord(s string) {
	m.record = &s
}

// Record returns the value of the "record" field in the mutation.
func (m *ServiceRevisionMutation) Record() (r string, exists bool) {
	v := m.record
	if v == nil {
		return
	}
	return *v, true
}

// OldRecord returns the old "record" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecord: %w", err)
	}
	return oldValue.Record, nil
}

// ClearRecord clears the value of the "record" field.
func (m *ServiceRevisionMutation) ClearRecord() {
	m.record = nil
	m.clearedFields[servicerevision.FieldRecord] = struct{}{}
}

// RecordCleared returns if the "record" field was cleared in this mutation.
func (m *ServiceRevisionMutation) RecordCleared() bool {
	_, ok := m.clearedFields[servicerevision.FieldRecord]
	return ok
}

// ResetRecord resets all changes to the "record" field.
func (m *ServiceRevisionMutation) ResetRecord() {
	m.record = nil
	delete(m.clearedFields, servicerevision.FieldRecord)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ServiceRevisionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ServiceRevisionMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ServiceRevisionMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ServiceRevisionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *ServiceRevisionMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *ServiceRevisionMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ServiceRevisionMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *ServiceRevisionMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceRevisionMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceRevisionMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceRevisionMutation) ServiceIDs() (ids []object.ID) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceRevisionMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ServiceRevisionMutation builder.
func (m *ServiceRevisionMutation) Where(ps ...predicate.ServiceRevision) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceRevisionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceRevisionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceRevision, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceRevisionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceRevisionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceRevision).
func (m *ServiceRevisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceRevisionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.create_time != nil {
		fields = append(fields, servicerevision.FieldCreateTime)
	}
	if m.status != nil {
		fields = append(fields, servicerevision.FieldStatus)
	}
	if m.project != nil {
		fields = append(fields, servicerevision.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, servicerevision.FieldEnvironmentID)
	}
	if m.service != nil {
		fields = append(fields, servicerevision.FieldServiceID)
	}
	if m.template_name != nil {
		fields = append(fields, servicerevision.FieldTemplateName)
	}
	if m.template_version != nil {
		fields = append(fields, servicerevision.FieldTemplateVersion)
	}
	if m.template_id != nil {
		fields = append(fields, servicerevision.FieldTemplateID)
	}
	if m.attributes != nil {
		fields = append(fields, servicerevision.FieldAttributes)
	}
	if m.variables != nil {
		fields = append(fields, servicerevision.FieldVariables)
	}
	if m.input_plan != nil {
		fields = append(fields, servicerevision.FieldInputPlan)
	}
	if m.output != nil {
		fields = append(fields, servicerevision.FieldOutput)
	}
	if m.deployer_type != nil {
		fields = append(fields, servicerevision.FieldDeployerType)
	}
	if m.duration != nil {
		fields = append(fields, servicerevision.FieldDuration)
	}
	if m.previous_required_providers != nil {
		fields = append(fields, servicerevision.FieldPreviousRequiredProviders)
	}
	if m.record != nil {
		fields = append(fields, servicerevision.FieldRecord)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceRevisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicerevision.FieldCreateTime:
		return m.CreateTime()
	case servicerevision.FieldStatus:
		return m.Status()
	case servicerevision.FieldProjectID:
		return m.ProjectID()
	case servicerevision.FieldEnvironmentID:
		return m.EnvironmentID()
	case servicerevision.FieldServiceID:
		return m.ServiceID()
	case servicerevision.FieldTemplateName:
		return m.TemplateName()
	case servicerevision.FieldTemplateVersion:
		return m.TemplateVersion()
	case servicerevision.FieldTemplateID:
		return m.TemplateID()
	case servicerevision.FieldAttributes:
		return m.Attributes()
	case servicerevision.FieldVariables:
		return m.Variables()
	case servicerevision.FieldInputPlan:
		return m.InputPlan()
	case servicerevision.FieldOutput:
		return m.Output()
	case servicerevision.FieldDeployerType:
		return m.DeployerType()
	case servicerevision.FieldDuration:
		return m.Duration()
	case servicerevision.FieldPreviousRequiredProviders:
		return m.PreviousRequiredProviders()
	case servicerevision.FieldRecord:
		return m.Record()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceRevisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicerevision.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case servicerevision.FieldStatus:
		return m.OldStatus(ctx)
	case servicerevision.FieldProjectID:
		return m.OldProjectID(ctx)
	case servicerevision.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case servicerevision.FieldServiceID:
		return m.OldServiceID(ctx)
	case servicerevision.FieldTemplateName:
		return m.OldTemplateName(ctx)
	case servicerevision.FieldTemplateVersion:
		return m.OldTemplateVersion(ctx)
	case servicerevision.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case servicerevision.FieldAttributes:
		return m.OldAttributes(ctx)
	case servicerevision.FieldVariables:
		return m.OldVariables(ctx)
	case servicerevision.FieldInputPlan:
		return m.OldInputPlan(ctx)
	case servicerevision.FieldOutput:
		return m.OldOutput(ctx)
	case servicerevision.FieldDeployerType:
		return m.OldDeployerType(ctx)
	case servicerevision.FieldDuration:
		return m.OldDuration(ctx)
	case servicerevision.FieldPreviousRequiredProviders:
		return m.OldPreviousRequiredProviders(ctx)
	case servicerevision.FieldRecord:
		return m.OldRecord(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceRevision field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRevisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicerevision.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case servicerevision.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicerevision.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case servicerevision.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case servicerevision.FieldServiceID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case servicerevision.FieldTemplateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateName(v)
		return nil
	case servicerevision.FieldTemplateVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateVersion(v)
		return nil
	case servicerevision.FieldTemplateID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case servicerevision.FieldAttributes:
		v, ok := value.(property.Values)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case servicerevision.FieldVariables:
		v, ok := value.(crypto.Map[string, string])
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case servicerevision.FieldInputPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputPlan(v)
		return nil
	case servicerevision.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case servicerevision.FieldDeployerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployerType(v)
		return nil
	case servicerevision.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case servicerevision.FieldPreviousRequiredProviders:
		v, ok := value.([]types.ProviderRequirement)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousRequiredProviders(v)
		return nil
	case servicerevision.FieldRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecord(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceRevisionMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, servicerevision.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceRevisionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicerevision.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRevisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicerevision.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceRevisionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicerevision.FieldStatus) {
		fields = append(fields, servicerevision.FieldStatus)
	}
	if m.FieldCleared(servicerevision.FieldAttributes) {
		fields = append(fields, servicerevision.FieldAttributes)
	}
	if m.FieldCleared(servicerevision.FieldRecord) {
		fields = append(fields, servicerevision.FieldRecord)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceRevisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceRevisionMutation) ClearField(name string) error {
	switch name {
	case servicerevision.FieldStatus:
		m.ClearStatus()
		return nil
	case servicerevision.FieldAttributes:
		m.ClearAttributes()
		return nil
	case servicerevision.FieldRecord:
		m.ClearRecord()
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceRevisionMutation) ResetField(name string) error {
	switch name {
	case servicerevision.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case servicerevision.FieldStatus:
		m.ResetStatus()
		return nil
	case servicerevision.FieldProjectID:
		m.ResetProjectID()
		return nil
	case servicerevision.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case servicerevision.FieldServiceID:
		m.ResetServiceID()
		return nil
	case servicerevision.FieldTemplateName:
		m.ResetTemplateName()
		return nil
	case servicerevision.FieldTemplateVersion:
		m.ResetTemplateVersion()
		return nil
	case servicerevision.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case servicerevision.FieldAttributes:
		m.ResetAttributes()
		return nil
	case servicerevision.FieldVariables:
		m.ResetVariables()
		return nil
	case servicerevision.FieldInputPlan:
		m.ResetInputPlan()
		return nil
	case servicerevision.FieldOutput:
		m.ResetOutput()
		return nil
	case servicerevision.FieldDeployerType:
		m.ResetDeployerType()
		return nil
	case servicerevision.FieldDuration:
		m.ResetDuration()
		return nil
	case servicerevision.FieldPreviousRequiredProviders:
		m.ResetPreviousRequiredProviders()
		return nil
	case servicerevision.FieldRecord:
		m.ResetRecord()
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceRevisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, servicerevision.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, servicerevision.EdgeEnvironment)
	}
	if m.service != nil {
		edges = append(edges, servicerevision.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceRevisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicerevision.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case servicerevision.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case servicerevision.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceRevisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceRevisionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceRevisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, servicerevision.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, servicerevision.EdgeEnvironment)
	}
	if m.clearedservice {
		edges = append(edges, servicerevision.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceRevisionMutation) EdgeCleared(name string) bool {
	switch name {
	case servicerevision.EdgeProject:
		return m.clearedproject
	case servicerevision.EdgeEnvironment:
		return m.clearedenvironment
	case servicerevision.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceRevisionMutation) ClearEdge(name string) error {
	switch name {
	case servicerevision.EdgeProject:
		m.ClearProject()
		return nil
	case servicerevision.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case servicerevision.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceRevisionMutation) ResetEdge(name string) error {
	switch name {
	case servicerevision.EdgeProject:
		m.ResetProject()
		return nil
	case servicerevision.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case servicerevision.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *object.ID
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	value         *crypto.String
	hidden        *bool
	editable      *bool
	sensitive     *bool
	private       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id object.ID) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SettingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SettingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SettingMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SettingMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SettingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SettingMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(c crypto.String) {
	m.value = &c
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r crypto.String, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v crypto.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetHidden sets the "hidden" field.
func (m *SettingMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *SettingMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldHidden(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *SettingMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[setting.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *SettingMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[setting.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *SettingMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, setting.FieldHidden)
}

// SetEditable sets the "editable" field.
func (m *SettingMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *SettingMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldEditable(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ClearEditable clears the value of the "editable" field.
func (m *SettingMutation) ClearEditable() {
	m.editable = nil
	m.clearedFields[setting.FieldEditable] = struct{}{}
}

// EditableCleared returns if the "editable" field was cleared in this mutation.
func (m *SettingMutation) EditableCleared() bool {
	_, ok := m.clearedFields[setting.FieldEditable]
	return ok
}

// ResetEditable resets all changes to the "editable" field.
func (m *SettingMutation) ResetEditable() {
	m.editable = nil
	delete(m.clearedFields, setting.FieldEditable)
}

// SetSensitive sets the "sensitive" field.
func (m *SettingMutation) SetSensitive(b bool) {
	m.sensitive = &b
}

// Sensitive returns the value of the "sensitive" field in the mutation.
func (m *SettingMutation) Sensitive() (r bool, exists bool) {
	v := m.sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitive returns the old "sensitive" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSensitive(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitive: %w", err)
	}
	return oldValue.Sensitive, nil
}

// ClearSensitive clears the value of the "sensitive" field.
func (m *SettingMutation) ClearSensitive() {
	m.sensitive = nil
	m.clearedFields[setting.FieldSensitive] = struct{}{}
}

// SensitiveCleared returns if the "sensitive" field was cleared in this mutation.
func (m *SettingMutation) SensitiveCleared() bool {
	_, ok := m.clearedFields[setting.FieldSensitive]
	return ok
}

// ResetSensitive resets all changes to the "sensitive" field.
func (m *SettingMutation) ResetSensitive() {
	m.sensitive = nil
	delete(m.clearedFields, setting.FieldSensitive)
}

// SetPrivate sets the "private" field.
func (m *SettingMutation) SetPrivate(b bool) {
	m.private = &b
}

// Private returns the value of the "private" field in the mutation.
func (m *SettingMutation) Private() (r bool, exists bool) {
	v := m.private
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivate returns the old "private" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldPrivate(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivate: %w", err)
	}
	return oldValue.Private, nil
}

// ClearPrivate clears the value of the "private" field.
func (m *SettingMutation) ClearPrivate() {
	m.private = nil
	m.clearedFields[setting.FieldPrivate] = struct{}{}
}

// PrivateCleared returns if the "private" field was cleared in this mutation.
func (m *SettingMutation) PrivateCleared() bool {
	_, ok := m.clearedFields[setting.FieldPrivate]
	return ok
}

// ResetPrivate resets all changes to the "private" field.
func (m *SettingMutation) ResetPrivate() {
	m.private = nil
	delete(m.clearedFields, setting.FieldPrivate)
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, setting.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, setting.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.hidden != nil {
		fields = append(fields, setting.FieldHidden)
	}
	if m.editable != nil {
		fields = append(fields, setting.FieldEditable)
	}
	if m.sensitive != nil {
		fields = append(fields, setting.FieldSensitive)
	}
	if m.private != nil {
		fields = append(fields, setting.FieldPrivate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreateTime:
		return m.CreateTime()
	case setting.FieldUpdateTime:
		return m.UpdateTime()
	case setting.FieldName:
		return m.Name()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldHidden:
		return m.Hidden()
	case setting.FieldEditable:
		return m.Editable()
	case setting.FieldSensitive:
		return m.Sensitive()
	case setting.FieldPrivate:
		return m.Private()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case setting.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldHidden:
		return m.OldHidden(ctx)
	case setting.FieldEditable:
		return m.OldEditable(ctx)
	case setting.FieldSensitive:
		return m.OldSensitive(ctx)
	case setting.FieldPrivate:
		return m.OldPrivate(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case setting.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(crypto.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case setting.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	case setting.FieldSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitive(v)
		return nil
	case setting.FieldPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivate(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldHidden) {
		fields = append(fields, setting.FieldHidden)
	}
	if m.FieldCleared(setting.FieldEditable) {
		fields = append(fields, setting.FieldEditable)
	}
	if m.FieldCleared(setting.FieldSensitive) {
		fields = append(fields, setting.FieldSensitive)
	}
	if m.FieldCleared(setting.FieldPrivate) {
		fields = append(fields, setting.FieldPrivate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldHidden:
		m.ClearHidden()
		return nil
	case setting.FieldEditable:
		m.ClearEditable()
		return nil
	case setting.FieldSensitive:
		m.ClearSensitive()
		return nil
	case setting.FieldPrivate:
		m.ClearPrivate()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case setting.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldHidden:
		m.ResetHidden()
		return nil
	case setting.FieldEditable:
		m.ResetEditable()
		return nil
	case setting.FieldSensitive:
		m.ResetSensitive()
		return nil
	case setting.FieldPrivate:
		m.ResetPrivate()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SubjectMutation represents an operation that mutates the Subject nodes in the graph.
type SubjectMutation struct {
	config
	op            Op
	typ           string
	id            *object.ID
	create_time   *time.Time
	update_time   *time.Time
	kind          *string
	domain        *string
	name          *string
	description   *string
	builtin       *bool
	clearedFields map[string]struct{}
	tokens        map[object.ID]struct{}
	removedtokens map[object.ID]struct{}
	clearedtokens bool
	roles         map[object.ID]struct{}
	removedroles  map[object.ID]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Subject, error)
	predicates    []predicate.Subject
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows management of the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for the Subject entity.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the ID field of the mutation.
func withSubjectID(id object.ID) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subject entities.
func (m *SubjectMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SubjectMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubjectMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SubjectMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SubjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SubjectMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetKind sets the "kind" field.
func (m *SubjectMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *SubjectMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *SubjectMutation) ResetKind() {
	m.kind = nil
}

// SetDomain sets the "domain" field.
func (m *SubjectMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *SubjectMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *SubjectMutation) ResetDomain() {
	m.domain = nil
}

// SetName sets the "name" field.
func (m *SubjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subject.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subject.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subject.FieldDescription)
}

// SetBuiltin sets the "builtin" field.
func (m *SubjectMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *SubjectMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *SubjectMutation) ResetBuiltin() {
	m.builtin = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *SubjectMutation) AddTokenIDs(ids ...object.ID) {
	if m.tokens == nil {
		m.tokens = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *SubjectMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *SubjectMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *SubjectMutation) RemoveTokenIDs(ids ...object.ID) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *SubjectMutation) RemovedTokensIDs() (ids []object.ID) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *SubjectMutation) TokensIDs() (ids []object.ID) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *SubjectMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddRoleIDs adds the "roles" edge to the SubjectRoleRelationship entity by ids.
func (m *SubjectMutation) AddRoleIDs(ids ...object.ID) {
	if m.roles == nil {
		m.roles = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the SubjectRoleRelationship entity.
func (m *SubjectMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the SubjectRoleRelationship entity was cleared.
func (m *SubjectMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the SubjectRoleRelationship entity by IDs.
func (m *SubjectMutation) RemoveRoleIDs(ids ...object.ID) {
	if m.removedroles == nil {
		m.removedroles = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the SubjectRoleRelationship entity.
func (m *SubjectMutation) RemovedRolesIDs() (ids []object.ID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *SubjectMutation) RolesIDs() (ids []object.ID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *SubjectMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the SubjectMutation builder.
func (m *SubjectMutation) Where(ps ...predicate.Subject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, subject.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, subject.FieldUpdateTime)
	}
	if m.kind != nil {
		fields = append(fields, subject.FieldKind)
	}
	if m.domain != nil {
		fields = append(fields, subject.FieldDomain)
	}
	if m.name != nil {
		fields = append(fields, subject.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subject.FieldDescription)
	}
	if m.builtin != nil {
		fields = append(fields, subject.FieldBuiltin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCreateTime:
		return m.CreateTime()
	case subject.FieldUpdateTime:
		return m.UpdateTime()
	case subject.FieldKind:
		return m.Kind()
	case subject.FieldDomain:
		return m.Domain()
	case subject.FieldName:
		return m.Name()
	case subject.FieldDescription:
		return m.Description()
	case subject.FieldBuiltin:
		return m.Builtin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subject.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case subject.FieldKind:
		return m.OldKind(ctx)
	case subject.FieldDomain:
		return m.OldDomain(ctx)
	case subject.FieldName:
		return m.OldName(ctx)
	case subject.FieldDescription:
		return m.OldDescription(ctx)
	case subject.FieldBuiltin:
		return m.OldBuiltin(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subject.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case subject.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case subject.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case subject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subject.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subject.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subject.FieldDescription) {
		fields = append(fields, subject.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	switch name {
	case subject.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subject.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case subject.FieldKind:
		m.ResetKind()
		return nil
	case subject.FieldDomain:
		m.ResetDomain()
		return nil
	case subject.FieldName:
		m.ResetName()
		return nil
	case subject.FieldDescription:
		m.ResetDescription()
		return nil
	case subject.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tokens != nil {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.roles != nil {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtokens != nil {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.removedroles != nil {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtokens {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.clearedroles {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case subject.EdgeTokens:
		return m.clearedtokens
	case subject.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeTokens:
		m.ResetTokens()
		return nil
	case subject.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// SubjectRoleRelationshipMutation represents an operation that mutates the SubjectRoleRelationship nodes in the graph.
type SubjectRoleRelationshipMutation struct {
	config
	op             Op
	typ            string
	id             *object.ID
	create_time    *time.Time
	clearedFields  map[string]struct{}
	project        *object.ID
	clearedproject bool
	subject        *object.ID
	clearedsubject bool
	role           *string
	clearedrole    bool
	done           bool
	oldValue       func(context.Context) (*SubjectRoleRelationship, error)
	predicates     []predicate.SubjectRoleRelationship
}

var _ ent.Mutation = (*SubjectRoleRelationshipMutation)(nil)

// subjectRoleRelationshipOption allows management of the mutation configuration using functional options.
type subjectRoleRelationshipOption func(*SubjectRoleRelationshipMutation)

// newSubjectRoleRelationshipMutation creates new mutation for the SubjectRoleRelationship entity.
func newSubjectRoleRelationshipMutation(c config, op Op, opts ...subjectRoleRelationshipOption) *SubjectRoleRelationshipMutation {
	m := &SubjectRoleRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeSubjectRoleRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectRoleRelationshipID sets the ID field of the mutation.
func withSubjectRoleRelationshipID(id object.ID) subjectRoleRelationshipOption {
	return func(m *SubjectRoleRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *SubjectRoleRelationship
		)
		m.oldValue = func(ctx context.Context) (*SubjectRoleRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubjectRoleRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubjectRoleRelationship sets the old SubjectRoleRelationship of the mutation.
func withSubjectRoleRelationship(node *SubjectRoleRelationship) subjectRoleRelationshipOption {
	return func(m *SubjectRoleRelationshipMutation) {
		m.oldValue = func(context.Context) (*SubjectRoleRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectRoleRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectRoleRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubjectRoleRelationship entities.
func (m *SubjectRoleRelationshipMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectRoleRelationshipMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectRoleRelationshipMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubjectRoleRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SubjectRoleRelationshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubjectRoleRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubjectRoleRelationshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *SubjectRoleRelationshipMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *SubjectRoleRelationshipMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *SubjectRoleRelationshipMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[subjectrolerelationship.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[subjectrolerelationship.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *SubjectRoleRelationshipMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, subjectrolerelationship.FieldProjectID)
}

// SetSubjectID sets the "subject_id" field.
func (m *SubjectRoleRelationshipMutation) SetSubjectID(o object.ID) {
	m.subject = &o
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *SubjectRoleRelationshipMutation) SubjectID() (r object.ID, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldSubjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *SubjectRoleRelationshipMutation) ResetSubjectID() {
	m.subject = nil
}

// SetRoleID sets the "role_id" field.
func (m *SubjectRoleRelationshipMutation) SetRoleID(s string) {
	m.role = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *SubjectRoleRelationshipMutation) RoleID() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *SubjectRoleRelationshipMutation) ResetRoleID() {
	m.role = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *SubjectRoleRelationshipMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *SubjectRoleRelationshipMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *SubjectRoleRelationshipMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *SubjectRoleRelationshipMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *SubjectRoleRelationshipMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) SubjectIDs() (ids []object.ID) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *SubjectRoleRelationshipMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *SubjectRoleRelationshipMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *SubjectRoleRelationshipMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *SubjectRoleRelationshipMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the SubjectRoleRelationshipMutation builder.
func (m *SubjectRoleRelationshipMutation) Where(ps ...predicate.SubjectRoleRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubjectRoleRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubjectRoleRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubjectRoleRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubjectRoleRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubjectRoleRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubjectRoleRelationship).
func (m *SubjectRoleRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectRoleRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, subjectrolerelationship.FieldCreateTime)
	}
	if m.project != nil {
		fields = append(fields, subjectrolerelationship.FieldProjectID)
	}
	if m.subject != nil {
		fields = append(fields, subjectrolerelationship.FieldSubjectID)
	}
	if m.role != nil {
		fields = append(fields, subjectrolerelationship.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectRoleRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		return m.CreateTime()
	case subjectrolerelationship.FieldProjectID:
		return m.ProjectID()
	case subjectrolerelationship.FieldSubjectID:
		return m.SubjectID()
	case subjectrolerelationship.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectRoleRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subjectrolerelationship.FieldProjectID:
		return m.OldProjectID(ctx)
	case subjectrolerelationship.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case subjectrolerelationship.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectRoleRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subjectrolerelationship.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case subjectrolerelationship.FieldSubjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case subjectrolerelationship.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectRoleRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectRoleRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectRoleRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubjectRoleRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectRoleRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subjectrolerelationship.FieldProjectID) {
		fields = append(fields, subjectrolerelationship.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ClearField(name string) error {
	switch name {
	case subjectrolerelationship.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ResetField(name string) error {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subjectrolerelationship.FieldProjectID:
		m.ResetProjectID()
		return nil
	case subjectrolerelationship.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case subjectrolerelationship.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectRoleRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, subjectrolerelationship.EdgeProject)
	}
	if m.subject != nil {
		edges = append(edges, subjectrolerelationship.EdgeSubject)
	}
	if m.role != nil {
		edges = append(edges, subjectrolerelationship.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectRoleRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subjectrolerelationship.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case subjectrolerelationship.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	case subjectrolerelationship.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectRoleRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectRoleRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, subjectrolerelationship.EdgeProject)
	}
	if m.clearedsubject {
		edges = append(edges, subjectrolerelationship.EdgeSubject)
	}
	if m.clearedrole {
		edges = append(edges, subjectrolerelationship.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case subjectrolerelationship.EdgeProject:
		return m.clearedproject
	case subjectrolerelationship.EdgeSubject:
		return m.clearedsubject
	case subjectrolerelationship.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case subjectrolerelationship.EdgeProject:
		m.ClearProject()
		return nil
	case subjectrolerelationship.EdgeSubject:
		m.ClearSubject()
		return nil
	case subjectrolerelationship.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case subjectrolerelationship.EdgeProject:
		m.ResetProject()
		return nil
	case subjectrolerelationship.EdgeSubject:
		m.ResetSubject()
		return nil
	case subjectrolerelationship.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op              Op
	typ             string
	id              *object.ID
	name            *string
	description     *string
	labels          *map[string]string
	create_time     *time.Time
	update_time     *time.Time
	status          *status.Status
	icon            *string
	source          *string
	clearedFields   map[string]struct{}
	versions        map[object.ID]struct{}
	removedversions map[object.ID]struct{}
	clearedversions bool
	catalog         *object.ID
	clearedcatalog  bool
	project         *object.ID
	clearedproject  bool
	done            bool
	oldValue        func(context.Context) (*Template, error)
	predicates      []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id object.ID) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Template entities.
func (m *TemplateMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[template.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[template.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, template.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *TemplateMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *TemplateMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *TemplateMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[template.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *TemplateMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[template.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *TemplateMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, template.FieldLabels)
}

// SetCreateTime sets the "create_time" field.
func (m *TemplateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TemplateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TemplateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TemplateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TemplateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TemplateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *TemplateMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TemplateMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TemplateMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[template.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TemplateMutation) StatusCleared() bool {
	_, ok := m.clearedFields[template.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TemplateMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, template.FieldStatus)
}

// SetIcon sets the "icon" field.
func (m *TemplateMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *TemplateMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *TemplateMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[template.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *TemplateMutation) IconCleared() bool {
	_, ok := m.clearedFields[template.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *TemplateMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, template.FieldIcon)
}

// SetSource sets the "source" field.
func (m *TemplateMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TemplateMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TemplateMutation) ResetSource() {
	m.source = nil
}

// SetCatalogID sets the "catalog_id" field.
func (m *TemplateMutation) SetCatalogID(o object.ID) {
	m.catalog = &o
}

// CatalogID returns the value of the "catalog_id" field in the mutation.
func (m *TemplateMutation) CatalogID() (r object.ID, exists bool) {
	v := m.catalog
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogID returns the old "catalog_id" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCatalogID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogID: %w", err)
	}
	return oldValue.CatalogID, nil
}

// ClearCatalogID clears the value of the "catalog_id" field.
func (m *TemplateMutation) ClearCatalogID() {
	m.catalog = nil
	m.clearedFields[template.FieldCatalogID] = struct{}{}
}

// CatalogIDCleared returns if the "catalog_id" field was cleared in this mutation.
func (m *TemplateMutation) CatalogIDCleared() bool {
	_, ok := m.clearedFields[template.FieldCatalogID]
	return ok
}

// ResetCatalogID resets all changes to the "catalog_id" field.
func (m *TemplateMutation) ResetCatalogID() {
	m.catalog = nil
	delete(m.clearedFields, template.FieldCatalogID)
}

// SetProjectID sets the "project_id" field.
func (m *TemplateMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TemplateMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *TemplateMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[template.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *TemplateMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[template.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TemplateMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, template.FieldProjectID)
}

// AddVersionIDs adds the "versions" edge to the TemplateVersion entity by ids.
func (m *TemplateMutation) AddVersionIDs(ids ...object.ID) {
	if m.versions == nil {
		m.versions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the TemplateVersion entity.
func (m *TemplateMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the TemplateVersion entity was cleared.
func (m *TemplateMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the TemplateVersion entity by IDs.
func (m *TemplateMutation) RemoveVersionIDs(ids ...object.ID) {
	if m.removedversions == nil {
		m.removedversions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the TemplateVersion entity.
func (m *TemplateMutation) RemovedVersionsIDs() (ids []object.ID) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *TemplateMutation) VersionsIDs() (ids []object.ID) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *TemplateMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// ClearCatalog clears the "catalog" edge to the Catalog entity.
func (m *TemplateMutation) ClearCatalog() {
	m.clearedcatalog = true
}

// CatalogCleared reports if the "catalog" edge to the Catalog entity was cleared.
func (m *TemplateMutation) CatalogCleared() bool {
	return m.CatalogIDCleared() || m.clearedcatalog
}

// CatalogIDs returns the "catalog" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CatalogID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) CatalogIDs() (ids []object.ID) {
	if id := m.catalog; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCatalog resets all changes to the "catalog" edge.
func (m *TemplateMutation) ResetCatalog() {
	m.catalog = nil
	m.clearedcatalog = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TemplateMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TemplateMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TemplateMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.description != nil {
		fields = append(fields, template.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, template.FieldLabels)
	}
	if m.create_time != nil {
		fields = append(fields, template.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, template.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, template.FieldStatus)
	}
	if m.icon != nil {
		fields = append(fields, template.FieldIcon)
	}
	if m.source != nil {
		fields = append(fields, template.FieldSource)
	}
	if m.catalog != nil {
		fields = append(fields, template.FieldCatalogID)
	}
	if m.project != nil {
		fields = append(fields, template.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldName:
		return m.Name()
	case template.FieldDescription:
		return m.Description()
	case template.FieldLabels:
		return m.Labels()
	case template.FieldCreateTime:
		return m.CreateTime()
	case template.FieldUpdateTime:
		return m.UpdateTime()
	case template.FieldStatus:
		return m.Status()
	case template.FieldIcon:
		return m.Icon()
	case template.FieldSource:
		return m.Source()
	case template.FieldCatalogID:
		return m.CatalogID()
	case template.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldDescription:
		return m.OldDescription(ctx)
	case template.FieldLabels:
		return m.OldLabels(ctx)
	case template.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case template.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case template.FieldStatus:
		return m.OldStatus(ctx)
	case template.FieldIcon:
		return m.OldIcon(ctx)
	case template.FieldSource:
		return m.OldSource(ctx)
	case template.FieldCatalogID:
		return m.OldCatalogID(ctx)
	case template.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case template.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case template.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case template.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case template.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case template.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case template.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case template.FieldCatalogID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogID(v)
		return nil
	case template.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldDescription) {
		fields = append(fields, template.FieldDescription)
	}
	if m.FieldCleared(template.FieldLabels) {
		fields = append(fields, template.FieldLabels)
	}
	if m.FieldCleared(template.FieldStatus) {
		fields = append(fields, template.FieldStatus)
	}
	if m.FieldCleared(template.FieldIcon) {
		fields = append(fields, template.FieldIcon)
	}
	if m.FieldCleared(template.FieldCatalogID) {
		fields = append(fields, template.FieldCatalogID)
	}
	if m.FieldCleared(template.FieldProjectID) {
		fields = append(fields, template.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldDescription:
		m.ClearDescription()
		return nil
	case template.FieldLabels:
		m.ClearLabels()
		return nil
	case template.FieldStatus:
		m.ClearStatus()
		return nil
	case template.FieldIcon:
		m.ClearIcon()
		return nil
	case template.FieldCatalogID:
		m.ClearCatalogID()
		return nil
	case template.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldDescription:
		m.ResetDescription()
		return nil
	case template.FieldLabels:
		m.ResetLabels()
		return nil
	case template.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case template.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case template.FieldStatus:
		m.ResetStatus()
		return nil
	case template.FieldIcon:
		m.ResetIcon()
		return nil
	case template.FieldSource:
		m.ResetSource()
		return nil
	case template.FieldCatalogID:
		m.ResetCatalogID()
		return nil
	case template.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.versions != nil {
		edges = append(edges, template.EdgeVersions)
	}
	if m.catalog != nil {
		edges = append(edges, template.EdgeCatalog)
	}
	if m.project != nil {
		edges = append(edges, template.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case template.EdgeCatalog:
		if id := m.catalog; id != nil {
			return []ent.Value{*id}
		}
	case template.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedversions != nil {
		edges = append(edges, template.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedversions {
		edges = append(edges, template.EdgeVersions)
	}
	if m.clearedcatalog {
		edges = append(edges, template.EdgeCatalog)
	}
	if m.clearedproject {
		edges = append(edges, template.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case template.EdgeVersions:
		return m.clearedversions
	case template.EdgeCatalog:
		return m.clearedcatalog
	case template.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	switch name {
	case template.EdgeCatalog:
		m.ClearCatalog()
		return nil
	case template.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	switch name {
	case template.EdgeVersions:
		m.ResetVersions()
		return nil
	case template.EdgeCatalog:
		m.ResetCatalog()
		return nil
	case template.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Template edge %s", name)
}

// TemplateVersionMutation represents an operation that mutates the TemplateVersion nodes in the graph.
type TemplateVersionMutation struct {
	config
	op              Op
	typ             string
	id              *object.ID
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	version         *string
	source          *string
	schema          **types.TemplateSchema
	clearedFields   map[string]struct{}
	template        *object.ID
	clearedtemplate bool
	services        map[object.ID]struct{}
	removedservices map[object.ID]struct{}
	clearedservices bool
	project         *object.ID
	clearedproject  bool
	done            bool
	oldValue        func(context.Context) (*TemplateVersion, error)
	predicates      []predicate.TemplateVersion
}

var _ ent.Mutation = (*TemplateVersionMutation)(nil)

// templateVersionOption allows management of the mutation configuration using functional options.
type templateVersionOption func(*TemplateVersionMutation)

// newTemplateVersionMutation creates new mutation for the TemplateVersion entity.
func newTemplateVersionMutation(c config, op Op, opts ...templateVersionOption) *TemplateVersionMutation {
	m := &TemplateVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplateVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateVersionID sets the ID field of the mutation.
func withTemplateVersionID(id object.ID) templateVersionOption {
	return func(m *TemplateVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *TemplateVersion
		)
		m.oldValue = func(ctx context.Context) (*TemplateVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemplateVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplateVersion sets the old TemplateVersion of the mutation.
func withTemplateVersion(node *TemplateVersion) templateVersionOption {
	return func(m *TemplateVersionMutation) {
		m.oldValue = func(context.Context) (*TemplateVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemplateVersion entities.
func (m *TemplateVersionMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateVersionMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateVersionMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemplateVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TemplateVersionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TemplateVersionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TemplateVersionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TemplateVersionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TemplateVersionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TemplateVersionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTemplateID sets the "template_id" field.
func (m *TemplateVersionMutation) SetTemplateID(o object.ID) {
	m.template = &o
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *TemplateVersionMutation) TemplateID() (r object.ID, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldTemplateID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *TemplateVersionMutation) ResetTemplateID() {
	m.template = nil
}

// SetName sets the "name" field.
func (m *TemplateVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateVersionMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *TemplateVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *TemplateVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *TemplateVersionMutation) ResetVersion() {
	m.version = nil
}

// SetSource sets the "source" field.
func (m *TemplateVersionMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TemplateVersionMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TemplateVersionMutation) ResetSource() {
	m.source = nil
}

// SetSchema sets the "schema" field.
func (m *TemplateVersionMutation) SetSchema(ts *types.TemplateSchema) {
	m.schema = &ts
}

// Schema returns the value of the "schema" field in the mutation.
func (m *TemplateVersionMutation) Schema() (r *types.TemplateSchema, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchema returns the old "schema" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldSchema(ctx context.Context) (v *types.TemplateSchema, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchema: %w", err)
	}
	return oldValue.Schema, nil
}

// ResetSchema resets all changes to the "schema" field.
func (m *TemplateVersionMutation) ResetSchema() {
	m.schema = nil
}

// SetProjectID sets the "project_id" field.
func (m *TemplateVersionMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TemplateVersionMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *TemplateVersionMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[templateversion.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *TemplateVersionMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[templateversion.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TemplateVersionMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, templateversion.FieldProjectID)
}

// ClearTemplate clears the "template" edge to the Template entity.
func (m *TemplateVersionMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared reports if the "template" edge to the Template entity was cleared.
func (m *TemplateVersionMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *TemplateVersionMutation) TemplateIDs() (ids []object.ID) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *TemplateVersionMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// AddServiceIDs adds the "services" edge to the Service entity by ids.
func (m *TemplateVersionMutation) AddServiceIDs(ids ...object.ID) {
	if m.services == nil {
		m.services = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Service entity.
func (m *TemplateVersionMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *TemplateVersionMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Service entity by IDs.
func (m *TemplateVersionMutation) RemoveServiceIDs(ids ...object.ID) {
	if m.removedservices == nil {
		m.removedservices = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Service entity.
func (m *TemplateVersionMutation) RemovedServicesIDs() (ids []object.ID) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *TemplateVersionMutation) ServicesIDs() (ids []object.ID) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *TemplateVersionMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TemplateVersionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TemplateVersionMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TemplateVersionMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TemplateVersionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the TemplateVersionMutation builder.
func (m *TemplateVersionMutation) Where(ps ...predicate.TemplateVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemplateVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemplateVersion).
func (m *TemplateVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateVersionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, templateversion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, templateversion.FieldUpdateTime)
	}
	if m.template != nil {
		fields = append(fields, templateversion.FieldTemplateID)
	}
	if m.name != nil {
		fields = append(fields, templateversion.FieldName)
	}
	if m.version != nil {
		fields = append(fields, templateversion.FieldVersion)
	}
	if m.source != nil {
		fields = append(fields, templateversion.FieldSource)
	}
	if m.schema != nil {
		fields = append(fields, templateversion.FieldSchema)
	}
	if m.project != nil {
		fields = append(fields, templateversion.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case templateversion.FieldCreateTime:
		return m.CreateTime()
	case templateversion.FieldUpdateTime:
		return m.UpdateTime()
	case templateversion.FieldTemplateID:
		return m.TemplateID()
	case templateversion.FieldName:
		return m.Name()
	case templateversion.FieldVersion:
		return m.Version()
	case templateversion.FieldSource:
		return m.Source()
	case templateversion.FieldSchema:
		return m.Schema()
	case templateversion.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case templateversion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case templateversion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case templateversion.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case templateversion.FieldName:
		return m.OldName(ctx)
	case templateversion.FieldVersion:
		return m.OldVersion(ctx)
	case templateversion.FieldSource:
		return m.OldSource(ctx)
	case templateversion.FieldSchema:
		return m.OldSchema(ctx)
	case templateversion.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown TemplateVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case templateversion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case templateversion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case templateversion.FieldTemplateID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case templateversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case templateversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case templateversion.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case templateversion.FieldSchema:
		v, ok := value.(*types.TemplateSchema)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchema(v)
		return nil
	case templateversion.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TemplateVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(templateversion.FieldProjectID) {
		fields = append(fields, templateversion.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateVersionMutation) ClearField(name string) error {
	switch name {
	case templateversion.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateVersionMutation) ResetField(name string) error {
	switch name {
	case templateversion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case templateversion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case templateversion.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case templateversion.FieldName:
		m.ResetName()
		return nil
	case templateversion.FieldVersion:
		m.ResetVersion()
		return nil
	case templateversion.FieldSource:
		m.ResetSource()
		return nil
	case templateversion.FieldSchema:
		m.ResetSchema()
		return nil
	case templateversion.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.template != nil {
		edges = append(edges, templateversion.EdgeTemplate)
	}
	if m.services != nil {
		edges = append(edges, templateversion.EdgeServices)
	}
	if m.project != nil {
		edges = append(edges, templateversion.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case templateversion.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case templateversion.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case templateversion.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedservices != nil {
		edges = append(edges, templateversion.EdgeServices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case templateversion.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtemplate {
		edges = append(edges, templateversion.EdgeTemplate)
	}
	if m.clearedservices {
		edges = append(edges, templateversion.EdgeServices)
	}
	if m.clearedproject {
		edges = append(edges, templateversion.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case templateversion.EdgeTemplate:
		return m.clearedtemplate
	case templateversion.EdgeServices:
		return m.clearedservices
	case templateversion.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateVersionMutation) ClearEdge(name string) error {
	switch name {
	case templateversion.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case templateversion.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateVersionMutation) ResetEdge(name string) error {
	switch name {
	case templateversion.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case templateversion.EdgeServices:
		m.ResetServices()
		return nil
	case templateversion.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op             Op
	typ            string
	id             *object.ID
	create_time    *time.Time
	kind           *string
	name           *string
	expiration     *time.Time
	value          *crypto.String
	clearedFields  map[string]struct{}
	subject        *object.ID
	clearedsubject bool
	done           bool
	oldValue       func(context.Context) (*Token, error)
	predicates     []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id object.ID) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *TokenMutation) SetSubjectID(o object.ID) {
	m.subject = &o
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *TokenMutation) SubjectID() (r object.ID, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSubjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *TokenMutation) ResetSubjectID() {
	m.subject = nil
}

// SetKind sets the "kind" field.
func (m *TokenMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *TokenMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *TokenMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *TokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TokenMutation) ResetName() {
	m.name = nil
}

// SetExpiration sets the "expiration" field.
func (m *TokenMutation) SetExpiration(t time.Time) {
	m.expiration = &t
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *TokenMutation) Expiration() (r time.Time, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiration(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ClearExpiration clears the value of the "expiration" field.
func (m *TokenMutation) ClearExpiration() {
	m.expiration = nil
	m.clearedFields[token.FieldExpiration] = struct{}{}
}

// ExpirationCleared returns if the "expiration" field was cleared in this mutation.
func (m *TokenMutation) ExpirationCleared() bool {
	_, ok := m.clearedFields[token.FieldExpiration]
	return ok
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *TokenMutation) ResetExpiration() {
	m.expiration = nil
	delete(m.clearedFields, token.FieldExpiration)
}

// SetValue sets the "value" field.
func (m *TokenMutation) SetValue(c crypto.String) {
	m.value = &c
}

// Value returns the value of the "value" field in the mutation.
func (m *TokenMutation) Value() (r crypto.String, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldValue(ctx context.Context) (v crypto.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *TokenMutation) ResetValue() {
	m.value = nil
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *TokenMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *TokenMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) SubjectIDs() (ids []object.ID) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *TokenMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, token.FieldCreateTime)
	}
	if m.subject != nil {
		fields = append(fields, token.FieldSubjectID)
	}
	if m.kind != nil {
		fields = append(fields, token.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, token.FieldName)
	}
	if m.expiration != nil {
		fields = append(fields, token.FieldExpiration)
	}
	if m.value != nil {
		fields = append(fields, token.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreateTime:
		return m.CreateTime()
	case token.FieldSubjectID:
		return m.SubjectID()
	case token.FieldKind:
		return m.Kind()
	case token.FieldName:
		return m.Name()
	case token.FieldExpiration:
		return m.Expiration()
	case token.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case token.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case token.FieldKind:
		return m.OldKind(ctx)
	case token.FieldName:
		return m.OldName(ctx)
	case token.FieldExpiration:
		return m.OldExpiration(ctx)
	case token.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case token.FieldSubjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case token.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case token.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case token.FieldExpiration:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case token.FieldValue:
		v, ok := value.(crypto.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldExpiration) {
		fields = append(fields, token.FieldExpiration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldExpiration:
		m.ClearExpiration()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case token.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case token.FieldKind:
		m.ResetKind()
		return nil
	case token.FieldName:
		m.ResetName()
		return nil
	case token.FieldExpiration:
		m.ResetExpiration()
		return nil
	case token.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subject != nil {
		edges = append(edges, token.EdgeSubject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubject {
		edges = append(edges, token.EdgeSubject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeSubject:
		return m.clearedsubject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// VariableMutation represents an operation that mutates the Variable nodes in the graph.
type VariableMutation struct {
	config
	op                 Op
	typ                string
	id                 *object.ID
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	value              *crypto.String
	sensitive          *bool
	description        *string
	clearedFields      map[string]struct{}
	project            *object.ID
	clearedproject     bool
	environment        *object.ID
	clearedenvironment bool
	done               bool
	oldValue           func(context.Context) (*Variable, error)
	predicates         []predicate.Variable
}

var _ ent.Mutation = (*VariableMutation)(nil)

// variableOption allows management of the mutation configuration using functional options.
type variableOption func(*VariableMutation)

// newVariableMutation creates new mutation for the Variable entity.
func newVariableMutation(c config, op Op, opts ...variableOption) *VariableMutation {
	m := &VariableMutation{
		config:        c,
		op:            op,
		typ:           TypeVariable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVariableID sets the ID field of the mutation.
func withVariableID(id object.ID) variableOption {
	return func(m *VariableMutation) {
		var (
			err   error
			once  sync.Once
			value *Variable
		)
		m.oldValue = func(ctx context.Context) (*Variable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Variable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVariable sets the old Variable of the mutation.
func withVariable(node *Variable) variableOption {
	return func(m *VariableMutation) {
		m.oldValue = func(context.Context) (*Variable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VariableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VariableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Variable entities.
func (m *VariableMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VariableMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VariableMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Variable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *VariableMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VariableMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VariableMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *VariableMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VariableMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VariableMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *VariableMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *VariableMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *VariableMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[variable.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *VariableMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[variable.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *VariableMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, variable.FieldProjectID)
}

// SetEnvironmentID sets the "environment_id" field.
func (m *VariableMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *VariableMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ClearEnvironmentID clears the value of the "environment_id" field.
func (m *VariableMutation) ClearEnvironmentID() {
	m.environment = nil
	m.clearedFields[variable.FieldEnvironmentID] = struct{}{}
}

// EnvironmentIDCleared returns if the "environment_id" field was cleared in this mutation.
func (m *VariableMutation) EnvironmentIDCleared() bool {
	_, ok := m.clearedFields[variable.FieldEnvironmentID]
	return ok
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *VariableMutation) ResetEnvironmentID() {
	m.environment = nil
	delete(m.clearedFields, variable.FieldEnvironmentID)
}

// SetName sets the "name" field.
func (m *VariableMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VariableMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VariableMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *VariableMutation) SetValue(c crypto.String) {
	m.value = &c
}

// Value returns the value of the "value" field in the mutation.
func (m *VariableMutation) Value() (r crypto.String, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldValue(ctx context.Context) (v crypto.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *VariableMutation) ResetValue() {
	m.value = nil
}

// SetSensitive sets the "sensitive" field.
func (m *VariableMutation) SetSensitive(b bool) {
	m.sensitive = &b
}

// Sensitive returns the value of the "sensitive" field in the mutation.
func (m *VariableMutation) Sensitive() (r bool, exists bool) {
	v := m.sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitive returns the old "sensitive" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitive: %w", err)
	}
	return oldValue.Sensitive, nil
}

// ResetSensitive resets all changes to the "sensitive" field.
func (m *VariableMutation) ResetSensitive() {
	m.sensitive = nil
}

// SetDescription sets the "description" field.
func (m *VariableMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VariableMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VariableMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[variable.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VariableMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[variable.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VariableMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, variable.FieldDescription)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *VariableMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *VariableMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *VariableMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *VariableMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *VariableMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *VariableMutation) EnvironmentCleared() bool {
	return m.EnvironmentIDCleared() || m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *VariableMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *VariableMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// Where appends a list predicates to the VariableMutation builder.
func (m *VariableMutation) Where(ps ...predicate.Variable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VariableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VariableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Variable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VariableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VariableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Variable).
func (m *VariableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VariableMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, variable.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, variable.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, variable.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, variable.FieldEnvironmentID)
	}
	if m.name != nil {
		fields = append(fields, variable.FieldName)
	}
	if m.value != nil {
		fields = append(fields, variable.FieldValue)
	}
	if m.sensitive != nil {
		fields = append(fields, variable.FieldSensitive)
	}
	if m.description != nil {
		fields = append(fields, variable.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VariableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case variable.FieldCreateTime:
		return m.CreateTime()
	case variable.FieldUpdateTime:
		return m.UpdateTime()
	case variable.FieldProjectID:
		return m.ProjectID()
	case variable.FieldEnvironmentID:
		return m.EnvironmentID()
	case variable.FieldName:
		return m.Name()
	case variable.FieldValue:
		return m.Value()
	case variable.FieldSensitive:
		return m.Sensitive()
	case variable.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VariableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case variable.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case variable.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case variable.FieldProjectID:
		return m.OldProjectID(ctx)
	case variable.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case variable.FieldName:
		return m.OldName(ctx)
	case variable.FieldValue:
		return m.OldValue(ctx)
	case variable.FieldSensitive:
		return m.OldSensitive(ctx)
	case variable.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Variable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case variable.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case variable.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case variable.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case variable.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case variable.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case variable.FieldValue:
		v, ok := value.(crypto.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case variable.FieldSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitive(v)
		return nil
	case variable.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Variable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VariableMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VariableMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariableMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Variable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VariableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(variable.FieldProjectID) {
		fields = append(fields, variable.FieldProjectID)
	}
	if m.FieldCleared(variable.FieldEnvironmentID) {
		fields = append(fields, variable.FieldEnvironmentID)
	}
	if m.FieldCleared(variable.FieldDescription) {
		fields = append(fields, variable.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VariableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VariableMutation) ClearField(name string) error {
	switch name {
	case variable.FieldProjectID:
		m.ClearProjectID()
		return nil
	case variable.FieldEnvironmentID:
		m.ClearEnvironmentID()
		return nil
	case variable.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Variable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VariableMutation) ResetField(name string) error {
	switch name {
	case variable.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case variable.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case variable.FieldProjectID:
		m.ResetProjectID()
		return nil
	case variable.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case variable.FieldName:
		m.ResetName()
		return nil
	case variable.FieldValue:
		m.ResetValue()
		return nil
	case variable.FieldSensitive:
		m.ResetSensitive()
		return nil
	case variable.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Variable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VariableMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, variable.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, variable.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VariableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case variable.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case variable.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VariableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VariableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VariableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, variable.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, variable.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VariableMutation) EdgeCleared(name string) bool {
	switch name {
	case variable.EdgeProject:
		return m.clearedproject
	case variable.EdgeEnvironment:
		return m.clearedenvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VariableMutation) ClearEdge(name string) error {
	switch name {
	case variable.EdgeProject:
		m.ClearProject()
		return nil
	case variable.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Variable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VariableMutation) ResetEdge(name string) error {
	switch name {
	case variable.EdgeProject:
		m.ResetProject()
		return nil
	case variable.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Variable edge %s", name)
}
