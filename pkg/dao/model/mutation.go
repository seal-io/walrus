// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "ent". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"

	"github.com/seal-io/seal/pkg/dao/model/allocationcost"
	"github.com/seal-io/seal/pkg/dao/model/clustercost"
	"github.com/seal-io/seal/pkg/dao/model/connector"
	"github.com/seal-io/seal/pkg/dao/model/environment"
	"github.com/seal-io/seal/pkg/dao/model/environmentconnectorrelationship"
	"github.com/seal-io/seal/pkg/dao/model/perspective"
	"github.com/seal-io/seal/pkg/dao/model/predicate"
	"github.com/seal-io/seal/pkg/dao/model/project"
	"github.com/seal-io/seal/pkg/dao/model/role"
	"github.com/seal-io/seal/pkg/dao/model/secret"
	"github.com/seal-io/seal/pkg/dao/model/service"
	"github.com/seal-io/seal/pkg/dao/model/servicedependency"
	"github.com/seal-io/seal/pkg/dao/model/serviceresource"
	"github.com/seal-io/seal/pkg/dao/model/servicerevision"
	"github.com/seal-io/seal/pkg/dao/model/setting"
	"github.com/seal-io/seal/pkg/dao/model/subject"
	"github.com/seal-io/seal/pkg/dao/model/subjectrolerelationship"
	"github.com/seal-io/seal/pkg/dao/model/template"
	"github.com/seal-io/seal/pkg/dao/model/templateversion"
	"github.com/seal-io/seal/pkg/dao/model/token"
	"github.com/seal-io/seal/pkg/dao/types"
	"github.com/seal-io/seal/pkg/dao/types/crypto"
	"github.com/seal-io/seal/pkg/dao/types/oid"
	"github.com/seal-io/seal/pkg/dao/types/property"
	"github.com/seal-io/seal/pkg/dao/types/status"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAllocationCost                   = "AllocationCost"
	TypeClusterCost                      = "ClusterCost"
	TypeConnector                        = "Connector"
	TypeEnvironment                      = "Environment"
	TypeEnvironmentConnectorRelationship = "EnvironmentConnectorRelationship"
	TypePerspective                      = "Perspective"
	TypeProject                          = "Project"
	TypeRole                             = "Role"
	TypeSecret                           = "Secret"
	TypeService                          = "Service"
	TypeServiceDependency                = "ServiceDependency"
	TypeServiceResource                  = "ServiceResource"
	TypeServiceRevision                  = "ServiceRevision"
	TypeSetting                          = "Setting"
	TypeSubject                          = "Subject"
	TypeSubjectRoleRelationship          = "SubjectRoleRelationship"
	TypeTemplate                         = "Template"
	TypeTemplateVersion                  = "TemplateVersion"
	TypeToken                            = "Token"
)

// AllocationCostMutation represents an operation that mutates the AllocationCost nodes in the graph.
type AllocationCostMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	startTime              *time.Time
	endTime                *time.Time
	minutes                *float64
	addminutes             *float64
	name                   *string
	fingerprint            *string
	clusterName            *string
	namespace              *string
	node                   *string
	controller             *string
	controllerKind         *string
	pod                    *string
	container              *string
	pvs                    *map[string]types.PVCost
	labels                 *map[string]string
	totalCost              *float64
	addtotalCost           *float64
	currency               *int
	addcurrency            *int
	cpuCost                *float64
	addcpuCost             *float64
	cpuCoreRequest         *float64
	addcpuCoreRequest      *float64
	gpuCost                *float64
	addgpuCost             *float64
	gpuCount               *float64
	addgpuCount            *float64
	ramCost                *float64
	addramCost             *float64
	ramByteRequest         *float64
	addramByteRequest      *float64
	pvCost                 *float64
	addpvCost              *float64
	pvBytes                *float64
	addpvBytes             *float64
	loadBalancerCost       *float64
	addloadBalancerCost    *float64
	cpuCoreUsageAverage    *float64
	addcpuCoreUsageAverage *float64
	cpuCoreUsageMax        *float64
	addcpuCoreUsageMax     *float64
	ramByteUsageAverage    *float64
	addramByteUsageAverage *float64
	ramByteUsageMax        *float64
	addramByteUsageMax     *float64
	clearedFields          map[string]struct{}
	connector              *oid.ID
	clearedconnector       bool
	done                   bool
	oldValue               func(context.Context) (*AllocationCost, error)
	predicates             []predicate.AllocationCost
}

var _ ent.Mutation = (*AllocationCostMutation)(nil)

// allocationCostOption allows management of the mutation configuration using functional options.
type allocationCostOption func(*AllocationCostMutation)

// newAllocationCostMutation creates new mutation for the AllocationCost entity.
func newAllocationCostMutation(c config, op Op, opts ...allocationCostOption) *AllocationCostMutation {
	m := &AllocationCostMutation{
		config:        c,
		op:            op,
		typ:           TypeAllocationCost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAllocationCostID sets the ID field of the mutation.
func withAllocationCostID(id int) allocationCostOption {
	return func(m *AllocationCostMutation) {
		var (
			err   error
			once  sync.Once
			value *AllocationCost
		)
		m.oldValue = func(ctx context.Context) (*AllocationCost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AllocationCost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAllocationCost sets the old AllocationCost of the mutation.
func withAllocationCost(node *AllocationCost) allocationCostOption {
	return func(m *AllocationCostMutation) {
		m.oldValue = func(context.Context) (*AllocationCost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AllocationCostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AllocationCostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AllocationCostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AllocationCostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AllocationCost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartTime sets the "startTime" field.
func (m *AllocationCostMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *AllocationCostMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *AllocationCostMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *AllocationCostMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *AllocationCostMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *AllocationCostMutation) ResetEndTime() {
	m.endTime = nil
}

// SetMinutes sets the "minutes" field.
func (m *AllocationCostMutation) SetMinutes(f float64) {
	m.minutes = &f
	m.addminutes = nil
}

// Minutes returns the value of the "minutes" field in the mutation.
func (m *AllocationCostMutation) Minutes() (r float64, exists bool) {
	v := m.minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldMinutes returns the old "minutes" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldMinutes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinutes: %w", err)
	}
	return oldValue.Minutes, nil
}

// AddMinutes adds f to the "minutes" field.
func (m *AllocationCostMutation) AddMinutes(f float64) {
	if m.addminutes != nil {
		*m.addminutes += f
	} else {
		m.addminutes = &f
	}
}

// AddedMinutes returns the value that was added to the "minutes" field in this mutation.
func (m *AllocationCostMutation) AddedMinutes() (r float64, exists bool) {
	v := m.addminutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinutes resets all changes to the "minutes" field.
func (m *AllocationCostMutation) ResetMinutes() {
	m.minutes = nil
	m.addminutes = nil
}

// SetConnectorID sets the "connectorID" field.
func (m *AllocationCostMutation) SetConnectorID(o oid.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connectorID" field in the mutation.
func (m *AllocationCostMutation) ConnectorID() (r oid.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connectorID" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldConnectorID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connectorID" field.
func (m *AllocationCostMutation) ResetConnectorID() {
	m.connector = nil
}

// SetName sets the "name" field.
func (m *AllocationCostMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AllocationCostMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AllocationCostMutation) ResetName() {
	m.name = nil
}

// SetFingerprint sets the "fingerprint" field.
func (m *AllocationCostMutation) SetFingerprint(s string) {
	m.fingerprint = &s
}

// Fingerprint returns the value of the "fingerprint" field in the mutation.
func (m *AllocationCostMutation) Fingerprint() (r string, exists bool) {
	v := m.fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprint returns the old "fingerprint" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprint: %w", err)
	}
	return oldValue.Fingerprint, nil
}

// ResetFingerprint resets all changes to the "fingerprint" field.
func (m *AllocationCostMutation) ResetFingerprint() {
	m.fingerprint = nil
}

// SetClusterName sets the "clusterName" field.
func (m *AllocationCostMutation) SetClusterName(s string) {
	m.clusterName = &s
}

// ClusterName returns the value of the "clusterName" field in the mutation.
func (m *AllocationCostMutation) ClusterName() (r string, exists bool) {
	v := m.clusterName
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterName returns the old "clusterName" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldClusterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClusterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClusterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterName: %w", err)
	}
	return oldValue.ClusterName, nil
}

// ClearClusterName clears the value of the "clusterName" field.
func (m *AllocationCostMutation) ClearClusterName() {
	m.clusterName = nil
	m.clearedFields[allocationcost.FieldClusterName] = struct{}{}
}

// ClusterNameCleared returns if the "clusterName" field was cleared in this mutation.
func (m *AllocationCostMutation) ClusterNameCleared() bool {
	_, ok := m.clearedFields[allocationcost.FieldClusterName]
	return ok
}

// ResetClusterName resets all changes to the "clusterName" field.
func (m *AllocationCostMutation) ResetClusterName() {
	m.clusterName = nil
	delete(m.clearedFields, allocationcost.FieldClusterName)
}

// SetNamespace sets the "namespace" field.
func (m *AllocationCostMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *AllocationCostMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ClearNamespace clears the value of the "namespace" field.
func (m *AllocationCostMutation) ClearNamespace() {
	m.namespace = nil
	m.clearedFields[allocationcost.FieldNamespace] = struct{}{}
}

// NamespaceCleared returns if the "namespace" field was cleared in this mutation.
func (m *AllocationCostMutation) NamespaceCleared() bool {
	_, ok := m.clearedFields[allocationcost.FieldNamespace]
	return ok
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *AllocationCostMutation) ResetNamespace() {
	m.namespace = nil
	delete(m.clearedFields, allocationcost.FieldNamespace)
}

// SetNode sets the "node" field.
func (m *AllocationCostMutation) SetNode(s string) {
	m.node = &s
}

// Node returns the value of the "node" field in the mutation.
func (m *AllocationCostMutation) Node() (r string, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNode returns the old "node" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldNode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNode: %w", err)
	}
	return oldValue.Node, nil
}

// ClearNode clears the value of the "node" field.
func (m *AllocationCostMutation) ClearNode() {
	m.node = nil
	m.clearedFields[allocationcost.FieldNode] = struct{}{}
}

// NodeCleared returns if the "node" field was cleared in this mutation.
func (m *AllocationCostMutation) NodeCleared() bool {
	_, ok := m.clearedFields[allocationcost.FieldNode]
	return ok
}

// ResetNode resets all changes to the "node" field.
func (m *AllocationCostMutation) ResetNode() {
	m.node = nil
	delete(m.clearedFields, allocationcost.FieldNode)
}

// SetController sets the "controller" field.
func (m *AllocationCostMutation) SetController(s string) {
	m.controller = &s
}

// Controller returns the value of the "controller" field in the mutation.
func (m *AllocationCostMutation) Controller() (r string, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldController returns the old "controller" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldController(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldController: %w", err)
	}
	return oldValue.Controller, nil
}

// ClearController clears the value of the "controller" field.
func (m *AllocationCostMutation) ClearController() {
	m.controller = nil
	m.clearedFields[allocationcost.FieldController] = struct{}{}
}

// ControllerCleared returns if the "controller" field was cleared in this mutation.
func (m *AllocationCostMutation) ControllerCleared() bool {
	_, ok := m.clearedFields[allocationcost.FieldController]
	return ok
}

// ResetController resets all changes to the "controller" field.
func (m *AllocationCostMutation) ResetController() {
	m.controller = nil
	delete(m.clearedFields, allocationcost.FieldController)
}

// SetControllerKind sets the "controllerKind" field.
func (m *AllocationCostMutation) SetControllerKind(s string) {
	m.controllerKind = &s
}

// ControllerKind returns the value of the "controllerKind" field in the mutation.
func (m *AllocationCostMutation) ControllerKind() (r string, exists bool) {
	v := m.controllerKind
	if v == nil {
		return
	}
	return *v, true
}

// OldControllerKind returns the old "controllerKind" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldControllerKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControllerKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControllerKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControllerKind: %w", err)
	}
	return oldValue.ControllerKind, nil
}

// ClearControllerKind clears the value of the "controllerKind" field.
func (m *AllocationCostMutation) ClearControllerKind() {
	m.controllerKind = nil
	m.clearedFields[allocationcost.FieldControllerKind] = struct{}{}
}

// ControllerKindCleared returns if the "controllerKind" field was cleared in this mutation.
func (m *AllocationCostMutation) ControllerKindCleared() bool {
	_, ok := m.clearedFields[allocationcost.FieldControllerKind]
	return ok
}

// ResetControllerKind resets all changes to the "controllerKind" field.
func (m *AllocationCostMutation) ResetControllerKind() {
	m.controllerKind = nil
	delete(m.clearedFields, allocationcost.FieldControllerKind)
}

// SetPod sets the "pod" field.
func (m *AllocationCostMutation) SetPod(s string) {
	m.pod = &s
}

// Pod returns the value of the "pod" field in the mutation.
func (m *AllocationCostMutation) Pod() (r string, exists bool) {
	v := m.pod
	if v == nil {
		return
	}
	return *v, true
}

// OldPod returns the old "pod" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldPod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPod: %w", err)
	}
	return oldValue.Pod, nil
}

// ClearPod clears the value of the "pod" field.
func (m *AllocationCostMutation) ClearPod() {
	m.pod = nil
	m.clearedFields[allocationcost.FieldPod] = struct{}{}
}

// PodCleared returns if the "pod" field was cleared in this mutation.
func (m *AllocationCostMutation) PodCleared() bool {
	_, ok := m.clearedFields[allocationcost.FieldPod]
	return ok
}

// ResetPod resets all changes to the "pod" field.
func (m *AllocationCostMutation) ResetPod() {
	m.pod = nil
	delete(m.clearedFields, allocationcost.FieldPod)
}

// SetContainer sets the "container" field.
func (m *AllocationCostMutation) SetContainer(s string) {
	m.container = &s
}

// Container returns the value of the "container" field in the mutation.
func (m *AllocationCostMutation) Container() (r string, exists bool) {
	v := m.container
	if v == nil {
		return
	}
	return *v, true
}

// OldContainer returns the old "container" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldContainer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainer: %w", err)
	}
	return oldValue.Container, nil
}

// ClearContainer clears the value of the "container" field.
func (m *AllocationCostMutation) ClearContainer() {
	m.container = nil
	m.clearedFields[allocationcost.FieldContainer] = struct{}{}
}

// ContainerCleared returns if the "container" field was cleared in this mutation.
func (m *AllocationCostMutation) ContainerCleared() bool {
	_, ok := m.clearedFields[allocationcost.FieldContainer]
	return ok
}

// ResetContainer resets all changes to the "container" field.
func (m *AllocationCostMutation) ResetContainer() {
	m.container = nil
	delete(m.clearedFields, allocationcost.FieldContainer)
}

// SetPvs sets the "pvs" field.
func (m *AllocationCostMutation) SetPvs(mc map[string]types.PVCost) {
	m.pvs = &mc
}

// Pvs returns the value of the "pvs" field in the mutation.
func (m *AllocationCostMutation) Pvs() (r map[string]types.PVCost, exists bool) {
	v := m.pvs
	if v == nil {
		return
	}
	return *v, true
}

// OldPvs returns the old "pvs" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldPvs(ctx context.Context) (v map[string]types.PVCost, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPvs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPvs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPvs: %w", err)
	}
	return oldValue.Pvs, nil
}

// ResetPvs resets all changes to the "pvs" field.
func (m *AllocationCostMutation) ResetPvs() {
	m.pvs = nil
}

// SetLabels sets the "labels" field.
func (m *AllocationCostMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *AllocationCostMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ResetLabels resets all changes to the "labels" field.
func (m *AllocationCostMutation) ResetLabels() {
	m.labels = nil
}

// SetTotalCost sets the "totalCost" field.
func (m *AllocationCostMutation) SetTotalCost(f float64) {
	m.totalCost = &f
	m.addtotalCost = nil
}

// TotalCost returns the value of the "totalCost" field in the mutation.
func (m *AllocationCostMutation) TotalCost() (r float64, exists bool) {
	v := m.totalCost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "totalCost" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldTotalCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "totalCost" field.
func (m *AllocationCostMutation) AddTotalCost(f float64) {
	if m.addtotalCost != nil {
		*m.addtotalCost += f
	} else {
		m.addtotalCost = &f
	}
}

// AddedTotalCost returns the value that was added to the "totalCost" field in this mutation.
func (m *AllocationCostMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotalCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCost resets all changes to the "totalCost" field.
func (m *AllocationCostMutation) ResetTotalCost() {
	m.totalCost = nil
	m.addtotalCost = nil
}

// SetCurrency sets the "currency" field.
func (m *AllocationCostMutation) SetCurrency(i int) {
	m.currency = &i
	m.addcurrency = nil
}

// Currency returns the value of the "currency" field in the mutation.
func (m *AllocationCostMutation) Currency() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldCurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// AddCurrency adds i to the "currency" field.
func (m *AllocationCostMutation) AddCurrency(i int) {
	if m.addcurrency != nil {
		*m.addcurrency += i
	} else {
		m.addcurrency = &i
	}
}

// AddedCurrency returns the value that was added to the "currency" field in this mutation.
func (m *AllocationCostMutation) AddedCurrency() (r int, exists bool) {
	v := m.addcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrency clears the value of the "currency" field.
func (m *AllocationCostMutation) ClearCurrency() {
	m.currency = nil
	m.addcurrency = nil
	m.clearedFields[allocationcost.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *AllocationCostMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[allocationcost.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *AllocationCostMutation) ResetCurrency() {
	m.currency = nil
	m.addcurrency = nil
	delete(m.clearedFields, allocationcost.FieldCurrency)
}

// SetCpuCost sets the "cpuCost" field.
func (m *AllocationCostMutation) SetCpuCost(f float64) {
	m.cpuCost = &f
	m.addcpuCost = nil
}

// CpuCost returns the value of the "cpuCost" field in the mutation.
func (m *AllocationCostMutation) CpuCost() (r float64, exists bool) {
	v := m.cpuCost
	if v == nil {
		return
	}
	return *v, true
}

// OldCpuCost returns the old "cpuCost" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldCpuCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCpuCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCpuCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCpuCost: %w", err)
	}
	return oldValue.CpuCost, nil
}

// AddCpuCost adds f to the "cpuCost" field.
func (m *AllocationCostMutation) AddCpuCost(f float64) {
	if m.addcpuCost != nil {
		*m.addcpuCost += f
	} else {
		m.addcpuCost = &f
	}
}

// AddedCpuCost returns the value that was added to the "cpuCost" field in this mutation.
func (m *AllocationCostMutation) AddedCpuCost() (r float64, exists bool) {
	v := m.addcpuCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCpuCost resets all changes to the "cpuCost" field.
func (m *AllocationCostMutation) ResetCpuCost() {
	m.cpuCost = nil
	m.addcpuCost = nil
}

// SetCpuCoreRequest sets the "cpuCoreRequest" field.
func (m *AllocationCostMutation) SetCpuCoreRequest(f float64) {
	m.cpuCoreRequest = &f
	m.addcpuCoreRequest = nil
}

// CpuCoreRequest returns the value of the "cpuCoreRequest" field in the mutation.
func (m *AllocationCostMutation) CpuCoreRequest() (r float64, exists bool) {
	v := m.cpuCoreRequest
	if v == nil {
		return
	}
	return *v, true
}

// OldCpuCoreRequest returns the old "cpuCoreRequest" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldCpuCoreRequest(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCpuCoreRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCpuCoreRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCpuCoreRequest: %w", err)
	}
	return oldValue.CpuCoreRequest, nil
}

// AddCpuCoreRequest adds f to the "cpuCoreRequest" field.
func (m *AllocationCostMutation) AddCpuCoreRequest(f float64) {
	if m.addcpuCoreRequest != nil {
		*m.addcpuCoreRequest += f
	} else {
		m.addcpuCoreRequest = &f
	}
}

// AddedCpuCoreRequest returns the value that was added to the "cpuCoreRequest" field in this mutation.
func (m *AllocationCostMutation) AddedCpuCoreRequest() (r float64, exists bool) {
	v := m.addcpuCoreRequest
	if v == nil {
		return
	}
	return *v, true
}

// ResetCpuCoreRequest resets all changes to the "cpuCoreRequest" field.
func (m *AllocationCostMutation) ResetCpuCoreRequest() {
	m.cpuCoreRequest = nil
	m.addcpuCoreRequest = nil
}

// SetGpuCost sets the "gpuCost" field.
func (m *AllocationCostMutation) SetGpuCost(f float64) {
	m.gpuCost = &f
	m.addgpuCost = nil
}

// GpuCost returns the value of the "gpuCost" field in the mutation.
func (m *AllocationCostMutation) GpuCost() (r float64, exists bool) {
	v := m.gpuCost
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuCost returns the old "gpuCost" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldGpuCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuCost: %w", err)
	}
	return oldValue.GpuCost, nil
}

// AddGpuCost adds f to the "gpuCost" field.
func (m *AllocationCostMutation) AddGpuCost(f float64) {
	if m.addgpuCost != nil {
		*m.addgpuCost += f
	} else {
		m.addgpuCost = &f
	}
}

// AddedGpuCost returns the value that was added to the "gpuCost" field in this mutation.
func (m *AllocationCostMutation) AddedGpuCost() (r float64, exists bool) {
	v := m.addgpuCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetGpuCost resets all changes to the "gpuCost" field.
func (m *AllocationCostMutation) ResetGpuCost() {
	m.gpuCost = nil
	m.addgpuCost = nil
}

// SetGpuCount sets the "gpuCount" field.
func (m *AllocationCostMutation) SetGpuCount(f float64) {
	m.gpuCount = &f
	m.addgpuCount = nil
}

// GpuCount returns the value of the "gpuCount" field in the mutation.
func (m *AllocationCostMutation) GpuCount() (r float64, exists bool) {
	v := m.gpuCount
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuCount returns the old "gpuCount" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldGpuCount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuCount: %w", err)
	}
	return oldValue.GpuCount, nil
}

// AddGpuCount adds f to the "gpuCount" field.
func (m *AllocationCostMutation) AddGpuCount(f float64) {
	if m.addgpuCount != nil {
		*m.addgpuCount += f
	} else {
		m.addgpuCount = &f
	}
}

// AddedGpuCount returns the value that was added to the "gpuCount" field in this mutation.
func (m *AllocationCostMutation) AddedGpuCount() (r float64, exists bool) {
	v := m.addgpuCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetGpuCount resets all changes to the "gpuCount" field.
func (m *AllocationCostMutation) ResetGpuCount() {
	m.gpuCount = nil
	m.addgpuCount = nil
}

// SetRamCost sets the "ramCost" field.
func (m *AllocationCostMutation) SetRamCost(f float64) {
	m.ramCost = &f
	m.addramCost = nil
}

// RamCost returns the value of the "ramCost" field in the mutation.
func (m *AllocationCostMutation) RamCost() (r float64, exists bool) {
	v := m.ramCost
	if v == nil {
		return
	}
	return *v, true
}

// OldRamCost returns the old "ramCost" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldRamCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRamCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRamCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRamCost: %w", err)
	}
	return oldValue.RamCost, nil
}

// AddRamCost adds f to the "ramCost" field.
func (m *AllocationCostMutation) AddRamCost(f float64) {
	if m.addramCost != nil {
		*m.addramCost += f
	} else {
		m.addramCost = &f
	}
}

// AddedRamCost returns the value that was added to the "ramCost" field in this mutation.
func (m *AllocationCostMutation) AddedRamCost() (r float64, exists bool) {
	v := m.addramCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetRamCost resets all changes to the "ramCost" field.
func (m *AllocationCostMutation) ResetRamCost() {
	m.ramCost = nil
	m.addramCost = nil
}

// SetRamByteRequest sets the "ramByteRequest" field.
func (m *AllocationCostMutation) SetRamByteRequest(f float64) {
	m.ramByteRequest = &f
	m.addramByteRequest = nil
}

// RamByteRequest returns the value of the "ramByteRequest" field in the mutation.
func (m *AllocationCostMutation) RamByteRequest() (r float64, exists bool) {
	v := m.ramByteRequest
	if v == nil {
		return
	}
	return *v, true
}

// OldRamByteRequest returns the old "ramByteRequest" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldRamByteRequest(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRamByteRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRamByteRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRamByteRequest: %w", err)
	}
	return oldValue.RamByteRequest, nil
}

// AddRamByteRequest adds f to the "ramByteRequest" field.
func (m *AllocationCostMutation) AddRamByteRequest(f float64) {
	if m.addramByteRequest != nil {
		*m.addramByteRequest += f
	} else {
		m.addramByteRequest = &f
	}
}

// AddedRamByteRequest returns the value that was added to the "ramByteRequest" field in this mutation.
func (m *AllocationCostMutation) AddedRamByteRequest() (r float64, exists bool) {
	v := m.addramByteRequest
	if v == nil {
		return
	}
	return *v, true
}

// ResetRamByteRequest resets all changes to the "ramByteRequest" field.
func (m *AllocationCostMutation) ResetRamByteRequest() {
	m.ramByteRequest = nil
	m.addramByteRequest = nil
}

// SetPvCost sets the "pvCost" field.
func (m *AllocationCostMutation) SetPvCost(f float64) {
	m.pvCost = &f
	m.addpvCost = nil
}

// PvCost returns the value of the "pvCost" field in the mutation.
func (m *AllocationCostMutation) PvCost() (r float64, exists bool) {
	v := m.pvCost
	if v == nil {
		return
	}
	return *v, true
}

// OldPvCost returns the old "pvCost" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldPvCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPvCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPvCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPvCost: %w", err)
	}
	return oldValue.PvCost, nil
}

// AddPvCost adds f to the "pvCost" field.
func (m *AllocationCostMutation) AddPvCost(f float64) {
	if m.addpvCost != nil {
		*m.addpvCost += f
	} else {
		m.addpvCost = &f
	}
}

// AddedPvCost returns the value that was added to the "pvCost" field in this mutation.
func (m *AllocationCostMutation) AddedPvCost() (r float64, exists bool) {
	v := m.addpvCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetPvCost resets all changes to the "pvCost" field.
func (m *AllocationCostMutation) ResetPvCost() {
	m.pvCost = nil
	m.addpvCost = nil
}

// SetPvBytes sets the "pvBytes" field.
func (m *AllocationCostMutation) SetPvBytes(f float64) {
	m.pvBytes = &f
	m.addpvBytes = nil
}

// PvBytes returns the value of the "pvBytes" field in the mutation.
func (m *AllocationCostMutation) PvBytes() (r float64, exists bool) {
	v := m.pvBytes
	if v == nil {
		return
	}
	return *v, true
}

// OldPvBytes returns the old "pvBytes" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldPvBytes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPvBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPvBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPvBytes: %w", err)
	}
	return oldValue.PvBytes, nil
}

// AddPvBytes adds f to the "pvBytes" field.
func (m *AllocationCostMutation) AddPvBytes(f float64) {
	if m.addpvBytes != nil {
		*m.addpvBytes += f
	} else {
		m.addpvBytes = &f
	}
}

// AddedPvBytes returns the value that was added to the "pvBytes" field in this mutation.
func (m *AllocationCostMutation) AddedPvBytes() (r float64, exists bool) {
	v := m.addpvBytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetPvBytes resets all changes to the "pvBytes" field.
func (m *AllocationCostMutation) ResetPvBytes() {
	m.pvBytes = nil
	m.addpvBytes = nil
}

// SetLoadBalancerCost sets the "loadBalancerCost" field.
func (m *AllocationCostMutation) SetLoadBalancerCost(f float64) {
	m.loadBalancerCost = &f
	m.addloadBalancerCost = nil
}

// LoadBalancerCost returns the value of the "loadBalancerCost" field in the mutation.
func (m *AllocationCostMutation) LoadBalancerCost() (r float64, exists bool) {
	v := m.loadBalancerCost
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadBalancerCost returns the old "loadBalancerCost" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldLoadBalancerCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoadBalancerCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoadBalancerCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadBalancerCost: %w", err)
	}
	return oldValue.LoadBalancerCost, nil
}

// AddLoadBalancerCost adds f to the "loadBalancerCost" field.
func (m *AllocationCostMutation) AddLoadBalancerCost(f float64) {
	if m.addloadBalancerCost != nil {
		*m.addloadBalancerCost += f
	} else {
		m.addloadBalancerCost = &f
	}
}

// AddedLoadBalancerCost returns the value that was added to the "loadBalancerCost" field in this mutation.
func (m *AllocationCostMutation) AddedLoadBalancerCost() (r float64, exists bool) {
	v := m.addloadBalancerCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoadBalancerCost resets all changes to the "loadBalancerCost" field.
func (m *AllocationCostMutation) ResetLoadBalancerCost() {
	m.loadBalancerCost = nil
	m.addloadBalancerCost = nil
}

// SetCpuCoreUsageAverage sets the "cpuCoreUsageAverage" field.
func (m *AllocationCostMutation) SetCpuCoreUsageAverage(f float64) {
	m.cpuCoreUsageAverage = &f
	m.addcpuCoreUsageAverage = nil
}

// CpuCoreUsageAverage returns the value of the "cpuCoreUsageAverage" field in the mutation.
func (m *AllocationCostMutation) CpuCoreUsageAverage() (r float64, exists bool) {
	v := m.cpuCoreUsageAverage
	if v == nil {
		return
	}
	return *v, true
}

// OldCpuCoreUsageAverage returns the old "cpuCoreUsageAverage" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldCpuCoreUsageAverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCpuCoreUsageAverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCpuCoreUsageAverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCpuCoreUsageAverage: %w", err)
	}
	return oldValue.CpuCoreUsageAverage, nil
}

// AddCpuCoreUsageAverage adds f to the "cpuCoreUsageAverage" field.
func (m *AllocationCostMutation) AddCpuCoreUsageAverage(f float64) {
	if m.addcpuCoreUsageAverage != nil {
		*m.addcpuCoreUsageAverage += f
	} else {
		m.addcpuCoreUsageAverage = &f
	}
}

// AddedCpuCoreUsageAverage returns the value that was added to the "cpuCoreUsageAverage" field in this mutation.
func (m *AllocationCostMutation) AddedCpuCoreUsageAverage() (r float64, exists bool) {
	v := m.addcpuCoreUsageAverage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCpuCoreUsageAverage resets all changes to the "cpuCoreUsageAverage" field.
func (m *AllocationCostMutation) ResetCpuCoreUsageAverage() {
	m.cpuCoreUsageAverage = nil
	m.addcpuCoreUsageAverage = nil
}

// SetCpuCoreUsageMax sets the "cpuCoreUsageMax" field.
func (m *AllocationCostMutation) SetCpuCoreUsageMax(f float64) {
	m.cpuCoreUsageMax = &f
	m.addcpuCoreUsageMax = nil
}

// CpuCoreUsageMax returns the value of the "cpuCoreUsageMax" field in the mutation.
func (m *AllocationCostMutation) CpuCoreUsageMax() (r float64, exists bool) {
	v := m.cpuCoreUsageMax
	if v == nil {
		return
	}
	return *v, true
}

// OldCpuCoreUsageMax returns the old "cpuCoreUsageMax" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldCpuCoreUsageMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCpuCoreUsageMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCpuCoreUsageMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCpuCoreUsageMax: %w", err)
	}
	return oldValue.CpuCoreUsageMax, nil
}

// AddCpuCoreUsageMax adds f to the "cpuCoreUsageMax" field.
func (m *AllocationCostMutation) AddCpuCoreUsageMax(f float64) {
	if m.addcpuCoreUsageMax != nil {
		*m.addcpuCoreUsageMax += f
	} else {
		m.addcpuCoreUsageMax = &f
	}
}

// AddedCpuCoreUsageMax returns the value that was added to the "cpuCoreUsageMax" field in this mutation.
func (m *AllocationCostMutation) AddedCpuCoreUsageMax() (r float64, exists bool) {
	v := m.addcpuCoreUsageMax
	if v == nil {
		return
	}
	return *v, true
}

// ResetCpuCoreUsageMax resets all changes to the "cpuCoreUsageMax" field.
func (m *AllocationCostMutation) ResetCpuCoreUsageMax() {
	m.cpuCoreUsageMax = nil
	m.addcpuCoreUsageMax = nil
}

// SetRamByteUsageAverage sets the "ramByteUsageAverage" field.
func (m *AllocationCostMutation) SetRamByteUsageAverage(f float64) {
	m.ramByteUsageAverage = &f
	m.addramByteUsageAverage = nil
}

// RamByteUsageAverage returns the value of the "ramByteUsageAverage" field in the mutation.
func (m *AllocationCostMutation) RamByteUsageAverage() (r float64, exists bool) {
	v := m.ramByteUsageAverage
	if v == nil {
		return
	}
	return *v, true
}

// OldRamByteUsageAverage returns the old "ramByteUsageAverage" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldRamByteUsageAverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRamByteUsageAverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRamByteUsageAverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRamByteUsageAverage: %w", err)
	}
	return oldValue.RamByteUsageAverage, nil
}

// AddRamByteUsageAverage adds f to the "ramByteUsageAverage" field.
func (m *AllocationCostMutation) AddRamByteUsageAverage(f float64) {
	if m.addramByteUsageAverage != nil {
		*m.addramByteUsageAverage += f
	} else {
		m.addramByteUsageAverage = &f
	}
}

// AddedRamByteUsageAverage returns the value that was added to the "ramByteUsageAverage" field in this mutation.
func (m *AllocationCostMutation) AddedRamByteUsageAverage() (r float64, exists bool) {
	v := m.addramByteUsageAverage
	if v == nil {
		return
	}
	return *v, true
}

// ResetRamByteUsageAverage resets all changes to the "ramByteUsageAverage" field.
func (m *AllocationCostMutation) ResetRamByteUsageAverage() {
	m.ramByteUsageAverage = nil
	m.addramByteUsageAverage = nil
}

// SetRamByteUsageMax sets the "ramByteUsageMax" field.
func (m *AllocationCostMutation) SetRamByteUsageMax(f float64) {
	m.ramByteUsageMax = &f
	m.addramByteUsageMax = nil
}

// RamByteUsageMax returns the value of the "ramByteUsageMax" field in the mutation.
func (m *AllocationCostMutation) RamByteUsageMax() (r float64, exists bool) {
	v := m.ramByteUsageMax
	if v == nil {
		return
	}
	return *v, true
}

// OldRamByteUsageMax returns the old "ramByteUsageMax" field's value of the AllocationCost entity.
// If the AllocationCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocationCostMutation) OldRamByteUsageMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRamByteUsageMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRamByteUsageMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRamByteUsageMax: %w", err)
	}
	return oldValue.RamByteUsageMax, nil
}

// AddRamByteUsageMax adds f to the "ramByteUsageMax" field.
func (m *AllocationCostMutation) AddRamByteUsageMax(f float64) {
	if m.addramByteUsageMax != nil {
		*m.addramByteUsageMax += f
	} else {
		m.addramByteUsageMax = &f
	}
}

// AddedRamByteUsageMax returns the value that was added to the "ramByteUsageMax" field in this mutation.
func (m *AllocationCostMutation) AddedRamByteUsageMax() (r float64, exists bool) {
	v := m.addramByteUsageMax
	if v == nil {
		return
	}
	return *v, true
}

// ResetRamByteUsageMax resets all changes to the "ramByteUsageMax" field.
func (m *AllocationCostMutation) ResetRamByteUsageMax() {
	m.ramByteUsageMax = nil
	m.addramByteUsageMax = nil
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *AllocationCostMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *AllocationCostMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *AllocationCostMutation) ConnectorIDs() (ids []oid.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *AllocationCostMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// Where appends a list predicates to the AllocationCostMutation builder.
func (m *AllocationCostMutation) Where(ps ...predicate.AllocationCost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AllocationCostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AllocationCostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AllocationCost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AllocationCostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AllocationCostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AllocationCost).
func (m *AllocationCostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AllocationCostMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.startTime != nil {
		fields = append(fields, allocationcost.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, allocationcost.FieldEndTime)
	}
	if m.minutes != nil {
		fields = append(fields, allocationcost.FieldMinutes)
	}
	if m.connector != nil {
		fields = append(fields, allocationcost.FieldConnectorID)
	}
	if m.name != nil {
		fields = append(fields, allocationcost.FieldName)
	}
	if m.fingerprint != nil {
		fields = append(fields, allocationcost.FieldFingerprint)
	}
	if m.clusterName != nil {
		fields = append(fields, allocationcost.FieldClusterName)
	}
	if m.namespace != nil {
		fields = append(fields, allocationcost.FieldNamespace)
	}
	if m.node != nil {
		fields = append(fields, allocationcost.FieldNode)
	}
	if m.controller != nil {
		fields = append(fields, allocationcost.FieldController)
	}
	if m.controllerKind != nil {
		fields = append(fields, allocationcost.FieldControllerKind)
	}
	if m.pod != nil {
		fields = append(fields, allocationcost.FieldPod)
	}
	if m.container != nil {
		fields = append(fields, allocationcost.FieldContainer)
	}
	if m.pvs != nil {
		fields = append(fields, allocationcost.FieldPvs)
	}
	if m.labels != nil {
		fields = append(fields, allocationcost.FieldLabels)
	}
	if m.totalCost != nil {
		fields = append(fields, allocationcost.FieldTotalCost)
	}
	if m.currency != nil {
		fields = append(fields, allocationcost.FieldCurrency)
	}
	if m.cpuCost != nil {
		fields = append(fields, allocationcost.FieldCpuCost)
	}
	if m.cpuCoreRequest != nil {
		fields = append(fields, allocationcost.FieldCpuCoreRequest)
	}
	if m.gpuCost != nil {
		fields = append(fields, allocationcost.FieldGpuCost)
	}
	if m.gpuCount != nil {
		fields = append(fields, allocationcost.FieldGpuCount)
	}
	if m.ramCost != nil {
		fields = append(fields, allocationcost.FieldRamCost)
	}
	if m.ramByteRequest != nil {
		fields = append(fields, allocationcost.FieldRamByteRequest)
	}
	if m.pvCost != nil {
		fields = append(fields, allocationcost.FieldPvCost)
	}
	if m.pvBytes != nil {
		fields = append(fields, allocationcost.FieldPvBytes)
	}
	if m.loadBalancerCost != nil {
		fields = append(fields, allocationcost.FieldLoadBalancerCost)
	}
	if m.cpuCoreUsageAverage != nil {
		fields = append(fields, allocationcost.FieldCpuCoreUsageAverage)
	}
	if m.cpuCoreUsageMax != nil {
		fields = append(fields, allocationcost.FieldCpuCoreUsageMax)
	}
	if m.ramByteUsageAverage != nil {
		fields = append(fields, allocationcost.FieldRamByteUsageAverage)
	}
	if m.ramByteUsageMax != nil {
		fields = append(fields, allocationcost.FieldRamByteUsageMax)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AllocationCostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case allocationcost.FieldStartTime:
		return m.StartTime()
	case allocationcost.FieldEndTime:
		return m.EndTime()
	case allocationcost.FieldMinutes:
		return m.Minutes()
	case allocationcost.FieldConnectorID:
		return m.ConnectorID()
	case allocationcost.FieldName:
		return m.Name()
	case allocationcost.FieldFingerprint:
		return m.Fingerprint()
	case allocationcost.FieldClusterName:
		return m.ClusterName()
	case allocationcost.FieldNamespace:
		return m.Namespace()
	case allocationcost.FieldNode:
		return m.Node()
	case allocationcost.FieldController:
		return m.Controller()
	case allocationcost.FieldControllerKind:
		return m.ControllerKind()
	case allocationcost.FieldPod:
		return m.Pod()
	case allocationcost.FieldContainer:
		return m.Container()
	case allocationcost.FieldPvs:
		return m.Pvs()
	case allocationcost.FieldLabels:
		return m.Labels()
	case allocationcost.FieldTotalCost:
		return m.TotalCost()
	case allocationcost.FieldCurrency:
		return m.Currency()
	case allocationcost.FieldCpuCost:
		return m.CpuCost()
	case allocationcost.FieldCpuCoreRequest:
		return m.CpuCoreRequest()
	case allocationcost.FieldGpuCost:
		return m.GpuCost()
	case allocationcost.FieldGpuCount:
		return m.GpuCount()
	case allocationcost.FieldRamCost:
		return m.RamCost()
	case allocationcost.FieldRamByteRequest:
		return m.RamByteRequest()
	case allocationcost.FieldPvCost:
		return m.PvCost()
	case allocationcost.FieldPvBytes:
		return m.PvBytes()
	case allocationcost.FieldLoadBalancerCost:
		return m.LoadBalancerCost()
	case allocationcost.FieldCpuCoreUsageAverage:
		return m.CpuCoreUsageAverage()
	case allocationcost.FieldCpuCoreUsageMax:
		return m.CpuCoreUsageMax()
	case allocationcost.FieldRamByteUsageAverage:
		return m.RamByteUsageAverage()
	case allocationcost.FieldRamByteUsageMax:
		return m.RamByteUsageMax()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AllocationCostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case allocationcost.FieldStartTime:
		return m.OldStartTime(ctx)
	case allocationcost.FieldEndTime:
		return m.OldEndTime(ctx)
	case allocationcost.FieldMinutes:
		return m.OldMinutes(ctx)
	case allocationcost.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case allocationcost.FieldName:
		return m.OldName(ctx)
	case allocationcost.FieldFingerprint:
		return m.OldFingerprint(ctx)
	case allocationcost.FieldClusterName:
		return m.OldClusterName(ctx)
	case allocationcost.FieldNamespace:
		return m.OldNamespace(ctx)
	case allocationcost.FieldNode:
		return m.OldNode(ctx)
	case allocationcost.FieldController:
		return m.OldController(ctx)
	case allocationcost.FieldControllerKind:
		return m.OldControllerKind(ctx)
	case allocationcost.FieldPod:
		return m.OldPod(ctx)
	case allocationcost.FieldContainer:
		return m.OldContainer(ctx)
	case allocationcost.FieldPvs:
		return m.OldPvs(ctx)
	case allocationcost.FieldLabels:
		return m.OldLabels(ctx)
	case allocationcost.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case allocationcost.FieldCurrency:
		return m.OldCurrency(ctx)
	case allocationcost.FieldCpuCost:
		return m.OldCpuCost(ctx)
	case allocationcost.FieldCpuCoreRequest:
		return m.OldCpuCoreRequest(ctx)
	case allocationcost.FieldGpuCost:
		return m.OldGpuCost(ctx)
	case allocationcost.FieldGpuCount:
		return m.OldGpuCount(ctx)
	case allocationcost.FieldRamCost:
		return m.OldRamCost(ctx)
	case allocationcost.FieldRamByteRequest:
		return m.OldRamByteRequest(ctx)
	case allocationcost.FieldPvCost:
		return m.OldPvCost(ctx)
	case allocationcost.FieldPvBytes:
		return m.OldPvBytes(ctx)
	case allocationcost.FieldLoadBalancerCost:
		return m.OldLoadBalancerCost(ctx)
	case allocationcost.FieldCpuCoreUsageAverage:
		return m.OldCpuCoreUsageAverage(ctx)
	case allocationcost.FieldCpuCoreUsageMax:
		return m.OldCpuCoreUsageMax(ctx)
	case allocationcost.FieldRamByteUsageAverage:
		return m.OldRamByteUsageAverage(ctx)
	case allocationcost.FieldRamByteUsageMax:
		return m.OldRamByteUsageMax(ctx)
	}
	return nil, fmt.Errorf("unknown AllocationCost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AllocationCostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case allocationcost.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case allocationcost.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case allocationcost.FieldMinutes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinutes(v)
		return nil
	case allocationcost.FieldConnectorID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case allocationcost.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case allocationcost.FieldFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprint(v)
		return nil
	case allocationcost.FieldClusterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterName(v)
		return nil
	case allocationcost.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case allocationcost.FieldNode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNode(v)
		return nil
	case allocationcost.FieldController:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetController(v)
		return nil
	case allocationcost.FieldControllerKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControllerKind(v)
		return nil
	case allocationcost.FieldPod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPod(v)
		return nil
	case allocationcost.FieldContainer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainer(v)
		return nil
	case allocationcost.FieldPvs:
		v, ok := value.(map[string]types.PVCost)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPvs(v)
		return nil
	case allocationcost.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case allocationcost.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case allocationcost.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case allocationcost.FieldCpuCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCpuCost(v)
		return nil
	case allocationcost.FieldCpuCoreRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCpuCoreRequest(v)
		return nil
	case allocationcost.FieldGpuCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuCost(v)
		return nil
	case allocationcost.FieldGpuCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuCount(v)
		return nil
	case allocationcost.FieldRamCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRamCost(v)
		return nil
	case allocationcost.FieldRamByteRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRamByteRequest(v)
		return nil
	case allocationcost.FieldPvCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPvCost(v)
		return nil
	case allocationcost.FieldPvBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPvBytes(v)
		return nil
	case allocationcost.FieldLoadBalancerCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadBalancerCost(v)
		return nil
	case allocationcost.FieldCpuCoreUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCpuCoreUsageAverage(v)
		return nil
	case allocationcost.FieldCpuCoreUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCpuCoreUsageMax(v)
		return nil
	case allocationcost.FieldRamByteUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRamByteUsageAverage(v)
		return nil
	case allocationcost.FieldRamByteUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRamByteUsageMax(v)
		return nil
	}
	return fmt.Errorf("unknown AllocationCost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AllocationCostMutation) AddedFields() []string {
	var fields []string
	if m.addminutes != nil {
		fields = append(fields, allocationcost.FieldMinutes)
	}
	if m.addtotalCost != nil {
		fields = append(fields, allocationcost.FieldTotalCost)
	}
	if m.addcurrency != nil {
		fields = append(fields, allocationcost.FieldCurrency)
	}
	if m.addcpuCost != nil {
		fields = append(fields, allocationcost.FieldCpuCost)
	}
	if m.addcpuCoreRequest != nil {
		fields = append(fields, allocationcost.FieldCpuCoreRequest)
	}
	if m.addgpuCost != nil {
		fields = append(fields, allocationcost.FieldGpuCost)
	}
	if m.addgpuCount != nil {
		fields = append(fields, allocationcost.FieldGpuCount)
	}
	if m.addramCost != nil {
		fields = append(fields, allocationcost.FieldRamCost)
	}
	if m.addramByteRequest != nil {
		fields = append(fields, allocationcost.FieldRamByteRequest)
	}
	if m.addpvCost != nil {
		fields = append(fields, allocationcost.FieldPvCost)
	}
	if m.addpvBytes != nil {
		fields = append(fields, allocationcost.FieldPvBytes)
	}
	if m.addloadBalancerCost != nil {
		fields = append(fields, allocationcost.FieldLoadBalancerCost)
	}
	if m.addcpuCoreUsageAverage != nil {
		fields = append(fields, allocationcost.FieldCpuCoreUsageAverage)
	}
	if m.addcpuCoreUsageMax != nil {
		fields = append(fields, allocationcost.FieldCpuCoreUsageMax)
	}
	if m.addramByteUsageAverage != nil {
		fields = append(fields, allocationcost.FieldRamByteUsageAverage)
	}
	if m.addramByteUsageMax != nil {
		fields = append(fields, allocationcost.FieldRamByteUsageMax)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AllocationCostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case allocationcost.FieldMinutes:
		return m.AddedMinutes()
	case allocationcost.FieldTotalCost:
		return m.AddedTotalCost()
	case allocationcost.FieldCurrency:
		return m.AddedCurrency()
	case allocationcost.FieldCpuCost:
		return m.AddedCpuCost()
	case allocationcost.FieldCpuCoreRequest:
		return m.AddedCpuCoreRequest()
	case allocationcost.FieldGpuCost:
		return m.AddedGpuCost()
	case allocationcost.FieldGpuCount:
		return m.AddedGpuCount()
	case allocationcost.FieldRamCost:
		return m.AddedRamCost()
	case allocationcost.FieldRamByteRequest:
		return m.AddedRamByteRequest()
	case allocationcost.FieldPvCost:
		return m.AddedPvCost()
	case allocationcost.FieldPvBytes:
		return m.AddedPvBytes()
	case allocationcost.FieldLoadBalancerCost:
		return m.AddedLoadBalancerCost()
	case allocationcost.FieldCpuCoreUsageAverage:
		return m.AddedCpuCoreUsageAverage()
	case allocationcost.FieldCpuCoreUsageMax:
		return m.AddedCpuCoreUsageMax()
	case allocationcost.FieldRamByteUsageAverage:
		return m.AddedRamByteUsageAverage()
	case allocationcost.FieldRamByteUsageMax:
		return m.AddedRamByteUsageMax()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AllocationCostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case allocationcost.FieldMinutes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinutes(v)
		return nil
	case allocationcost.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	case allocationcost.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrency(v)
		return nil
	case allocationcost.FieldCpuCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCpuCost(v)
		return nil
	case allocationcost.FieldCpuCoreRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCpuCoreRequest(v)
		return nil
	case allocationcost.FieldGpuCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGpuCost(v)
		return nil
	case allocationcost.FieldGpuCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGpuCount(v)
		return nil
	case allocationcost.FieldRamCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRamCost(v)
		return nil
	case allocationcost.FieldRamByteRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRamByteRequest(v)
		return nil
	case allocationcost.FieldPvCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPvCost(v)
		return nil
	case allocationcost.FieldPvBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPvBytes(v)
		return nil
	case allocationcost.FieldLoadBalancerCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadBalancerCost(v)
		return nil
	case allocationcost.FieldCpuCoreUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCpuCoreUsageAverage(v)
		return nil
	case allocationcost.FieldCpuCoreUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCpuCoreUsageMax(v)
		return nil
	case allocationcost.FieldRamByteUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRamByteUsageAverage(v)
		return nil
	case allocationcost.FieldRamByteUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRamByteUsageMax(v)
		return nil
	}
	return fmt.Errorf("unknown AllocationCost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AllocationCostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(allocationcost.FieldClusterName) {
		fields = append(fields, allocationcost.FieldClusterName)
	}
	if m.FieldCleared(allocationcost.FieldNamespace) {
		fields = append(fields, allocationcost.FieldNamespace)
	}
	if m.FieldCleared(allocationcost.FieldNode) {
		fields = append(fields, allocationcost.FieldNode)
	}
	if m.FieldCleared(allocationcost.FieldController) {
		fields = append(fields, allocationcost.FieldController)
	}
	if m.FieldCleared(allocationcost.FieldControllerKind) {
		fields = append(fields, allocationcost.FieldControllerKind)
	}
	if m.FieldCleared(allocationcost.FieldPod) {
		fields = append(fields, allocationcost.FieldPod)
	}
	if m.FieldCleared(allocationcost.FieldContainer) {
		fields = append(fields, allocationcost.FieldContainer)
	}
	if m.FieldCleared(allocationcost.FieldCurrency) {
		fields = append(fields, allocationcost.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AllocationCostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AllocationCostMutation) ClearField(name string) error {
	switch name {
	case allocationcost.FieldClusterName:
		m.ClearClusterName()
		return nil
	case allocationcost.FieldNamespace:
		m.ClearNamespace()
		return nil
	case allocationcost.FieldNode:
		m.ClearNode()
		return nil
	case allocationcost.FieldController:
		m.ClearController()
		return nil
	case allocationcost.FieldControllerKind:
		m.ClearControllerKind()
		return nil
	case allocationcost.FieldPod:
		m.ClearPod()
		return nil
	case allocationcost.FieldContainer:
		m.ClearContainer()
		return nil
	case allocationcost.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown AllocationCost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AllocationCostMutation) ResetField(name string) error {
	switch name {
	case allocationcost.FieldStartTime:
		m.ResetStartTime()
		return nil
	case allocationcost.FieldEndTime:
		m.ResetEndTime()
		return nil
	case allocationcost.FieldMinutes:
		m.ResetMinutes()
		return nil
	case allocationcost.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case allocationcost.FieldName:
		m.ResetName()
		return nil
	case allocationcost.FieldFingerprint:
		m.ResetFingerprint()
		return nil
	case allocationcost.FieldClusterName:
		m.ResetClusterName()
		return nil
	case allocationcost.FieldNamespace:
		m.ResetNamespace()
		return nil
	case allocationcost.FieldNode:
		m.ResetNode()
		return nil
	case allocationcost.FieldController:
		m.ResetController()
		return nil
	case allocationcost.FieldControllerKind:
		m.ResetControllerKind()
		return nil
	case allocationcost.FieldPod:
		m.ResetPod()
		return nil
	case allocationcost.FieldContainer:
		m.ResetContainer()
		return nil
	case allocationcost.FieldPvs:
		m.ResetPvs()
		return nil
	case allocationcost.FieldLabels:
		m.ResetLabels()
		return nil
	case allocationcost.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case allocationcost.FieldCurrency:
		m.ResetCurrency()
		return nil
	case allocationcost.FieldCpuCost:
		m.ResetCpuCost()
		return nil
	case allocationcost.FieldCpuCoreRequest:
		m.ResetCpuCoreRequest()
		return nil
	case allocationcost.FieldGpuCost:
		m.ResetGpuCost()
		return nil
	case allocationcost.FieldGpuCount:
		m.ResetGpuCount()
		return nil
	case allocationcost.FieldRamCost:
		m.ResetRamCost()
		return nil
	case allocationcost.FieldRamByteRequest:
		m.ResetRamByteRequest()
		return nil
	case allocationcost.FieldPvCost:
		m.ResetPvCost()
		return nil
	case allocationcost.FieldPvBytes:
		m.ResetPvBytes()
		return nil
	case allocationcost.FieldLoadBalancerCost:
		m.ResetLoadBalancerCost()
		return nil
	case allocationcost.FieldCpuCoreUsageAverage:
		m.ResetCpuCoreUsageAverage()
		return nil
	case allocationcost.FieldCpuCoreUsageMax:
		m.ResetCpuCoreUsageMax()
		return nil
	case allocationcost.FieldRamByteUsageAverage:
		m.ResetRamByteUsageAverage()
		return nil
	case allocationcost.FieldRamByteUsageMax:
		m.ResetRamByteUsageMax()
		return nil
	}
	return fmt.Errorf("unknown AllocationCost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AllocationCostMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connector != nil {
		edges = append(edges, allocationcost.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AllocationCostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case allocationcost.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AllocationCostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AllocationCostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AllocationCostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnector {
		edges = append(edges, allocationcost.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AllocationCostMutation) EdgeCleared(name string) bool {
	switch name {
	case allocationcost.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AllocationCostMutation) ClearEdge(name string) error {
	switch name {
	case allocationcost.EdgeConnector:
		m.ClearConnector()
		return nil
	}
	return fmt.Errorf("unknown AllocationCost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AllocationCostMutation) ResetEdge(name string) error {
	switch name {
	case allocationcost.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown AllocationCost edge %s", name)
}

// ClusterCostMutation represents an operation that mutates the ClusterCost nodes in the graph.
type ClusterCostMutation struct {
	config
	op                Op
	typ               string
	id                *int
	startTime         *time.Time
	endTime           *time.Time
	minutes           *float64
	addminutes        *float64
	clusterName       *string
	totalCost         *float64
	addtotalCost      *float64
	currency          *int
	addcurrency       *int
	allocationCost    *float64
	addallocationCost *float64
	idleCost          *float64
	addidleCost       *float64
	managementCost    *float64
	addmanagementCost *float64
	clearedFields     map[string]struct{}
	connector         *oid.ID
	clearedconnector  bool
	done              bool
	oldValue          func(context.Context) (*ClusterCost, error)
	predicates        []predicate.ClusterCost
}

var _ ent.Mutation = (*ClusterCostMutation)(nil)

// clusterCostOption allows management of the mutation configuration using functional options.
type clusterCostOption func(*ClusterCostMutation)

// newClusterCostMutation creates new mutation for the ClusterCost entity.
func newClusterCostMutation(c config, op Op, opts ...clusterCostOption) *ClusterCostMutation {
	m := &ClusterCostMutation{
		config:        c,
		op:            op,
		typ:           TypeClusterCost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClusterCostID sets the ID field of the mutation.
func withClusterCostID(id int) clusterCostOption {
	return func(m *ClusterCostMutation) {
		var (
			err   error
			once  sync.Once
			value *ClusterCost
		)
		m.oldValue = func(ctx context.Context) (*ClusterCost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClusterCost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClusterCost sets the old ClusterCost of the mutation.
func withClusterCost(node *ClusterCost) clusterCostOption {
	return func(m *ClusterCostMutation) {
		m.oldValue = func(context.Context) (*ClusterCost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClusterCostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClusterCostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClusterCostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClusterCostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClusterCost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartTime sets the "startTime" field.
func (m *ClusterCostMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *ClusterCostMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *ClusterCostMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *ClusterCostMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *ClusterCostMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *ClusterCostMutation) ResetEndTime() {
	m.endTime = nil
}

// SetMinutes sets the "minutes" field.
func (m *ClusterCostMutation) SetMinutes(f float64) {
	m.minutes = &f
	m.addminutes = nil
}

// Minutes returns the value of the "minutes" field in the mutation.
func (m *ClusterCostMutation) Minutes() (r float64, exists bool) {
	v := m.minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldMinutes returns the old "minutes" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldMinutes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinutes: %w", err)
	}
	return oldValue.Minutes, nil
}

// AddMinutes adds f to the "minutes" field.
func (m *ClusterCostMutation) AddMinutes(f float64) {
	if m.addminutes != nil {
		*m.addminutes += f
	} else {
		m.addminutes = &f
	}
}

// AddedMinutes returns the value that was added to the "minutes" field in this mutation.
func (m *ClusterCostMutation) AddedMinutes() (r float64, exists bool) {
	v := m.addminutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinutes resets all changes to the "minutes" field.
func (m *ClusterCostMutation) ResetMinutes() {
	m.minutes = nil
	m.addminutes = nil
}

// SetConnectorID sets the "connectorID" field.
func (m *ClusterCostMutation) SetConnectorID(o oid.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connectorID" field in the mutation.
func (m *ClusterCostMutation) ConnectorID() (r oid.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connectorID" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldConnectorID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connectorID" field.
func (m *ClusterCostMutation) ResetConnectorID() {
	m.connector = nil
}

// SetClusterName sets the "clusterName" field.
func (m *ClusterCostMutation) SetClusterName(s string) {
	m.clusterName = &s
}

// ClusterName returns the value of the "clusterName" field in the mutation.
func (m *ClusterCostMutation) ClusterName() (r string, exists bool) {
	v := m.clusterName
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterName returns the old "clusterName" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldClusterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClusterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClusterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterName: %w", err)
	}
	return oldValue.ClusterName, nil
}

// ResetClusterName resets all changes to the "clusterName" field.
func (m *ClusterCostMutation) ResetClusterName() {
	m.clusterName = nil
}

// SetTotalCost sets the "totalCost" field.
func (m *ClusterCostMutation) SetTotalCost(f float64) {
	m.totalCost = &f
	m.addtotalCost = nil
}

// TotalCost returns the value of the "totalCost" field in the mutation.
func (m *ClusterCostMutation) TotalCost() (r float64, exists bool) {
	v := m.totalCost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "totalCost" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldTotalCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "totalCost" field.
func (m *ClusterCostMutation) AddTotalCost(f float64) {
	if m.addtotalCost != nil {
		*m.addtotalCost += f
	} else {
		m.addtotalCost = &f
	}
}

// AddedTotalCost returns the value that was added to the "totalCost" field in this mutation.
func (m *ClusterCostMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotalCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCost resets all changes to the "totalCost" field.
func (m *ClusterCostMutation) ResetTotalCost() {
	m.totalCost = nil
	m.addtotalCost = nil
}

// SetCurrency sets the "currency" field.
func (m *ClusterCostMutation) SetCurrency(i int) {
	m.currency = &i
	m.addcurrency = nil
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ClusterCostMutation) Currency() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldCurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// AddCurrency adds i to the "currency" field.
func (m *ClusterCostMutation) AddCurrency(i int) {
	if m.addcurrency != nil {
		*m.addcurrency += i
	} else {
		m.addcurrency = &i
	}
}

// AddedCurrency returns the value that was added to the "currency" field in this mutation.
func (m *ClusterCostMutation) AddedCurrency() (r int, exists bool) {
	v := m.addcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrency clears the value of the "currency" field.
func (m *ClusterCostMutation) ClearCurrency() {
	m.currency = nil
	m.addcurrency = nil
	m.clearedFields[clustercost.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *ClusterCostMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[clustercost.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ClusterCostMutation) ResetCurrency() {
	m.currency = nil
	m.addcurrency = nil
	delete(m.clearedFields, clustercost.FieldCurrency)
}

// SetAllocationCost sets the "allocationCost" field.
func (m *ClusterCostMutation) SetAllocationCost(f float64) {
	m.allocationCost = &f
	m.addallocationCost = nil
}

// AllocationCost returns the value of the "allocationCost" field in the mutation.
func (m *ClusterCostMutation) AllocationCost() (r float64, exists bool) {
	v := m.allocationCost
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocationCost returns the old "allocationCost" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldAllocationCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocationCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocationCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocationCost: %w", err)
	}
	return oldValue.AllocationCost, nil
}

// AddAllocationCost adds f to the "allocationCost" field.
func (m *ClusterCostMutation) AddAllocationCost(f float64) {
	if m.addallocationCost != nil {
		*m.addallocationCost += f
	} else {
		m.addallocationCost = &f
	}
}

// AddedAllocationCost returns the value that was added to the "allocationCost" field in this mutation.
func (m *ClusterCostMutation) AddedAllocationCost() (r float64, exists bool) {
	v := m.addallocationCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllocationCost resets all changes to the "allocationCost" field.
func (m *ClusterCostMutation) ResetAllocationCost() {
	m.allocationCost = nil
	m.addallocationCost = nil
}

// SetIdleCost sets the "idleCost" field.
func (m *ClusterCostMutation) SetIdleCost(f float64) {
	m.idleCost = &f
	m.addidleCost = nil
}

// IdleCost returns the value of the "idleCost" field in the mutation.
func (m *ClusterCostMutation) IdleCost() (r float64, exists bool) {
	v := m.idleCost
	if v == nil {
		return
	}
	return *v, true
}

// OldIdleCost returns the old "idleCost" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldIdleCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdleCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdleCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdleCost: %w", err)
	}
	return oldValue.IdleCost, nil
}

// AddIdleCost adds f to the "idleCost" field.
func (m *ClusterCostMutation) AddIdleCost(f float64) {
	if m.addidleCost != nil {
		*m.addidleCost += f
	} else {
		m.addidleCost = &f
	}
}

// AddedIdleCost returns the value that was added to the "idleCost" field in this mutation.
func (m *ClusterCostMutation) AddedIdleCost() (r float64, exists bool) {
	v := m.addidleCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetIdleCost resets all changes to the "idleCost" field.
func (m *ClusterCostMutation) ResetIdleCost() {
	m.idleCost = nil
	m.addidleCost = nil
}

// SetManagementCost sets the "managementCost" field.
func (m *ClusterCostMutation) SetManagementCost(f float64) {
	m.managementCost = &f
	m.addmanagementCost = nil
}

// ManagementCost returns the value of the "managementCost" field in the mutation.
func (m *ClusterCostMutation) ManagementCost() (r float64, exists bool) {
	v := m.managementCost
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementCost returns the old "managementCost" field's value of the ClusterCost entity.
// If the ClusterCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterCostMutation) OldManagementCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementCost: %w", err)
	}
	return oldValue.ManagementCost, nil
}

// AddManagementCost adds f to the "managementCost" field.
func (m *ClusterCostMutation) AddManagementCost(f float64) {
	if m.addmanagementCost != nil {
		*m.addmanagementCost += f
	} else {
		m.addmanagementCost = &f
	}
}

// AddedManagementCost returns the value that was added to the "managementCost" field in this mutation.
func (m *ClusterCostMutation) AddedManagementCost() (r float64, exists bool) {
	v := m.addmanagementCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetManagementCost resets all changes to the "managementCost" field.
func (m *ClusterCostMutation) ResetManagementCost() {
	m.managementCost = nil
	m.addmanagementCost = nil
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *ClusterCostMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *ClusterCostMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *ClusterCostMutation) ConnectorIDs() (ids []oid.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *ClusterCostMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// Where appends a list predicates to the ClusterCostMutation builder.
func (m *ClusterCostMutation) Where(ps ...predicate.ClusterCost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClusterCostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClusterCostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClusterCost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClusterCostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClusterCostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClusterCost).
func (m *ClusterCostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClusterCostMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.startTime != nil {
		fields = append(fields, clustercost.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, clustercost.FieldEndTime)
	}
	if m.minutes != nil {
		fields = append(fields, clustercost.FieldMinutes)
	}
	if m.connector != nil {
		fields = append(fields, clustercost.FieldConnectorID)
	}
	if m.clusterName != nil {
		fields = append(fields, clustercost.FieldClusterName)
	}
	if m.totalCost != nil {
		fields = append(fields, clustercost.FieldTotalCost)
	}
	if m.currency != nil {
		fields = append(fields, clustercost.FieldCurrency)
	}
	if m.allocationCost != nil {
		fields = append(fields, clustercost.FieldAllocationCost)
	}
	if m.idleCost != nil {
		fields = append(fields, clustercost.FieldIdleCost)
	}
	if m.managementCost != nil {
		fields = append(fields, clustercost.FieldManagementCost)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClusterCostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clustercost.FieldStartTime:
		return m.StartTime()
	case clustercost.FieldEndTime:
		return m.EndTime()
	case clustercost.FieldMinutes:
		return m.Minutes()
	case clustercost.FieldConnectorID:
		return m.ConnectorID()
	case clustercost.FieldClusterName:
		return m.ClusterName()
	case clustercost.FieldTotalCost:
		return m.TotalCost()
	case clustercost.FieldCurrency:
		return m.Currency()
	case clustercost.FieldAllocationCost:
		return m.AllocationCost()
	case clustercost.FieldIdleCost:
		return m.IdleCost()
	case clustercost.FieldManagementCost:
		return m.ManagementCost()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClusterCostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clustercost.FieldStartTime:
		return m.OldStartTime(ctx)
	case clustercost.FieldEndTime:
		return m.OldEndTime(ctx)
	case clustercost.FieldMinutes:
		return m.OldMinutes(ctx)
	case clustercost.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case clustercost.FieldClusterName:
		return m.OldClusterName(ctx)
	case clustercost.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case clustercost.FieldCurrency:
		return m.OldCurrency(ctx)
	case clustercost.FieldAllocationCost:
		return m.OldAllocationCost(ctx)
	case clustercost.FieldIdleCost:
		return m.OldIdleCost(ctx)
	case clustercost.FieldManagementCost:
		return m.OldManagementCost(ctx)
	}
	return nil, fmt.Errorf("unknown ClusterCost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterCostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clustercost.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case clustercost.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case clustercost.FieldMinutes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinutes(v)
		return nil
	case clustercost.FieldConnectorID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case clustercost.FieldClusterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterName(v)
		return nil
	case clustercost.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case clustercost.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case clustercost.FieldAllocationCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocationCost(v)
		return nil
	case clustercost.FieldIdleCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdleCost(v)
		return nil
	case clustercost.FieldManagementCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementCost(v)
		return nil
	}
	return fmt.Errorf("unknown ClusterCost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClusterCostMutation) AddedFields() []string {
	var fields []string
	if m.addminutes != nil {
		fields = append(fields, clustercost.FieldMinutes)
	}
	if m.addtotalCost != nil {
		fields = append(fields, clustercost.FieldTotalCost)
	}
	if m.addcurrency != nil {
		fields = append(fields, clustercost.FieldCurrency)
	}
	if m.addallocationCost != nil {
		fields = append(fields, clustercost.FieldAllocationCost)
	}
	if m.addidleCost != nil {
		fields = append(fields, clustercost.FieldIdleCost)
	}
	if m.addmanagementCost != nil {
		fields = append(fields, clustercost.FieldManagementCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClusterCostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case clustercost.FieldMinutes:
		return m.AddedMinutes()
	case clustercost.FieldTotalCost:
		return m.AddedTotalCost()
	case clustercost.FieldCurrency:
		return m.AddedCurrency()
	case clustercost.FieldAllocationCost:
		return m.AddedAllocationCost()
	case clustercost.FieldIdleCost:
		return m.AddedIdleCost()
	case clustercost.FieldManagementCost:
		return m.AddedManagementCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterCostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case clustercost.FieldMinutes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinutes(v)
		return nil
	case clustercost.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	case clustercost.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrency(v)
		return nil
	case clustercost.FieldAllocationCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllocationCost(v)
		return nil
	case clustercost.FieldIdleCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdleCost(v)
		return nil
	case clustercost.FieldManagementCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManagementCost(v)
		return nil
	}
	return fmt.Errorf("unknown ClusterCost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClusterCostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clustercost.FieldCurrency) {
		fields = append(fields, clustercost.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClusterCostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClusterCostMutation) ClearField(name string) error {
	switch name {
	case clustercost.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown ClusterCost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClusterCostMutation) ResetField(name string) error {
	switch name {
	case clustercost.FieldStartTime:
		m.ResetStartTime()
		return nil
	case clustercost.FieldEndTime:
		m.ResetEndTime()
		return nil
	case clustercost.FieldMinutes:
		m.ResetMinutes()
		return nil
	case clustercost.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case clustercost.FieldClusterName:
		m.ResetClusterName()
		return nil
	case clustercost.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case clustercost.FieldCurrency:
		m.ResetCurrency()
		return nil
	case clustercost.FieldAllocationCost:
		m.ResetAllocationCost()
		return nil
	case clustercost.FieldIdleCost:
		m.ResetIdleCost()
		return nil
	case clustercost.FieldManagementCost:
		m.ResetManagementCost()
		return nil
	}
	return fmt.Errorf("unknown ClusterCost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClusterCostMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connector != nil {
		edges = append(edges, clustercost.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClusterCostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clustercost.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClusterCostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClusterCostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClusterCostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnector {
		edges = append(edges, clustercost.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClusterCostMutation) EdgeCleared(name string) bool {
	switch name {
	case clustercost.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClusterCostMutation) ClearEdge(name string) error {
	switch name {
	case clustercost.EdgeConnector:
		m.ClearConnector()
		return nil
	}
	return fmt.Errorf("unknown ClusterCost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClusterCostMutation) ResetEdge(name string) error {
	switch name {
	case clustercost.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown ClusterCost edge %s", name)
}

// ConnectorMutation represents an operation that mutates the Connector nodes in the graph.
type ConnectorMutation struct {
	config
	op                     Op
	typ                    string
	id                     *oid.ID
	name                   *string
	description            *string
	labels                 *map[string]string
	annotations            *map[string]string
	createTime             *time.Time
	updateTime             *time.Time
	status                 *status.Status
	_type                  *string
	configVersion          *string
	configData             *crypto.Properties
	enableFinOps           *bool
	finOpsCustomPricing    **types.FinOpsCustomPricing
	category               *string
	clearedFields          map[string]struct{}
	project                *oid.ID
	clearedproject         bool
	resources              map[oid.ID]struct{}
	removedresources       map[oid.ID]struct{}
	clearedresources       bool
	clusterCosts           map[int]struct{}
	removedclusterCosts    map[int]struct{}
	clearedclusterCosts    bool
	allocationCosts        map[int]struct{}
	removedallocationCosts map[int]struct{}
	clearedallocationCosts bool
	done                   bool
	oldValue               func(context.Context) (*Connector, error)
	predicates             []predicate.Connector
}

var _ ent.Mutation = (*ConnectorMutation)(nil)

// connectorOption allows management of the mutation configuration using functional options.
type connectorOption func(*ConnectorMutation)

// newConnectorMutation creates new mutation for the Connector entity.
func newConnectorMutation(c config, op Op, opts ...connectorOption) *ConnectorMutation {
	m := &ConnectorMutation{
		config:        c,
		op:            op,
		typ:           TypeConnector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectorID sets the ID field of the mutation.
func withConnectorID(id oid.ID) connectorOption {
	return func(m *ConnectorMutation) {
		var (
			err   error
			once  sync.Once
			value *Connector
		)
		m.oldValue = func(ctx context.Context) (*Connector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnector sets the old Connector of the mutation.
func withConnector(node *Connector) connectorOption {
	return func(m *ConnectorMutation) {
		m.oldValue = func(context.Context) (*Connector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connector entities.
func (m *ConnectorMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectorMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectorMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConnectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectorMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConnectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConnectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConnectorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[connector.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConnectorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[connector.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConnectorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, connector.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ConnectorMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ConnectorMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ConnectorMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[connector.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ConnectorMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[connector.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ConnectorMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, connector.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ConnectorMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ConnectorMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ConnectorMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[connector.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ConnectorMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[connector.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ConnectorMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, connector.FieldAnnotations)
}

// SetCreateTime sets the "createTime" field.
func (m *ConnectorMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *ConnectorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *ConnectorMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *ConnectorMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *ConnectorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *ConnectorMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetProjectID sets the "projectID" field.
func (m *ConnectorMutation) SetProjectID(o oid.ID) {
	m.project = &o
}

// ProjectID returns the value of the "projectID" field in the mutation.
func (m *ConnectorMutation) ProjectID() (r oid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "projectID" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldProjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "projectID" field.
func (m *ConnectorMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[connector.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "projectID" field was cleared in this mutation.
func (m *ConnectorMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[connector.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "projectID" field.
func (m *ConnectorMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, connector.FieldProjectID)
}

// SetStatus sets the "status" field.
func (m *ConnectorMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConnectorMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ConnectorMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[connector.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ConnectorMutation) StatusCleared() bool {
	_, ok := m.clearedFields[connector.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ConnectorMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, connector.FieldStatus)
}

// SetType sets the "type" field.
func (m *ConnectorMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConnectorMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ConnectorMutation) ResetType() {
	m._type = nil
}

// SetConfigVersion sets the "configVersion" field.
func (m *ConnectorMutation) SetConfigVersion(s string) {
	m.configVersion = &s
}

// ConfigVersion returns the value of the "configVersion" field in the mutation.
func (m *ConnectorMutation) ConfigVersion() (r string, exists bool) {
	v := m.configVersion
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigVersion returns the old "configVersion" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldConfigVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigVersion: %w", err)
	}
	return oldValue.ConfigVersion, nil
}

// ResetConfigVersion resets all changes to the "configVersion" field.
func (m *ConnectorMutation) ResetConfigVersion() {
	m.configVersion = nil
}

// SetConfigData sets the "configData" field.
func (m *ConnectorMutation) SetConfigData(c crypto.Properties) {
	m.configData = &c
}

// ConfigData returns the value of the "configData" field in the mutation.
func (m *ConnectorMutation) ConfigData() (r crypto.Properties, exists bool) {
	v := m.configData
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigData returns the old "configData" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldConfigData(ctx context.Context) (v crypto.Properties, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigData: %w", err)
	}
	return oldValue.ConfigData, nil
}

// ResetConfigData resets all changes to the "configData" field.
func (m *ConnectorMutation) ResetConfigData() {
	m.configData = nil
}

// SetEnableFinOps sets the "enableFinOps" field.
func (m *ConnectorMutation) SetEnableFinOps(b bool) {
	m.enableFinOps = &b
}

// EnableFinOps returns the value of the "enableFinOps" field in the mutation.
func (m *ConnectorMutation) EnableFinOps() (r bool, exists bool) {
	v := m.enableFinOps
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableFinOps returns the old "enableFinOps" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldEnableFinOps(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableFinOps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableFinOps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableFinOps: %w", err)
	}
	return oldValue.EnableFinOps, nil
}

// ResetEnableFinOps resets all changes to the "enableFinOps" field.
func (m *ConnectorMutation) ResetEnableFinOps() {
	m.enableFinOps = nil
}

// SetFinOpsCustomPricing sets the "finOpsCustomPricing" field.
func (m *ConnectorMutation) SetFinOpsCustomPricing(tocp *types.FinOpsCustomPricing) {
	m.finOpsCustomPricing = &tocp
}

// FinOpsCustomPricing returns the value of the "finOpsCustomPricing" field in the mutation.
func (m *ConnectorMutation) FinOpsCustomPricing() (r *types.FinOpsCustomPricing, exists bool) {
	v := m.finOpsCustomPricing
	if v == nil {
		return
	}
	return *v, true
}

// OldFinOpsCustomPricing returns the old "finOpsCustomPricing" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldFinOpsCustomPricing(ctx context.Context) (v *types.FinOpsCustomPricing, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinOpsCustomPricing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinOpsCustomPricing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinOpsCustomPricing: %w", err)
	}
	return oldValue.FinOpsCustomPricing, nil
}

// ClearFinOpsCustomPricing clears the value of the "finOpsCustomPricing" field.
func (m *ConnectorMutation) ClearFinOpsCustomPricing() {
	m.finOpsCustomPricing = nil
	m.clearedFields[connector.FieldFinOpsCustomPricing] = struct{}{}
}

// FinOpsCustomPricingCleared returns if the "finOpsCustomPricing" field was cleared in this mutation.
func (m *ConnectorMutation) FinOpsCustomPricingCleared() bool {
	_, ok := m.clearedFields[connector.FieldFinOpsCustomPricing]
	return ok
}

// ResetFinOpsCustomPricing resets all changes to the "finOpsCustomPricing" field.
func (m *ConnectorMutation) ResetFinOpsCustomPricing() {
	m.finOpsCustomPricing = nil
	delete(m.clearedFields, connector.FieldFinOpsCustomPricing)
}

// SetCategory sets the "category" field.
func (m *ConnectorMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ConnectorMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ConnectorMutation) ResetCategory() {
	m.category = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ConnectorMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ConnectorMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ConnectorMutation) ProjectIDs() (ids []oid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ConnectorMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddResourceIDs adds the "resources" edge to the ServiceResource entity by ids.
func (m *ConnectorMutation) AddResourceIDs(ids ...oid.ID) {
	if m.resources == nil {
		m.resources = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the ServiceResource entity.
func (m *ConnectorMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the ServiceResource entity was cleared.
func (m *ConnectorMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the ServiceResource entity by IDs.
func (m *ConnectorMutation) RemoveResourceIDs(ids ...oid.ID) {
	if m.removedresources == nil {
		m.removedresources = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the ServiceResource entity.
func (m *ConnectorMutation) RemovedResourcesIDs() (ids []oid.ID) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *ConnectorMutation) ResourcesIDs() (ids []oid.ID) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *ConnectorMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddClusterCostIDs adds the "clusterCosts" edge to the ClusterCost entity by ids.
func (m *ConnectorMutation) AddClusterCostIDs(ids ...int) {
	if m.clusterCosts == nil {
		m.clusterCosts = make(map[int]struct{})
	}
	for i := range ids {
		m.clusterCosts[ids[i]] = struct{}{}
	}
}

// ClearClusterCosts clears the "clusterCosts" edge to the ClusterCost entity.
func (m *ConnectorMutation) ClearClusterCosts() {
	m.clearedclusterCosts = true
}

// ClusterCostsCleared reports if the "clusterCosts" edge to the ClusterCost entity was cleared.
func (m *ConnectorMutation) ClusterCostsCleared() bool {
	return m.clearedclusterCosts
}

// RemoveClusterCostIDs removes the "clusterCosts" edge to the ClusterCost entity by IDs.
func (m *ConnectorMutation) RemoveClusterCostIDs(ids ...int) {
	if m.removedclusterCosts == nil {
		m.removedclusterCosts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clusterCosts, ids[i])
		m.removedclusterCosts[ids[i]] = struct{}{}
	}
}

// RemovedClusterCosts returns the removed IDs of the "clusterCosts" edge to the ClusterCost entity.
func (m *ConnectorMutation) RemovedClusterCostsIDs() (ids []int) {
	for id := range m.removedclusterCosts {
		ids = append(ids, id)
	}
	return
}

// ClusterCostsIDs returns the "clusterCosts" edge IDs in the mutation.
func (m *ConnectorMutation) ClusterCostsIDs() (ids []int) {
	for id := range m.clusterCosts {
		ids = append(ids, id)
	}
	return
}

// ResetClusterCosts resets all changes to the "clusterCosts" edge.
func (m *ConnectorMutation) ResetClusterCosts() {
	m.clusterCosts = nil
	m.clearedclusterCosts = false
	m.removedclusterCosts = nil
}

// AddAllocationCostIDs adds the "allocationCosts" edge to the AllocationCost entity by ids.
func (m *ConnectorMutation) AddAllocationCostIDs(ids ...int) {
	if m.allocationCosts == nil {
		m.allocationCosts = make(map[int]struct{})
	}
	for i := range ids {
		m.allocationCosts[ids[i]] = struct{}{}
	}
}

// ClearAllocationCosts clears the "allocationCosts" edge to the AllocationCost entity.
func (m *ConnectorMutation) ClearAllocationCosts() {
	m.clearedallocationCosts = true
}

// AllocationCostsCleared reports if the "allocationCosts" edge to the AllocationCost entity was cleared.
func (m *ConnectorMutation) AllocationCostsCleared() bool {
	return m.clearedallocationCosts
}

// RemoveAllocationCostIDs removes the "allocationCosts" edge to the AllocationCost entity by IDs.
func (m *ConnectorMutation) RemoveAllocationCostIDs(ids ...int) {
	if m.removedallocationCosts == nil {
		m.removedallocationCosts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.allocationCosts, ids[i])
		m.removedallocationCosts[ids[i]] = struct{}{}
	}
}

// RemovedAllocationCosts returns the removed IDs of the "allocationCosts" edge to the AllocationCost entity.
func (m *ConnectorMutation) RemovedAllocationCostsIDs() (ids []int) {
	for id := range m.removedallocationCosts {
		ids = append(ids, id)
	}
	return
}

// AllocationCostsIDs returns the "allocationCosts" edge IDs in the mutation.
func (m *ConnectorMutation) AllocationCostsIDs() (ids []int) {
	for id := range m.allocationCosts {
		ids = append(ids, id)
	}
	return
}

// ResetAllocationCosts resets all changes to the "allocationCosts" edge.
func (m *ConnectorMutation) ResetAllocationCosts() {
	m.allocationCosts = nil
	m.clearedallocationCosts = false
	m.removedallocationCosts = nil
}

// Where appends a list predicates to the ConnectorMutation builder.
func (m *ConnectorMutation) Where(ps ...predicate.Connector) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Connector, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Connector).
func (m *ConnectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectorMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, connector.FieldName)
	}
	if m.description != nil {
		fields = append(fields, connector.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, connector.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, connector.FieldAnnotations)
	}
	if m.createTime != nil {
		fields = append(fields, connector.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, connector.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, connector.FieldProjectID)
	}
	if m.status != nil {
		fields = append(fields, connector.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, connector.FieldType)
	}
	if m.configVersion != nil {
		fields = append(fields, connector.FieldConfigVersion)
	}
	if m.configData != nil {
		fields = append(fields, connector.FieldConfigData)
	}
	if m.enableFinOps != nil {
		fields = append(fields, connector.FieldEnableFinOps)
	}
	if m.finOpsCustomPricing != nil {
		fields = append(fields, connector.FieldFinOpsCustomPricing)
	}
	if m.category != nil {
		fields = append(fields, connector.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connector.FieldName:
		return m.Name()
	case connector.FieldDescription:
		return m.Description()
	case connector.FieldLabels:
		return m.Labels()
	case connector.FieldAnnotations:
		return m.Annotations()
	case connector.FieldCreateTime:
		return m.CreateTime()
	case connector.FieldUpdateTime:
		return m.UpdateTime()
	case connector.FieldProjectID:
		return m.ProjectID()
	case connector.FieldStatus:
		return m.Status()
	case connector.FieldType:
		return m.GetType()
	case connector.FieldConfigVersion:
		return m.ConfigVersion()
	case connector.FieldConfigData:
		return m.ConfigData()
	case connector.FieldEnableFinOps:
		return m.EnableFinOps()
	case connector.FieldFinOpsCustomPricing:
		return m.FinOpsCustomPricing()
	case connector.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connector.FieldName:
		return m.OldName(ctx)
	case connector.FieldDescription:
		return m.OldDescription(ctx)
	case connector.FieldLabels:
		return m.OldLabels(ctx)
	case connector.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case connector.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case connector.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case connector.FieldProjectID:
		return m.OldProjectID(ctx)
	case connector.FieldStatus:
		return m.OldStatus(ctx)
	case connector.FieldType:
		return m.OldType(ctx)
	case connector.FieldConfigVersion:
		return m.OldConfigVersion(ctx)
	case connector.FieldConfigData:
		return m.OldConfigData(ctx)
	case connector.FieldEnableFinOps:
		return m.OldEnableFinOps(ctx)
	case connector.FieldFinOpsCustomPricing:
		return m.OldFinOpsCustomPricing(ctx)
	case connector.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Connector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case connector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case connector.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case connector.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case connector.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case connector.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case connector.FieldProjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case connector.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case connector.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case connector.FieldConfigVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigVersion(v)
		return nil
	case connector.FieldConfigData:
		v, ok := value.(crypto.Properties)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigData(v)
		return nil
	case connector.FieldEnableFinOps:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableFinOps(v)
		return nil
	case connector.FieldFinOpsCustomPricing:
		v, ok := value.(*types.FinOpsCustomPricing)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinOpsCustomPricing(v)
		return nil
	case connector.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Connector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connector.FieldDescription) {
		fields = append(fields, connector.FieldDescription)
	}
	if m.FieldCleared(connector.FieldLabels) {
		fields = append(fields, connector.FieldLabels)
	}
	if m.FieldCleared(connector.FieldAnnotations) {
		fields = append(fields, connector.FieldAnnotations)
	}
	if m.FieldCleared(connector.FieldProjectID) {
		fields = append(fields, connector.FieldProjectID)
	}
	if m.FieldCleared(connector.FieldStatus) {
		fields = append(fields, connector.FieldStatus)
	}
	if m.FieldCleared(connector.FieldFinOpsCustomPricing) {
		fields = append(fields, connector.FieldFinOpsCustomPricing)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectorMutation) ClearField(name string) error {
	switch name {
	case connector.FieldDescription:
		m.ClearDescription()
		return nil
	case connector.FieldLabels:
		m.ClearLabels()
		return nil
	case connector.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case connector.FieldProjectID:
		m.ClearProjectID()
		return nil
	case connector.FieldStatus:
		m.ClearStatus()
		return nil
	case connector.FieldFinOpsCustomPricing:
		m.ClearFinOpsCustomPricing()
		return nil
	}
	return fmt.Errorf("unknown Connector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectorMutation) ResetField(name string) error {
	switch name {
	case connector.FieldName:
		m.ResetName()
		return nil
	case connector.FieldDescription:
		m.ResetDescription()
		return nil
	case connector.FieldLabels:
		m.ResetLabels()
		return nil
	case connector.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case connector.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case connector.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case connector.FieldProjectID:
		m.ResetProjectID()
		return nil
	case connector.FieldStatus:
		m.ResetStatus()
		return nil
	case connector.FieldType:
		m.ResetType()
		return nil
	case connector.FieldConfigVersion:
		m.ResetConfigVersion()
		return nil
	case connector.FieldConfigData:
		m.ResetConfigData()
		return nil
	case connector.FieldEnableFinOps:
		m.ResetEnableFinOps()
		return nil
	case connector.FieldFinOpsCustomPricing:
		m.ResetFinOpsCustomPricing()
		return nil
	case connector.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.project != nil {
		edges = append(edges, connector.EdgeProject)
	}
	if m.resources != nil {
		edges = append(edges, connector.EdgeResources)
	}
	if m.clusterCosts != nil {
		edges = append(edges, connector.EdgeClusterCosts)
	}
	if m.allocationCosts != nil {
		edges = append(edges, connector.EdgeAllocationCosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connector.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case connector.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeClusterCosts:
		ids := make([]ent.Value, 0, len(m.clusterCosts))
		for id := range m.clusterCosts {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeAllocationCosts:
		ids := make([]ent.Value, 0, len(m.allocationCosts))
		for id := range m.allocationCosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedresources != nil {
		edges = append(edges, connector.EdgeResources)
	}
	if m.removedclusterCosts != nil {
		edges = append(edges, connector.EdgeClusterCosts)
	}
	if m.removedallocationCosts != nil {
		edges = append(edges, connector.EdgeAllocationCosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connector.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeClusterCosts:
		ids := make([]ent.Value, 0, len(m.removedclusterCosts))
		for id := range m.removedclusterCosts {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeAllocationCosts:
		ids := make([]ent.Value, 0, len(m.removedallocationCosts))
		for id := range m.removedallocationCosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproject {
		edges = append(edges, connector.EdgeProject)
	}
	if m.clearedresources {
		edges = append(edges, connector.EdgeResources)
	}
	if m.clearedclusterCosts {
		edges = append(edges, connector.EdgeClusterCosts)
	}
	if m.clearedallocationCosts {
		edges = append(edges, connector.EdgeAllocationCosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectorMutation) EdgeCleared(name string) bool {
	switch name {
	case connector.EdgeProject:
		return m.clearedproject
	case connector.EdgeResources:
		return m.clearedresources
	case connector.EdgeClusterCosts:
		return m.clearedclusterCosts
	case connector.EdgeAllocationCosts:
		return m.clearedallocationCosts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectorMutation) ClearEdge(name string) error {
	switch name {
	case connector.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Connector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectorMutation) ResetEdge(name string) error {
	switch name {
	case connector.EdgeProject:
		m.ResetProject()
		return nil
	case connector.EdgeResources:
		m.ResetResources()
		return nil
	case connector.EdgeClusterCosts:
		m.ResetClusterCosts()
		return nil
	case connector.EdgeAllocationCosts:
		m.ResetAllocationCosts()
		return nil
	}
	return fmt.Errorf("unknown Connector edge %s", name)
}

// EnvironmentMutation represents an operation that mutates the Environment nodes in the graph.
type EnvironmentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *oid.ID
	name                    *string
	description             *string
	labels                  *map[string]string
	annotations             *map[string]string
	createTime              *time.Time
	updateTime              *time.Time
	clearedFields           map[string]struct{}
	project                 *oid.ID
	clearedproject          bool
	services                map[oid.ID]struct{}
	removedservices         map[oid.ID]struct{}
	clearedservices         bool
	serviceRevisions        map[oid.ID]struct{}
	removedserviceRevisions map[oid.ID]struct{}
	clearedserviceRevisions bool
	done                    bool
	oldValue                func(context.Context) (*Environment, error)
	predicates              []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows management of the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for the Environment entity.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the ID field of the mutation.
func withEnvironmentID(id oid.ID) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Environment entities.
func (m *EnvironmentMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Environment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EnvironmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EnvironmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EnvironmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[environment.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EnvironmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[environment.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EnvironmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, environment.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *EnvironmentMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *EnvironmentMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *EnvironmentMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[environment.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *EnvironmentMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[environment.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *EnvironmentMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, environment.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *EnvironmentMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *EnvironmentMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *EnvironmentMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[environment.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *EnvironmentMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[environment.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *EnvironmentMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, environment.FieldAnnotations)
}

// SetCreateTime sets the "createTime" field.
func (m *EnvironmentMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *EnvironmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *EnvironmentMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *EnvironmentMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *EnvironmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *EnvironmentMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetProjectID sets the "projectID" field.
func (m *EnvironmentMutation) SetProjectID(o oid.ID) {
	m.project = &o
}

// ProjectID returns the value of the "projectID" field in the mutation.
func (m *EnvironmentMutation) ProjectID() (r oid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "projectID" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldProjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "projectID" field.
func (m *EnvironmentMutation) ResetProjectID() {
	m.project = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *EnvironmentMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *EnvironmentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *EnvironmentMutation) ProjectIDs() (ids []oid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *EnvironmentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddServiceIDs adds the "services" edge to the Service entity by ids.
func (m *EnvironmentMutation) AddServiceIDs(ids ...oid.ID) {
	if m.services == nil {
		m.services = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Service entity.
func (m *EnvironmentMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *EnvironmentMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Service entity by IDs.
func (m *EnvironmentMutation) RemoveServiceIDs(ids ...oid.ID) {
	if m.removedservices == nil {
		m.removedservices = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Service entity.
func (m *EnvironmentMutation) RemovedServicesIDs() (ids []oid.ID) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *EnvironmentMutation) ServicesIDs() (ids []oid.ID) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *EnvironmentMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// AddServiceRevisionIDs adds the "serviceRevisions" edge to the ServiceRevision entity by ids.
func (m *EnvironmentMutation) AddServiceRevisionIDs(ids ...oid.ID) {
	if m.serviceRevisions == nil {
		m.serviceRevisions = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.serviceRevisions[ids[i]] = struct{}{}
	}
}

// ClearServiceRevisions clears the "serviceRevisions" edge to the ServiceRevision entity.
func (m *EnvironmentMutation) ClearServiceRevisions() {
	m.clearedserviceRevisions = true
}

// ServiceRevisionsCleared reports if the "serviceRevisions" edge to the ServiceRevision entity was cleared.
func (m *EnvironmentMutation) ServiceRevisionsCleared() bool {
	return m.clearedserviceRevisions
}

// RemoveServiceRevisionIDs removes the "serviceRevisions" edge to the ServiceRevision entity by IDs.
func (m *EnvironmentMutation) RemoveServiceRevisionIDs(ids ...oid.ID) {
	if m.removedserviceRevisions == nil {
		m.removedserviceRevisions = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.serviceRevisions, ids[i])
		m.removedserviceRevisions[ids[i]] = struct{}{}
	}
}

// RemovedServiceRevisions returns the removed IDs of the "serviceRevisions" edge to the ServiceRevision entity.
func (m *EnvironmentMutation) RemovedServiceRevisionsIDs() (ids []oid.ID) {
	for id := range m.removedserviceRevisions {
		ids = append(ids, id)
	}
	return
}

// ServiceRevisionsIDs returns the "serviceRevisions" edge IDs in the mutation.
func (m *EnvironmentMutation) ServiceRevisionsIDs() (ids []oid.ID) {
	for id := range m.serviceRevisions {
		ids = append(ids, id)
	}
	return
}

// ResetServiceRevisions resets all changes to the "serviceRevisions" edge.
func (m *EnvironmentMutation) ResetServiceRevisions() {
	m.serviceRevisions = nil
	m.clearedserviceRevisions = false
	m.removedserviceRevisions = nil
}

// Where appends a list predicates to the EnvironmentMutation builder.
func (m *EnvironmentMutation) Where(ps ...predicate.Environment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Environment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	if m.description != nil {
		fields = append(fields, environment.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, environment.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, environment.FieldAnnotations)
	}
	if m.createTime != nil {
		fields = append(fields, environment.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, environment.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, environment.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldName:
		return m.Name()
	case environment.FieldDescription:
		return m.Description()
	case environment.FieldLabels:
		return m.Labels()
	case environment.FieldAnnotations:
		return m.Annotations()
	case environment.FieldCreateTime:
		return m.CreateTime()
	case environment.FieldUpdateTime:
		return m.UpdateTime()
	case environment.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldName:
		return m.OldName(ctx)
	case environment.FieldDescription:
		return m.OldDescription(ctx)
	case environment.FieldLabels:
		return m.OldLabels(ctx)
	case environment.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case environment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case environment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case environment.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case environment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case environment.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case environment.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case environment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case environment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case environment.FieldProjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(environment.FieldDescription) {
		fields = append(fields, environment.FieldDescription)
	}
	if m.FieldCleared(environment.FieldLabels) {
		fields = append(fields, environment.FieldLabels)
	}
	if m.FieldCleared(environment.FieldAnnotations) {
		fields = append(fields, environment.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	switch name {
	case environment.FieldDescription:
		m.ClearDescription()
		return nil
	case environment.FieldLabels:
		m.ClearLabels()
		return nil
	case environment.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldName:
		m.ResetName()
		return nil
	case environment.FieldDescription:
		m.ResetDescription()
		return nil
	case environment.FieldLabels:
		m.ResetLabels()
		return nil
	case environment.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case environment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case environment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case environment.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, environment.EdgeProject)
	}
	if m.services != nil {
		edges = append(edges, environment.EdgeServices)
	}
	if m.serviceRevisions != nil {
		edges = append(edges, environment.EdgeServiceRevisions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case environment.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServiceRevisions:
		ids := make([]ent.Value, 0, len(m.serviceRevisions))
		for id := range m.serviceRevisions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedservices != nil {
		edges = append(edges, environment.EdgeServices)
	}
	if m.removedserviceRevisions != nil {
		edges = append(edges, environment.EdgeServiceRevisions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServiceRevisions:
		ids := make([]ent.Value, 0, len(m.removedserviceRevisions))
		for id := range m.removedserviceRevisions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, environment.EdgeProject)
	}
	if m.clearedservices {
		edges = append(edges, environment.EdgeServices)
	}
	if m.clearedserviceRevisions {
		edges = append(edges, environment.EdgeServiceRevisions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeProject:
		return m.clearedproject
	case environment.EdgeServices:
		return m.clearedservices
	case environment.EdgeServiceRevisions:
		return m.clearedserviceRevisions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	case environment.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeProject:
		m.ResetProject()
		return nil
	case environment.EdgeServices:
		m.ResetServices()
		return nil
	case environment.EdgeServiceRevisions:
		m.ResetServiceRevisions()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// EnvironmentConnectorRelationshipMutation represents an operation that mutates the EnvironmentConnectorRelationship nodes in the graph.
type EnvironmentConnectorRelationshipMutation struct {
	config
	op                 Op
	typ                string
	createTime         *time.Time
	clearedFields      map[string]struct{}
	environment        *oid.ID
	clearedenvironment bool
	connector          *oid.ID
	clearedconnector   bool
	done               bool
	oldValue           func(context.Context) (*EnvironmentConnectorRelationship, error)
	predicates         []predicate.EnvironmentConnectorRelationship
}

var _ ent.Mutation = (*EnvironmentConnectorRelationshipMutation)(nil)

// environmentConnectorRelationshipOption allows management of the mutation configuration using functional options.
type environmentConnectorRelationshipOption func(*EnvironmentConnectorRelationshipMutation)

// newEnvironmentConnectorRelationshipMutation creates new mutation for the EnvironmentConnectorRelationship entity.
func newEnvironmentConnectorRelationshipMutation(c config, op Op, opts ...environmentConnectorRelationshipOption) *EnvironmentConnectorRelationshipMutation {
	m := &EnvironmentConnectorRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironmentConnectorRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentConnectorRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentConnectorRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreateTime sets the "createTime" field.
func (m *EnvironmentConnectorRelationshipMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *EnvironmentConnectorRelationshipMutation) SetEnvironmentID(o oid.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentID() (r oid.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *EnvironmentConnectorRelationshipMutation) SetConnectorID(o oid.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorID() (r oid.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetConnectorID() {
	m.connector = nil
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *EnvironmentConnectorRelationshipMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentIDs() (ids []oid.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *EnvironmentConnectorRelationshipMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *EnvironmentConnectorRelationshipMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorIDs() (ids []oid.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *EnvironmentConnectorRelationshipMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// Where appends a list predicates to the EnvironmentConnectorRelationshipMutation builder.
func (m *EnvironmentConnectorRelationshipMutation) Where(ps ...predicate.EnvironmentConnectorRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentConnectorRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentConnectorRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnvironmentConnectorRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentConnectorRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentConnectorRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnvironmentConnectorRelationship).
func (m *EnvironmentConnectorRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentConnectorRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.createTime != nil {
		fields = append(fields, environmentconnectorrelationship.FieldCreateTime)
	}
	if m.environment != nil {
		fields = append(fields, environmentconnectorrelationship.FieldEnvironmentID)
	}
	if m.connector != nil {
		fields = append(fields, environmentconnectorrelationship.FieldConnectorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentConnectorRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		return m.CreateTime()
	case environmentconnectorrelationship.FieldEnvironmentID:
		return m.EnvironmentID()
	case environmentconnectorrelationship.FieldConnectorID:
		return m.ConnectorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentConnectorRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema EnvironmentConnectorRelationship does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentConnectorRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case environmentconnectorrelationship.FieldEnvironmentID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case environmentconnectorrelationship.FieldConnectorID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentConnectorRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentConnectorRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnvironmentConnectorRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ResetField(name string) error {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case environmentconnectorrelationship.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case environmentconnectorrelationship.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.environment != nil {
		edges = append(edges, environmentconnectorrelationship.EdgeEnvironment)
	}
	if m.connector != nil {
		edges = append(edges, environmentconnectorrelationship.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case environmentconnectorrelationship.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenvironment {
		edges = append(edges, environmentconnectorrelationship.EdgeEnvironment)
	}
	if m.clearedconnector {
		edges = append(edges, environmentconnectorrelationship.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		return m.clearedenvironment
	case environmentconnectorrelationship.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case environmentconnectorrelationship.EdgeConnector:
		m.ClearConnector()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case environmentconnectorrelationship.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship edge %s", name)
}

// PerspectiveMutation represents an operation that mutates the Perspective nodes in the graph.
type PerspectiveMutation struct {
	config
	op                      Op
	typ                     string
	id                      *oid.ID
	name                    *string
	description             *string
	labels                  *map[string]string
	annotations             *map[string]string
	createTime              *time.Time
	updateTime              *time.Time
	startTime               *string
	endTime                 *string
	builtin                 *bool
	allocationQueries       *[]types.QueryCondition
	appendallocationQueries []types.QueryCondition
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*Perspective, error)
	predicates              []predicate.Perspective
}

var _ ent.Mutation = (*PerspectiveMutation)(nil)

// perspectiveOption allows management of the mutation configuration using functional options.
type perspectiveOption func(*PerspectiveMutation)

// newPerspectiveMutation creates new mutation for the Perspective entity.
func newPerspectiveMutation(c config, op Op, opts ...perspectiveOption) *PerspectiveMutation {
	m := &PerspectiveMutation{
		config:        c,
		op:            op,
		typ:           TypePerspective,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPerspectiveID sets the ID field of the mutation.
func withPerspectiveID(id oid.ID) perspectiveOption {
	return func(m *PerspectiveMutation) {
		var (
			err   error
			once  sync.Once
			value *Perspective
		)
		m.oldValue = func(ctx context.Context) (*Perspective, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Perspective.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerspective sets the old Perspective of the mutation.
func withPerspective(node *Perspective) perspectiveOption {
	return func(m *PerspectiveMutation) {
		m.oldValue = func(context.Context) (*Perspective, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PerspectiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PerspectiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Perspective entities.
func (m *PerspectiveMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PerspectiveMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PerspectiveMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Perspective.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PerspectiveMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PerspectiveMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PerspectiveMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PerspectiveMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PerspectiveMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PerspectiveMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[perspective.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PerspectiveMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[perspective.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PerspectiveMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, perspective.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *PerspectiveMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *PerspectiveMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *PerspectiveMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[perspective.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *PerspectiveMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[perspective.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *PerspectiveMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, perspective.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *PerspectiveMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *PerspectiveMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *PerspectiveMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[perspective.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *PerspectiveMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[perspective.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *PerspectiveMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, perspective.FieldAnnotations)
}

// SetCreateTime sets the "createTime" field.
func (m *PerspectiveMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *PerspectiveMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *PerspectiveMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *PerspectiveMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *PerspectiveMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *PerspectiveMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetStartTime sets the "startTime" field.
func (m *PerspectiveMutation) SetStartTime(s string) {
	m.startTime = &s
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *PerspectiveMutation) StartTime() (r string, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldStartTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *PerspectiveMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *PerspectiveMutation) SetEndTime(s string) {
	m.endTime = &s
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *PerspectiveMutation) EndTime() (r string, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *PerspectiveMutation) ResetEndTime() {
	m.endTime = nil
}

// SetBuiltin sets the "builtin" field.
func (m *PerspectiveMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *PerspectiveMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *PerspectiveMutation) ResetBuiltin() {
	m.builtin = nil
}

// SetAllocationQueries sets the "allocationQueries" field.
func (m *PerspectiveMutation) SetAllocationQueries(tc []types.QueryCondition) {
	m.allocationQueries = &tc
	m.appendallocationQueries = nil
}

// AllocationQueries returns the value of the "allocationQueries" field in the mutation.
func (m *PerspectiveMutation) AllocationQueries() (r []types.QueryCondition, exists bool) {
	v := m.allocationQueries
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocationQueries returns the old "allocationQueries" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldAllocationQueries(ctx context.Context) (v []types.QueryCondition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocationQueries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocationQueries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocationQueries: %w", err)
	}
	return oldValue.AllocationQueries, nil
}

// AppendAllocationQueries adds tc to the "allocationQueries" field.
func (m *PerspectiveMutation) AppendAllocationQueries(tc []types.QueryCondition) {
	m.appendallocationQueries = append(m.appendallocationQueries, tc...)
}

// AppendedAllocationQueries returns the list of values that were appended to the "allocationQueries" field in this mutation.
func (m *PerspectiveMutation) AppendedAllocationQueries() ([]types.QueryCondition, bool) {
	if len(m.appendallocationQueries) == 0 {
		return nil, false
	}
	return m.appendallocationQueries, true
}

// ResetAllocationQueries resets all changes to the "allocationQueries" field.
func (m *PerspectiveMutation) ResetAllocationQueries() {
	m.allocationQueries = nil
	m.appendallocationQueries = nil
}

// Where appends a list predicates to the PerspectiveMutation builder.
func (m *PerspectiveMutation) Where(ps ...predicate.Perspective) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PerspectiveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PerspectiveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Perspective, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PerspectiveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PerspectiveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Perspective).
func (m *PerspectiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PerspectiveMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, perspective.FieldName)
	}
	if m.description != nil {
		fields = append(fields, perspective.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, perspective.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, perspective.FieldAnnotations)
	}
	if m.createTime != nil {
		fields = append(fields, perspective.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, perspective.FieldUpdateTime)
	}
	if m.startTime != nil {
		fields = append(fields, perspective.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, perspective.FieldEndTime)
	}
	if m.builtin != nil {
		fields = append(fields, perspective.FieldBuiltin)
	}
	if m.allocationQueries != nil {
		fields = append(fields, perspective.FieldAllocationQueries)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PerspectiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case perspective.FieldName:
		return m.Name()
	case perspective.FieldDescription:
		return m.Description()
	case perspective.FieldLabels:
		return m.Labels()
	case perspective.FieldAnnotations:
		return m.Annotations()
	case perspective.FieldCreateTime:
		return m.CreateTime()
	case perspective.FieldUpdateTime:
		return m.UpdateTime()
	case perspective.FieldStartTime:
		return m.StartTime()
	case perspective.FieldEndTime:
		return m.EndTime()
	case perspective.FieldBuiltin:
		return m.Builtin()
	case perspective.FieldAllocationQueries:
		return m.AllocationQueries()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PerspectiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case perspective.FieldName:
		return m.OldName(ctx)
	case perspective.FieldDescription:
		return m.OldDescription(ctx)
	case perspective.FieldLabels:
		return m.OldLabels(ctx)
	case perspective.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case perspective.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case perspective.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case perspective.FieldStartTime:
		return m.OldStartTime(ctx)
	case perspective.FieldEndTime:
		return m.OldEndTime(ctx)
	case perspective.FieldBuiltin:
		return m.OldBuiltin(ctx)
	case perspective.FieldAllocationQueries:
		return m.OldAllocationQueries(ctx)
	}
	return nil, fmt.Errorf("unknown Perspective field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PerspectiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case perspective.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case perspective.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case perspective.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case perspective.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case perspective.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case perspective.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case perspective.FieldStartTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case perspective.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case perspective.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	case perspective.FieldAllocationQueries:
		v, ok := value.([]types.QueryCondition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocationQueries(v)
		return nil
	}
	return fmt.Errorf("unknown Perspective field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PerspectiveMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PerspectiveMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PerspectiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Perspective numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PerspectiveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(perspective.FieldDescription) {
		fields = append(fields, perspective.FieldDescription)
	}
	if m.FieldCleared(perspective.FieldLabels) {
		fields = append(fields, perspective.FieldLabels)
	}
	if m.FieldCleared(perspective.FieldAnnotations) {
		fields = append(fields, perspective.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PerspectiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PerspectiveMutation) ClearField(name string) error {
	switch name {
	case perspective.FieldDescription:
		m.ClearDescription()
		return nil
	case perspective.FieldLabels:
		m.ClearLabels()
		return nil
	case perspective.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Perspective nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PerspectiveMutation) ResetField(name string) error {
	switch name {
	case perspective.FieldName:
		m.ResetName()
		return nil
	case perspective.FieldDescription:
		m.ResetDescription()
		return nil
	case perspective.FieldLabels:
		m.ResetLabels()
		return nil
	case perspective.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case perspective.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case perspective.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case perspective.FieldStartTime:
		m.ResetStartTime()
		return nil
	case perspective.FieldEndTime:
		m.ResetEndTime()
		return nil
	case perspective.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	case perspective.FieldAllocationQueries:
		m.ResetAllocationQueries()
		return nil
	}
	return fmt.Errorf("unknown Perspective field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PerspectiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PerspectiveMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PerspectiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PerspectiveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PerspectiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PerspectiveMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PerspectiveMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Perspective unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PerspectiveMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Perspective edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                      Op
	typ                     string
	id                      *oid.ID
	name                    *string
	description             *string
	labels                  *map[string]string
	annotations             *map[string]string
	createTime              *time.Time
	updateTime              *time.Time
	clearedFields           map[string]struct{}
	environments            map[oid.ID]struct{}
	removedenvironments     map[oid.ID]struct{}
	clearedenvironments     bool
	connectors              map[oid.ID]struct{}
	removedconnectors       map[oid.ID]struct{}
	clearedconnectors       bool
	secrets                 map[oid.ID]struct{}
	removedsecrets          map[oid.ID]struct{}
	clearedsecrets          bool
	subjectRoles            map[oid.ID]struct{}
	removedsubjectRoles     map[oid.ID]struct{}
	clearedsubjectRoles     bool
	services                map[oid.ID]struct{}
	removedservices         map[oid.ID]struct{}
	clearedservices         bool
	serviceRevisions        map[oid.ID]struct{}
	removedserviceRevisions map[oid.ID]struct{}
	clearedserviceRevisions bool
	done                    bool
	oldValue                func(context.Context) (*Project, error)
	predicates              []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id oid.ID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ProjectMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ProjectMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ProjectMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[project.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ProjectMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[project.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ProjectMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, project.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ProjectMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ProjectMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ProjectMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[project.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ProjectMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[project.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ProjectMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, project.FieldAnnotations)
}

// SetCreateTime sets the "createTime" field.
func (m *ProjectMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *ProjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *ProjectMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *ProjectMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *ProjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *ProjectMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// AddEnvironmentIDs adds the "environments" edge to the Environment entity by ids.
func (m *ProjectMutation) AddEnvironmentIDs(ids ...oid.ID) {
	if m.environments == nil {
		m.environments = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "environments" edge to the Environment entity.
func (m *ProjectMutation) ClearEnvironments() {
	m.clearedenvironments = true
}

// EnvironmentsCleared reports if the "environments" edge to the Environment entity was cleared.
func (m *ProjectMutation) EnvironmentsCleared() bool {
	return m.clearedenvironments
}

// RemoveEnvironmentIDs removes the "environments" edge to the Environment entity by IDs.
func (m *ProjectMutation) RemoveEnvironmentIDs(ids ...oid.ID) {
	if m.removedenvironments == nil {
		m.removedenvironments = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.environments, ids[i])
		m.removedenvironments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "environments" edge to the Environment entity.
func (m *ProjectMutation) RemovedEnvironmentsIDs() (ids []oid.ID) {
	for id := range m.removedenvironments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "environments" edge IDs in the mutation.
func (m *ProjectMutation) EnvironmentsIDs() (ids []oid.ID) {
	for id := range m.environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "environments" edge.
func (m *ProjectMutation) ResetEnvironments() {
	m.environments = nil
	m.clearedenvironments = false
	m.removedenvironments = nil
}

// AddConnectorIDs adds the "connectors" edge to the Connector entity by ids.
func (m *ProjectMutation) AddConnectorIDs(ids ...oid.ID) {
	if m.connectors == nil {
		m.connectors = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.connectors[ids[i]] = struct{}{}
	}
}

// ClearConnectors clears the "connectors" edge to the Connector entity.
func (m *ProjectMutation) ClearConnectors() {
	m.clearedconnectors = true
}

// ConnectorsCleared reports if the "connectors" edge to the Connector entity was cleared.
func (m *ProjectMutation) ConnectorsCleared() bool {
	return m.clearedconnectors
}

// RemoveConnectorIDs removes the "connectors" edge to the Connector entity by IDs.
func (m *ProjectMutation) RemoveConnectorIDs(ids ...oid.ID) {
	if m.removedconnectors == nil {
		m.removedconnectors = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.connectors, ids[i])
		m.removedconnectors[ids[i]] = struct{}{}
	}
}

// RemovedConnectors returns the removed IDs of the "connectors" edge to the Connector entity.
func (m *ProjectMutation) RemovedConnectorsIDs() (ids []oid.ID) {
	for id := range m.removedconnectors {
		ids = append(ids, id)
	}
	return
}

// ConnectorsIDs returns the "connectors" edge IDs in the mutation.
func (m *ProjectMutation) ConnectorsIDs() (ids []oid.ID) {
	for id := range m.connectors {
		ids = append(ids, id)
	}
	return
}

// ResetConnectors resets all changes to the "connectors" edge.
func (m *ProjectMutation) ResetConnectors() {
	m.connectors = nil
	m.clearedconnectors = false
	m.removedconnectors = nil
}

// AddSecretIDs adds the "secrets" edge to the Secret entity by ids.
func (m *ProjectMutation) AddSecretIDs(ids ...oid.ID) {
	if m.secrets == nil {
		m.secrets = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.secrets[ids[i]] = struct{}{}
	}
}

// ClearSecrets clears the "secrets" edge to the Secret entity.
func (m *ProjectMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the Secret entity was cleared.
func (m *ProjectMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// RemoveSecretIDs removes the "secrets" edge to the Secret entity by IDs.
func (m *ProjectMutation) RemoveSecretIDs(ids ...oid.ID) {
	if m.removedsecrets == nil {
		m.removedsecrets = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.secrets, ids[i])
		m.removedsecrets[ids[i]] = struct{}{}
	}
}

// RemovedSecrets returns the removed IDs of the "secrets" edge to the Secret entity.
func (m *ProjectMutation) RemovedSecretsIDs() (ids []oid.ID) {
	for id := range m.removedsecrets {
		ids = append(ids, id)
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
func (m *ProjectMutation) SecretsIDs() (ids []oid.ID) {
	for id := range m.secrets {
		ids = append(ids, id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *ProjectMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
	m.removedsecrets = nil
}

// AddSubjectRoleIDs adds the "subjectRoles" edge to the SubjectRoleRelationship entity by ids.
func (m *ProjectMutation) AddSubjectRoleIDs(ids ...oid.ID) {
	if m.subjectRoles == nil {
		m.subjectRoles = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.subjectRoles[ids[i]] = struct{}{}
	}
}

// ClearSubjectRoles clears the "subjectRoles" edge to the SubjectRoleRelationship entity.
func (m *ProjectMutation) ClearSubjectRoles() {
	m.clearedsubjectRoles = true
}

// SubjectRolesCleared reports if the "subjectRoles" edge to the SubjectRoleRelationship entity was cleared.
func (m *ProjectMutation) SubjectRolesCleared() bool {
	return m.clearedsubjectRoles
}

// RemoveSubjectRoleIDs removes the "subjectRoles" edge to the SubjectRoleRelationship entity by IDs.
func (m *ProjectMutation) RemoveSubjectRoleIDs(ids ...oid.ID) {
	if m.removedsubjectRoles == nil {
		m.removedsubjectRoles = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.subjectRoles, ids[i])
		m.removedsubjectRoles[ids[i]] = struct{}{}
	}
}

// RemovedSubjectRoles returns the removed IDs of the "subjectRoles" edge to the SubjectRoleRelationship entity.
func (m *ProjectMutation) RemovedSubjectRolesIDs() (ids []oid.ID) {
	for id := range m.removedsubjectRoles {
		ids = append(ids, id)
	}
	return
}

// SubjectRolesIDs returns the "subjectRoles" edge IDs in the mutation.
func (m *ProjectMutation) SubjectRolesIDs() (ids []oid.ID) {
	for id := range m.subjectRoles {
		ids = append(ids, id)
	}
	return
}

// ResetSubjectRoles resets all changes to the "subjectRoles" edge.
func (m *ProjectMutation) ResetSubjectRoles() {
	m.subjectRoles = nil
	m.clearedsubjectRoles = false
	m.removedsubjectRoles = nil
}

// AddServiceIDs adds the "services" edge to the Service entity by ids.
func (m *ProjectMutation) AddServiceIDs(ids ...oid.ID) {
	if m.services == nil {
		m.services = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Service entity.
func (m *ProjectMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *ProjectMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Service entity by IDs.
func (m *ProjectMutation) RemoveServiceIDs(ids ...oid.ID) {
	if m.removedservices == nil {
		m.removedservices = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Service entity.
func (m *ProjectMutation) RemovedServicesIDs() (ids []oid.ID) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *ProjectMutation) ServicesIDs() (ids []oid.ID) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *ProjectMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// AddServiceRevisionIDs adds the "serviceRevisions" edge to the ServiceRevision entity by ids.
func (m *ProjectMutation) AddServiceRevisionIDs(ids ...oid.ID) {
	if m.serviceRevisions == nil {
		m.serviceRevisions = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.serviceRevisions[ids[i]] = struct{}{}
	}
}

// ClearServiceRevisions clears the "serviceRevisions" edge to the ServiceRevision entity.
func (m *ProjectMutation) ClearServiceRevisions() {
	m.clearedserviceRevisions = true
}

// ServiceRevisionsCleared reports if the "serviceRevisions" edge to the ServiceRevision entity was cleared.
func (m *ProjectMutation) ServiceRevisionsCleared() bool {
	return m.clearedserviceRevisions
}

// RemoveServiceRevisionIDs removes the "serviceRevisions" edge to the ServiceRevision entity by IDs.
func (m *ProjectMutation) RemoveServiceRevisionIDs(ids ...oid.ID) {
	if m.removedserviceRevisions == nil {
		m.removedserviceRevisions = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.serviceRevisions, ids[i])
		m.removedserviceRevisions[ids[i]] = struct{}{}
	}
}

// RemovedServiceRevisions returns the removed IDs of the "serviceRevisions" edge to the ServiceRevision entity.
func (m *ProjectMutation) RemovedServiceRevisionsIDs() (ids []oid.ID) {
	for id := range m.removedserviceRevisions {
		ids = append(ids, id)
	}
	return
}

// ServiceRevisionsIDs returns the "serviceRevisions" edge IDs in the mutation.
func (m *ProjectMutation) ServiceRevisionsIDs() (ids []oid.ID) {
	for id := range m.serviceRevisions {
		ids = append(ids, id)
	}
	return
}

// ResetServiceRevisions resets all changes to the "serviceRevisions" edge.
func (m *ProjectMutation) ResetServiceRevisions() {
	m.serviceRevisions = nil
	m.clearedserviceRevisions = false
	m.removedserviceRevisions = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, project.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, project.FieldAnnotations)
	}
	if m.createTime != nil {
		fields = append(fields, project.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, project.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldLabels:
		return m.Labels()
	case project.FieldAnnotations:
		return m.Annotations()
	case project.FieldCreateTime:
		return m.CreateTime()
	case project.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldLabels:
		return m.OldLabels(ctx)
	case project.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case project.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case project.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case project.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case project.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case project.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldLabels) {
		fields = append(fields, project.FieldLabels)
	}
	if m.FieldCleared(project.FieldAnnotations) {
		fields = append(fields, project.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldLabels:
		m.ClearLabels()
		return nil
	case project.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldLabels:
		m.ResetLabels()
		return nil
	case project.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case project.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case project.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.environments != nil {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.connectors != nil {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.secrets != nil {
		edges = append(edges, project.EdgeSecrets)
	}
	if m.subjectRoles != nil {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.services != nil {
		edges = append(edges, project.EdgeServices)
	}
	if m.serviceRevisions != nil {
		edges = append(edges, project.EdgeServiceRevisions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.environments))
		for id := range m.environments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.connectors))
		for id := range m.connectors {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.secrets))
		for id := range m.secrets {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSubjectRoles:
		ids := make([]ent.Value, 0, len(m.subjectRoles))
		for id := range m.subjectRoles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServiceRevisions:
		ids := make([]ent.Value, 0, len(m.serviceRevisions))
		for id := range m.serviceRevisions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedenvironments != nil {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.removedconnectors != nil {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.removedsecrets != nil {
		edges = append(edges, project.EdgeSecrets)
	}
	if m.removedsubjectRoles != nil {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.removedservices != nil {
		edges = append(edges, project.EdgeServices)
	}
	if m.removedserviceRevisions != nil {
		edges = append(edges, project.EdgeServiceRevisions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removedenvironments))
		for id := range m.removedenvironments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.removedconnectors))
		for id := range m.removedconnectors {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.removedsecrets))
		for id := range m.removedsecrets {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSubjectRoles:
		ids := make([]ent.Value, 0, len(m.removedsubjectRoles))
		for id := range m.removedsubjectRoles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeServiceRevisions:
		ids := make([]ent.Value, 0, len(m.removedserviceRevisions))
		for id := range m.removedserviceRevisions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedenvironments {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.clearedconnectors {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.clearedsecrets {
		edges = append(edges, project.EdgeSecrets)
	}
	if m.clearedsubjectRoles {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.clearedservices {
		edges = append(edges, project.EdgeServices)
	}
	if m.clearedserviceRevisions {
		edges = append(edges, project.EdgeServiceRevisions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeEnvironments:
		return m.clearedenvironments
	case project.EdgeConnectors:
		return m.clearedconnectors
	case project.EdgeSecrets:
		return m.clearedsecrets
	case project.EdgeSubjectRoles:
		return m.clearedsubjectRoles
	case project.EdgeServices:
		return m.clearedservices
	case project.EdgeServiceRevisions:
		return m.clearedserviceRevisions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case project.EdgeConnectors:
		m.ResetConnectors()
		return nil
	case project.EdgeSecrets:
		m.ResetSecrets()
		return nil
	case project.EdgeSubjectRoles:
		m.ResetSubjectRoles()
		return nil
	case project.EdgeServices:
		m.ResetServices()
		return nil
	case project.EdgeServiceRevisions:
		m.ResetServiceRevisions()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op              Op
	typ             string
	id              *string
	createTime      *time.Time
	updateTime      *time.Time
	kind            *string
	description     *string
	policies        *types.RolePolicies
	appendpolicies  types.RolePolicies
	session         *bool
	builtin         *bool
	clearedFields   map[string]struct{}
	subjects        map[oid.ID]struct{}
	removedsubjects map[oid.ID]struct{}
	clearedsubjects bool
	done            bool
	oldValue        func(context.Context) (*Role, error)
	predicates      []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id string) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *RoleMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *RoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *RoleMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *RoleMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *RoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *RoleMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetKind sets the "kind" field.
func (m *RoleMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *RoleMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *RoleMutation) ResetKind() {
	m.kind = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetPolicies sets the "policies" field.
func (m *RoleMutation) SetPolicies(tp types.RolePolicies) {
	m.policies = &tp
	m.appendpolicies = nil
}

// Policies returns the value of the "policies" field in the mutation.
func (m *RoleMutation) Policies() (r types.RolePolicies, exists bool) {
	v := m.policies
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicies returns the old "policies" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPolicies(ctx context.Context) (v types.RolePolicies, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicies: %w", err)
	}
	return oldValue.Policies, nil
}

// AppendPolicies adds tp to the "policies" field.
func (m *RoleMutation) AppendPolicies(tp types.RolePolicies) {
	m.appendpolicies = append(m.appendpolicies, tp...)
}

// AppendedPolicies returns the list of values that were appended to the "policies" field in this mutation.
func (m *RoleMutation) AppendedPolicies() (types.RolePolicies, bool) {
	if len(m.appendpolicies) == 0 {
		return nil, false
	}
	return m.appendpolicies, true
}

// ResetPolicies resets all changes to the "policies" field.
func (m *RoleMutation) ResetPolicies() {
	m.policies = nil
	m.appendpolicies = nil
}

// SetSession sets the "session" field.
func (m *RoleMutation) SetSession(b bool) {
	m.session = &b
}

// Session returns the value of the "session" field in the mutation.
func (m *RoleMutation) Session() (r bool, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSession returns the old "session" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSession(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSession is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSession requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSession: %w", err)
	}
	return oldValue.Session, nil
}

// ResetSession resets all changes to the "session" field.
func (m *RoleMutation) ResetSession() {
	m.session = nil
}

// SetBuiltin sets the "builtin" field.
func (m *RoleMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *RoleMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *RoleMutation) ResetBuiltin() {
	m.builtin = nil
}

// AddSubjectIDs adds the "subjects" edge to the SubjectRoleRelationship entity by ids.
func (m *RoleMutation) AddSubjectIDs(ids ...oid.ID) {
	if m.subjects == nil {
		m.subjects = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the SubjectRoleRelationship entity.
func (m *RoleMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the SubjectRoleRelationship entity was cleared.
func (m *RoleMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the SubjectRoleRelationship entity by IDs.
func (m *RoleMutation) RemoveSubjectIDs(ids ...oid.ID) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the SubjectRoleRelationship entity.
func (m *RoleMutation) RemovedSubjectsIDs() (ids []oid.ID) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *RoleMutation) SubjectsIDs() (ids []oid.ID) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *RoleMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.createTime != nil {
		fields = append(fields, role.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, role.FieldUpdateTime)
	}
	if m.kind != nil {
		fields = append(fields, role.FieldKind)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.policies != nil {
		fields = append(fields, role.FieldPolicies)
	}
	if m.session != nil {
		fields = append(fields, role.FieldSession)
	}
	if m.builtin != nil {
		fields = append(fields, role.FieldBuiltin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreateTime:
		return m.CreateTime()
	case role.FieldUpdateTime:
		return m.UpdateTime()
	case role.FieldKind:
		return m.Kind()
	case role.FieldDescription:
		return m.Description()
	case role.FieldPolicies:
		return m.Policies()
	case role.FieldSession:
		return m.Session()
	case role.FieldBuiltin:
		return m.Builtin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case role.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case role.FieldKind:
		return m.OldKind(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldPolicies:
		return m.OldPolicies(ctx)
	case role.FieldSession:
		return m.OldSession(ctx)
	case role.FieldBuiltin:
		return m.OldBuiltin(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case role.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case role.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldPolicies:
		v, ok := value.(types.RolePolicies)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicies(v)
		return nil
	case role.FieldSession:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSession(v)
		return nil
	case role.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case role.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case role.FieldKind:
		m.ResetKind()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldPolicies:
		m.ResetPolicies()
		return nil
	case role.FieldSession:
		m.ResetSession()
		return nil
	case role.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subjects != nil {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubjects != nil {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubjects {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeSubjects:
		return m.clearedsubjects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeSubjects:
		m.ResetSubjects()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SecretMutation represents an operation that mutates the Secret nodes in the graph.
type SecretMutation struct {
	config
	op             Op
	typ            string
	id             *oid.ID
	createTime     *time.Time
	updateTime     *time.Time
	name           *string
	value          *crypto.String
	clearedFields  map[string]struct{}
	project        *oid.ID
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*Secret, error)
	predicates     []predicate.Secret
}

var _ ent.Mutation = (*SecretMutation)(nil)

// secretOption allows management of the mutation configuration using functional options.
type secretOption func(*SecretMutation)

// newSecretMutation creates new mutation for the Secret entity.
func newSecretMutation(c config, op Op, opts ...secretOption) *SecretMutation {
	m := &SecretMutation{
		config:        c,
		op:            op,
		typ:           TypeSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecretID sets the ID field of the mutation.
func withSecretID(id oid.ID) secretOption {
	return func(m *SecretMutation) {
		var (
			err   error
			once  sync.Once
			value *Secret
		)
		m.oldValue = func(ctx context.Context) (*Secret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Secret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecret sets the old Secret of the mutation.
func withSecret(node *Secret) secretOption {
	return func(m *SecretMutation) {
		m.oldValue = func(context.Context) (*Secret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Secret entities.
func (m *SecretMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecretMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecretMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Secret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *SecretMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *SecretMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *SecretMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *SecretMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *SecretMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *SecretMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetProjectID sets the "projectID" field.
func (m *SecretMutation) SetProjectID(o oid.ID) {
	m.project = &o
}

// ProjectID returns the value of the "projectID" field in the mutation.
func (m *SecretMutation) ProjectID() (r oid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "projectID" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldProjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "projectID" field.
func (m *SecretMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[secret.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "projectID" field was cleared in this mutation.
func (m *SecretMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[secret.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "projectID" field.
func (m *SecretMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, secret.FieldProjectID)
}

// SetName sets the "name" field.
func (m *SecretMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SecretMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SecretMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SecretMutation) SetValue(c crypto.String) {
	m.value = &c
}

// Value returns the value of the "value" field in the mutation.
func (m *SecretMutation) Value() (r crypto.String, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldValue(ctx context.Context) (v crypto.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SecretMutation) ResetValue() {
	m.value = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *SecretMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *SecretMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *SecretMutation) ProjectIDs() (ids []oid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *SecretMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the SecretMutation builder.
func (m *SecretMutation) Where(ps ...predicate.Secret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Secret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Secret).
func (m *SecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecretMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.createTime != nil {
		fields = append(fields, secret.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, secret.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, secret.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, secret.FieldName)
	}
	if m.value != nil {
		fields = append(fields, secret.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case secret.FieldCreateTime:
		return m.CreateTime()
	case secret.FieldUpdateTime:
		return m.UpdateTime()
	case secret.FieldProjectID:
		return m.ProjectID()
	case secret.FieldName:
		return m.Name()
	case secret.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case secret.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case secret.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case secret.FieldProjectID:
		return m.OldProjectID(ctx)
	case secret.FieldName:
		return m.OldName(ctx)
	case secret.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Secret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case secret.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case secret.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case secret.FieldProjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case secret.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case secret.FieldValue:
		v, ok := value.(crypto.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Secret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecretMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecretMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Secret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecretMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(secret.FieldProjectID) {
		fields = append(fields, secret.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecretMutation) ClearField(name string) error {
	switch name {
	case secret.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown Secret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecretMutation) ResetField(name string) error {
	switch name {
	case secret.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case secret.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case secret.FieldProjectID:
		m.ResetProjectID()
		return nil
	case secret.FieldName:
		m.ResetName()
		return nil
	case secret.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Secret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, secret.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case secret.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, secret.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecretMutation) EdgeCleared(name string) bool {
	switch name {
	case secret.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecretMutation) ClearEdge(name string) error {
	switch name {
	case secret.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Secret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecretMutation) ResetEdge(name string) error {
	switch name {
	case secret.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Secret edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *oid.ID
	name                *string
	description         *string
	labels              *map[string]string
	annotations         *map[string]string
	createTime          *time.Time
	updateTime          *time.Time
	template            *types.TemplateVersionRef
	attributes          *property.Values
	status              *status.Status
	clearedFields       map[string]struct{}
	project             *oid.ID
	clearedproject      bool
	environment         *oid.ID
	clearedenvironment  bool
	revisions           map[oid.ID]struct{}
	removedrevisions    map[oid.ID]struct{}
	clearedrevisions    bool
	resources           map[oid.ID]struct{}
	removedresources    map[oid.ID]struct{}
	clearedresources    bool
	dependencies        map[oid.ID]struct{}
	removeddependencies map[oid.ID]struct{}
	cleareddependencies bool
	done                bool
	oldValue            func(context.Context) (*Service, error)
	predicates          []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id oid.ID) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Service entities.
func (m *ServiceMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServiceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[service.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[service.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, service.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ServiceMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ServiceMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ServiceMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[service.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ServiceMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[service.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ServiceMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, service.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ServiceMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ServiceMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ServiceMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[service.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ServiceMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[service.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ServiceMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, service.FieldAnnotations)
}

// SetCreateTime sets the "createTime" field.
func (m *ServiceMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *ServiceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *ServiceMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *ServiceMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *ServiceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *ServiceMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetProjectID sets the "projectID" field.
func (m *ServiceMutation) SetProjectID(o oid.ID) {
	m.project = &o
}

// ProjectID returns the value of the "projectID" field in the mutation.
func (m *ServiceMutation) ProjectID() (r oid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "projectID" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldProjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "projectID" field.
func (m *ServiceMutation) ResetProjectID() {
	m.project = nil
}

// SetEnvironmentID sets the "environmentID" field.
func (m *ServiceMutation) SetEnvironmentID(o oid.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environmentID" field in the mutation.
func (m *ServiceMutation) EnvironmentID() (r oid.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environmentID" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldEnvironmentID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environmentID" field.
func (m *ServiceMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetTemplate sets the "template" field.
func (m *ServiceMutation) SetTemplate(tvr types.TemplateVersionRef) {
	m.template = &tvr
}

// Template returns the value of the "template" field in the mutation.
func (m *ServiceMutation) Template() (r types.TemplateVersionRef, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldTemplate(ctx context.Context) (v types.TemplateVersionRef, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *ServiceMutation) ResetTemplate() {
	m.template = nil
}

// SetAttributes sets the "attributes" field.
func (m *ServiceMutation) SetAttributes(pr property.Values) {
	m.attributes = &pr
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ServiceMutation) Attributes() (r property.Values, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldAttributes(ctx context.Context) (v property.Values, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ServiceMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[service.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ServiceMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[service.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ServiceMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, service.FieldAttributes)
}

// SetStatus sets the "status" field.
func (m *ServiceMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ServiceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[service.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ServiceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[service.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, service.FieldStatus)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ServiceMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ServiceMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ProjectIDs() (ids []oid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ServiceMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *ServiceMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *ServiceMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) EnvironmentIDs() (ids []oid.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *ServiceMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// AddRevisionIDs adds the "revisions" edge to the ServiceRevision entity by ids.
func (m *ServiceMutation) AddRevisionIDs(ids ...oid.ID) {
	if m.revisions == nil {
		m.revisions = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.revisions[ids[i]] = struct{}{}
	}
}

// ClearRevisions clears the "revisions" edge to the ServiceRevision entity.
func (m *ServiceMutation) ClearRevisions() {
	m.clearedrevisions = true
}

// RevisionsCleared reports if the "revisions" edge to the ServiceRevision entity was cleared.
func (m *ServiceMutation) RevisionsCleared() bool {
	return m.clearedrevisions
}

// RemoveRevisionIDs removes the "revisions" edge to the ServiceRevision entity by IDs.
func (m *ServiceMutation) RemoveRevisionIDs(ids ...oid.ID) {
	if m.removedrevisions == nil {
		m.removedrevisions = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.revisions, ids[i])
		m.removedrevisions[ids[i]] = struct{}{}
	}
}

// RemovedRevisions returns the removed IDs of the "revisions" edge to the ServiceRevision entity.
func (m *ServiceMutation) RemovedRevisionsIDs() (ids []oid.ID) {
	for id := range m.removedrevisions {
		ids = append(ids, id)
	}
	return
}

// RevisionsIDs returns the "revisions" edge IDs in the mutation.
func (m *ServiceMutation) RevisionsIDs() (ids []oid.ID) {
	for id := range m.revisions {
		ids = append(ids, id)
	}
	return
}

// ResetRevisions resets all changes to the "revisions" edge.
func (m *ServiceMutation) ResetRevisions() {
	m.revisions = nil
	m.clearedrevisions = false
	m.removedrevisions = nil
}

// AddResourceIDs adds the "resources" edge to the ServiceResource entity by ids.
func (m *ServiceMutation) AddResourceIDs(ids ...oid.ID) {
	if m.resources == nil {
		m.resources = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the ServiceResource entity.
func (m *ServiceMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the ServiceResource entity was cleared.
func (m *ServiceMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the ServiceResource entity by IDs.
func (m *ServiceMutation) RemoveResourceIDs(ids ...oid.ID) {
	if m.removedresources == nil {
		m.removedresources = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the ServiceResource entity.
func (m *ServiceMutation) RemovedResourcesIDs() (ids []oid.ID) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *ServiceMutation) ResourcesIDs() (ids []oid.ID) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *ServiceMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddDependencyIDs adds the "dependencies" edge to the ServiceDependency entity by ids.
func (m *ServiceMutation) AddDependencyIDs(ids ...oid.ID) {
	if m.dependencies == nil {
		m.dependencies = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the ServiceDependency entity.
func (m *ServiceMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the ServiceDependency entity was cleared.
func (m *ServiceMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the ServiceDependency entity by IDs.
func (m *ServiceMutation) RemoveDependencyIDs(ids ...oid.ID) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the ServiceDependency entity.
func (m *ServiceMutation) RemovedDependenciesIDs() (ids []oid.ID) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ServiceMutation) DependenciesIDs() (ids []oid.ID) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ServiceMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Service, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.description != nil {
		fields = append(fields, service.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, service.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, service.FieldAnnotations)
	}
	if m.createTime != nil {
		fields = append(fields, service.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, service.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, service.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, service.FieldEnvironmentID)
	}
	if m.template != nil {
		fields = append(fields, service.FieldTemplate)
	}
	if m.attributes != nil {
		fields = append(fields, service.FieldAttributes)
	}
	if m.status != nil {
		fields = append(fields, service.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldName:
		return m.Name()
	case service.FieldDescription:
		return m.Description()
	case service.FieldLabels:
		return m.Labels()
	case service.FieldAnnotations:
		return m.Annotations()
	case service.FieldCreateTime:
		return m.CreateTime()
	case service.FieldUpdateTime:
		return m.UpdateTime()
	case service.FieldProjectID:
		return m.ProjectID()
	case service.FieldEnvironmentID:
		return m.EnvironmentID()
	case service.FieldTemplate:
		return m.Template()
	case service.FieldAttributes:
		return m.Attributes()
	case service.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldDescription:
		return m.OldDescription(ctx)
	case service.FieldLabels:
		return m.OldLabels(ctx)
	case service.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case service.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case service.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case service.FieldProjectID:
		return m.OldProjectID(ctx)
	case service.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case service.FieldTemplate:
		return m.OldTemplate(ctx)
	case service.FieldAttributes:
		return m.OldAttributes(ctx)
	case service.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case service.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case service.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case service.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case service.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case service.FieldProjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case service.FieldEnvironmentID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case service.FieldTemplate:
		v, ok := value.(types.TemplateVersionRef)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case service.FieldAttributes:
		v, ok := value.(property.Values)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case service.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(service.FieldDescription) {
		fields = append(fields, service.FieldDescription)
	}
	if m.FieldCleared(service.FieldLabels) {
		fields = append(fields, service.FieldLabels)
	}
	if m.FieldCleared(service.FieldAnnotations) {
		fields = append(fields, service.FieldAnnotations)
	}
	if m.FieldCleared(service.FieldAttributes) {
		fields = append(fields, service.FieldAttributes)
	}
	if m.FieldCleared(service.FieldStatus) {
		fields = append(fields, service.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	switch name {
	case service.FieldDescription:
		m.ClearDescription()
		return nil
	case service.FieldLabels:
		m.ClearLabels()
		return nil
	case service.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case service.FieldAttributes:
		m.ClearAttributes()
		return nil
	case service.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldDescription:
		m.ResetDescription()
		return nil
	case service.FieldLabels:
		m.ResetLabels()
		return nil
	case service.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case service.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case service.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case service.FieldProjectID:
		m.ResetProjectID()
		return nil
	case service.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case service.FieldTemplate:
		m.ResetTemplate()
		return nil
	case service.FieldAttributes:
		m.ResetAttributes()
		return nil
	case service.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.project != nil {
		edges = append(edges, service.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, service.EdgeEnvironment)
	}
	if m.revisions != nil {
		edges = append(edges, service.EdgeRevisions)
	}
	if m.resources != nil {
		edges = append(edges, service.EdgeResources)
	}
	if m.dependencies != nil {
		edges = append(edges, service.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.revisions))
		for id := range m.revisions {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrevisions != nil {
		edges = append(edges, service.EdgeRevisions)
	}
	if m.removedresources != nil {
		edges = append(edges, service.EdgeResources)
	}
	if m.removeddependencies != nil {
		edges = append(edges, service.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.removedrevisions))
		for id := range m.removedrevisions {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedproject {
		edges = append(edges, service.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, service.EdgeEnvironment)
	}
	if m.clearedrevisions {
		edges = append(edges, service.EdgeRevisions)
	}
	if m.clearedresources {
		edges = append(edges, service.EdgeResources)
	}
	if m.cleareddependencies {
		edges = append(edges, service.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeProject:
		return m.clearedproject
	case service.EdgeEnvironment:
		return m.clearedenvironment
	case service.EdgeRevisions:
		return m.clearedrevisions
	case service.EdgeResources:
		return m.clearedresources
	case service.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeProject:
		m.ClearProject()
		return nil
	case service.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeProject:
		m.ResetProject()
		return nil
	case service.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case service.EdgeRevisions:
		m.ResetRevisions()
		return nil
	case service.EdgeResources:
		m.ResetResources()
		return nil
	case service.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// ServiceDependencyMutation represents an operation that mutates the ServiceDependency nodes in the graph.
type ServiceDependencyMutation struct {
	config
	op             Op
	typ            string
	id             *oid.ID
	createTime     *time.Time
	dependentID    *oid.ID
	_path          *[]oid.ID
	append_path    []oid.ID
	_type          *string
	clearedFields  map[string]struct{}
	service        *oid.ID
	clearedservice bool
	done           bool
	oldValue       func(context.Context) (*ServiceDependency, error)
	predicates     []predicate.ServiceDependency
}

var _ ent.Mutation = (*ServiceDependencyMutation)(nil)

// serviceDependencyOption allows management of the mutation configuration using functional options.
type serviceDependencyOption func(*ServiceDependencyMutation)

// newServiceDependencyMutation creates new mutation for the ServiceDependency entity.
func newServiceDependencyMutation(c config, op Op, opts ...serviceDependencyOption) *ServiceDependencyMutation {
	m := &ServiceDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceDependencyID sets the ID field of the mutation.
func withServiceDependencyID(id oid.ID) serviceDependencyOption {
	return func(m *ServiceDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceDependency
		)
		m.oldValue = func(ctx context.Context) (*ServiceDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceDependency sets the old ServiceDependency of the mutation.
func withServiceDependency(node *ServiceDependency) serviceDependencyOption {
	return func(m *ServiceDependencyMutation) {
		m.oldValue = func(context.Context) (*ServiceDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceDependency entities.
func (m *ServiceDependencyMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceDependencyMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceDependencyMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *ServiceDependencyMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *ServiceDependencyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *ServiceDependencyMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetServiceID sets the "serviceID" field.
func (m *ServiceDependencyMutation) SetServiceID(o oid.ID) {
	m.service = &o
}

// ServiceID returns the value of the "serviceID" field in the mutation.
func (m *ServiceDependencyMutation) ServiceID() (r oid.ID, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "serviceID" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldServiceID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID resets all changes to the "serviceID" field.
func (m *ServiceDependencyMutation) ResetServiceID() {
	m.service = nil
}

// SetDependentID sets the "dependentID" field.
func (m *ServiceDependencyMutation) SetDependentID(o oid.ID) {
	m.dependentID = &o
}

// DependentID returns the value of the "dependentID" field in the mutation.
func (m *ServiceDependencyMutation) DependentID() (r oid.ID, exists bool) {
	v := m.dependentID
	if v == nil {
		return
	}
	return *v, true
}

// OldDependentID returns the old "dependentID" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldDependentID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependentID: %w", err)
	}
	return oldValue.DependentID, nil
}

// ResetDependentID resets all changes to the "dependentID" field.
func (m *ServiceDependencyMutation) ResetDependentID() {
	m.dependentID = nil
}

// SetPath sets the "path" field.
func (m *ServiceDependencyMutation) SetPath(o []oid.ID) {
	m._path = &o
	m.append_path = nil
}

// Path returns the value of the "path" field in the mutation.
func (m *ServiceDependencyMutation) Path() (r []oid.ID, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldPath(ctx context.Context) (v []oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// AppendPath adds o to the "path" field.
func (m *ServiceDependencyMutation) AppendPath(o []oid.ID) {
	m.append_path = append(m.append_path, o...)
}

// AppendedPath returns the list of values that were appended to the "path" field in this mutation.
func (m *ServiceDependencyMutation) AppendedPath() ([]oid.ID, bool) {
	if len(m.append_path) == 0 {
		return nil, false
	}
	return m.append_path, true
}

// ResetPath resets all changes to the "path" field.
func (m *ServiceDependencyMutation) ResetPath() {
	m._path = nil
	m.append_path = nil
}

// SetType sets the "type" field.
func (m *ServiceDependencyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServiceDependencyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ServiceDependency entity.
// If the ServiceDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceDependencyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServiceDependencyMutation) ResetType() {
	m._type = nil
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceDependencyMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceDependencyMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceDependencyMutation) ServiceIDs() (ids []oid.ID) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceDependencyMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ServiceDependencyMutation builder.
func (m *ServiceDependencyMutation) Where(ps ...predicate.ServiceDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceDependency).
func (m *ServiceDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceDependencyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.createTime != nil {
		fields = append(fields, servicedependency.FieldCreateTime)
	}
	if m.service != nil {
		fields = append(fields, servicedependency.FieldServiceID)
	}
	if m.dependentID != nil {
		fields = append(fields, servicedependency.FieldDependentID)
	}
	if m._path != nil {
		fields = append(fields, servicedependency.FieldPath)
	}
	if m._type != nil {
		fields = append(fields, servicedependency.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicedependency.FieldCreateTime:
		return m.CreateTime()
	case servicedependency.FieldServiceID:
		return m.ServiceID()
	case servicedependency.FieldDependentID:
		return m.DependentID()
	case servicedependency.FieldPath:
		return m.Path()
	case servicedependency.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicedependency.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case servicedependency.FieldServiceID:
		return m.OldServiceID(ctx)
	case servicedependency.FieldDependentID:
		return m.OldDependentID(ctx)
	case servicedependency.FieldPath:
		return m.OldPath(ctx)
	case servicedependency.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicedependency.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case servicedependency.FieldServiceID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case servicedependency.FieldDependentID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependentID(v)
		return nil
	case servicedependency.FieldPath:
		v, ok := value.([]oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case servicedependency.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceDependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceDependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceDependencyMutation) ResetField(name string) error {
	switch name {
	case servicedependency.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case servicedependency.FieldServiceID:
		m.ResetServiceID()
		return nil
	case servicedependency.FieldDependentID:
		m.ResetDependentID()
		return nil
	case servicedependency.FieldPath:
		m.ResetPath()
		return nil
	case servicedependency.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.service != nil {
		edges = append(edges, servicedependency.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicedependency.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservice {
		edges = append(edges, servicedependency.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case servicedependency.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceDependencyMutation) ClearEdge(name string) error {
	switch name {
	case servicedependency.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceDependencyMutation) ResetEdge(name string) error {
	switch name {
	case servicedependency.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown ServiceDependency edge %s", name)
}

// ServiceResourceMutation represents an operation that mutates the ServiceResource nodes in the graph.
type ServiceResourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *oid.ID
	createTime         *time.Time
	updateTime         *time.Time
	projectID          *oid.ID
	mode               *string
	_type              *string
	name               *string
	deployerType       *string
	status             *types.ServiceResourceStatus
	clearedFields      map[string]struct{}
	service            *oid.ID
	clearedservice     bool
	connector          *oid.ID
	clearedconnector   bool
	composition        *oid.ID
	clearedcomposition bool
	components         map[oid.ID]struct{}
	removedcomponents  map[oid.ID]struct{}
	clearedcomponents  bool
	done               bool
	oldValue           func(context.Context) (*ServiceResource, error)
	predicates         []predicate.ServiceResource
}

var _ ent.Mutation = (*ServiceResourceMutation)(nil)

// serviceResourceOption allows management of the mutation configuration using functional options.
type serviceResourceOption func(*ServiceResourceMutation)

// newServiceResourceMutation creates new mutation for the ServiceResource entity.
func newServiceResourceMutation(c config, op Op, opts ...serviceResourceOption) *ServiceResourceMutation {
	m := &ServiceResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceResourceID sets the ID field of the mutation.
func withServiceResourceID(id oid.ID) serviceResourceOption {
	return func(m *ServiceResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceResource
		)
		m.oldValue = func(ctx context.Context) (*ServiceResource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceResource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceResource sets the old ServiceResource of the mutation.
func withServiceResource(node *ServiceResource) serviceResourceOption {
	return func(m *ServiceResourceMutation) {
		m.oldValue = func(context.Context) (*ServiceResource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceResource entities.
func (m *ServiceResourceMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceResourceMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceResourceMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceResource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *ServiceResourceMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *ServiceResourceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *ServiceResourceMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *ServiceResourceMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *ServiceResourceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *ServiceResourceMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetProjectID sets the "projectID" field.
func (m *ServiceResourceMutation) SetProjectID(o oid.ID) {
	m.projectID = &o
}

// ProjectID returns the value of the "projectID" field in the mutation.
func (m *ServiceResourceMutation) ProjectID() (r oid.ID, exists bool) {
	v := m.projectID
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "projectID" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldProjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "projectID" field.
func (m *ServiceResourceMutation) ResetProjectID() {
	m.projectID = nil
}

// SetServiceID sets the "serviceID" field.
func (m *ServiceResourceMutation) SetServiceID(o oid.ID) {
	m.service = &o
}

// ServiceID returns the value of the "serviceID" field in the mutation.
func (m *ServiceResourceMutation) ServiceID() (r oid.ID, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "serviceID" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldServiceID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID resets all changes to the "serviceID" field.
func (m *ServiceResourceMutation) ResetServiceID() {
	m.service = nil
}

// SetConnectorID sets the "connectorID" field.
func (m *ServiceResourceMutation) SetConnectorID(o oid.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connectorID" field in the mutation.
func (m *ServiceResourceMutation) ConnectorID() (r oid.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connectorID" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldConnectorID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connectorID" field.
func (m *ServiceResourceMutation) ResetConnectorID() {
	m.connector = nil
}

// SetCompositionID sets the "compositionID" field.
func (m *ServiceResourceMutation) SetCompositionID(o oid.ID) {
	m.composition = &o
}

// CompositionID returns the value of the "compositionID" field in the mutation.
func (m *ServiceResourceMutation) CompositionID() (r oid.ID, exists bool) {
	v := m.composition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompositionID returns the old "compositionID" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldCompositionID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompositionID: %w", err)
	}
	return oldValue.CompositionID, nil
}

// ClearCompositionID clears the value of the "compositionID" field.
func (m *ServiceResourceMutation) ClearCompositionID() {
	m.composition = nil
	m.clearedFields[serviceresource.FieldCompositionID] = struct{}{}
}

// CompositionIDCleared returns if the "compositionID" field was cleared in this mutation.
func (m *ServiceResourceMutation) CompositionIDCleared() bool {
	_, ok := m.clearedFields[serviceresource.FieldCompositionID]
	return ok
}

// ResetCompositionID resets all changes to the "compositionID" field.
func (m *ServiceResourceMutation) ResetCompositionID() {
	m.composition = nil
	delete(m.clearedFields, serviceresource.FieldCompositionID)
}

// SetMode sets the "mode" field.
func (m *ServiceResourceMutation) SetMode(s string) {
	m.mode = &s
}

// Mode returns the value of the "mode" field in the mutation.
func (m *ServiceResourceMutation) Mode() (r string, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *ServiceResourceMutation) ResetMode() {
	m.mode = nil
}

// SetType sets the "type" field.
func (m *ServiceResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServiceResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServiceResourceMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ServiceResourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceResourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceResourceMutation) ResetName() {
	m.name = nil
}

// SetDeployerType sets the "deployerType" field.
func (m *ServiceResourceMutation) SetDeployerType(s string) {
	m.deployerType = &s
}

// DeployerType returns the value of the "deployerType" field in the mutation.
func (m *ServiceResourceMutation) DeployerType() (r string, exists bool) {
	v := m.deployerType
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployerType returns the old "deployerType" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldDeployerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployerType: %w", err)
	}
	return oldValue.DeployerType, nil
}

// ResetDeployerType resets all changes to the "deployerType" field.
func (m *ServiceResourceMutation) ResetDeployerType() {
	m.deployerType = nil
}

// SetStatus sets the "status" field.
func (m *ServiceResourceMutation) SetStatus(trs types.ServiceResourceStatus) {
	m.status = &trs
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceResourceMutation) Status() (r types.ServiceResourceStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceResource entity.
// If the ServiceResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceResourceMutation) OldStatus(ctx context.Context) (v types.ServiceResourceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ServiceResourceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[serviceresource.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ServiceResourceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[serviceresource.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceResourceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, serviceresource.FieldStatus)
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceResourceMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceResourceMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) ServiceIDs() (ids []oid.ID) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceResourceMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *ServiceResourceMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *ServiceResourceMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) ConnectorIDs() (ids []oid.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *ServiceResourceMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// ClearComposition clears the "composition" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) ClearComposition() {
	m.clearedcomposition = true
}

// CompositionCleared reports if the "composition" edge to the ServiceResource entity was cleared.
func (m *ServiceResourceMutation) CompositionCleared() bool {
	return m.CompositionIDCleared() || m.clearedcomposition
}

// CompositionIDs returns the "composition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompositionID instead. It exists only for internal usage by the builders.
func (m *ServiceResourceMutation) CompositionIDs() (ids []oid.ID) {
	if id := m.composition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComposition resets all changes to the "composition" edge.
func (m *ServiceResourceMutation) ResetComposition() {
	m.composition = nil
	m.clearedcomposition = false
}

// AddComponentIDs adds the "components" edge to the ServiceResource entity by ids.
func (m *ServiceResourceMutation) AddComponentIDs(ids ...oid.ID) {
	if m.components == nil {
		m.components = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ServiceResource entity was cleared.
func (m *ServiceResourceMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ServiceResource entity by IDs.
func (m *ServiceResourceMutation) RemoveComponentIDs(ids ...oid.ID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ServiceResource entity.
func (m *ServiceResourceMutation) RemovedComponentsIDs() (ids []oid.ID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ServiceResourceMutation) ComponentsIDs() (ids []oid.ID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ServiceResourceMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// Where appends a list predicates to the ServiceResourceMutation builder.
func (m *ServiceResourceMutation) Where(ps ...predicate.ServiceResource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceResource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceResource).
func (m *ServiceResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceResourceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.createTime != nil {
		fields = append(fields, serviceresource.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, serviceresource.FieldUpdateTime)
	}
	if m.projectID != nil {
		fields = append(fields, serviceresource.FieldProjectID)
	}
	if m.service != nil {
		fields = append(fields, serviceresource.FieldServiceID)
	}
	if m.connector != nil {
		fields = append(fields, serviceresource.FieldConnectorID)
	}
	if m.composition != nil {
		fields = append(fields, serviceresource.FieldCompositionID)
	}
	if m.mode != nil {
		fields = append(fields, serviceresource.FieldMode)
	}
	if m._type != nil {
		fields = append(fields, serviceresource.FieldType)
	}
	if m.name != nil {
		fields = append(fields, serviceresource.FieldName)
	}
	if m.deployerType != nil {
		fields = append(fields, serviceresource.FieldDeployerType)
	}
	if m.status != nil {
		fields = append(fields, serviceresource.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceresource.FieldCreateTime:
		return m.CreateTime()
	case serviceresource.FieldUpdateTime:
		return m.UpdateTime()
	case serviceresource.FieldProjectID:
		return m.ProjectID()
	case serviceresource.FieldServiceID:
		return m.ServiceID()
	case serviceresource.FieldConnectorID:
		return m.ConnectorID()
	case serviceresource.FieldCompositionID:
		return m.CompositionID()
	case serviceresource.FieldMode:
		return m.Mode()
	case serviceresource.FieldType:
		return m.GetType()
	case serviceresource.FieldName:
		return m.Name()
	case serviceresource.FieldDeployerType:
		return m.DeployerType()
	case serviceresource.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceresource.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceresource.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serviceresource.FieldProjectID:
		return m.OldProjectID(ctx)
	case serviceresource.FieldServiceID:
		return m.OldServiceID(ctx)
	case serviceresource.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case serviceresource.FieldCompositionID:
		return m.OldCompositionID(ctx)
	case serviceresource.FieldMode:
		return m.OldMode(ctx)
	case serviceresource.FieldType:
		return m.OldType(ctx)
	case serviceresource.FieldName:
		return m.OldName(ctx)
	case serviceresource.FieldDeployerType:
		return m.OldDeployerType(ctx)
	case serviceresource.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceResource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceresource.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceresource.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serviceresource.FieldProjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case serviceresource.FieldServiceID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case serviceresource.FieldConnectorID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case serviceresource.FieldCompositionID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompositionID(v)
		return nil
	case serviceresource.FieldMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case serviceresource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case serviceresource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case serviceresource.FieldDeployerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployerType(v)
		return nil
	case serviceresource.FieldStatus:
		v, ok := value.(types.ServiceResourceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceResource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceResource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceresource.FieldCompositionID) {
		fields = append(fields, serviceresource.FieldCompositionID)
	}
	if m.FieldCleared(serviceresource.FieldStatus) {
		fields = append(fields, serviceresource.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceResourceMutation) ClearField(name string) error {
	switch name {
	case serviceresource.FieldCompositionID:
		m.ClearCompositionID()
		return nil
	case serviceresource.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown ServiceResource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceResourceMutation) ResetField(name string) error {
	switch name {
	case serviceresource.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceresource.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serviceresource.FieldProjectID:
		m.ResetProjectID()
		return nil
	case serviceresource.FieldServiceID:
		m.ResetServiceID()
		return nil
	case serviceresource.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case serviceresource.FieldCompositionID:
		m.ResetCompositionID()
		return nil
	case serviceresource.FieldMode:
		m.ResetMode()
		return nil
	case serviceresource.FieldType:
		m.ResetType()
		return nil
	case serviceresource.FieldName:
		m.ResetName()
		return nil
	case serviceresource.FieldDeployerType:
		m.ResetDeployerType()
		return nil
	case serviceresource.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ServiceResource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.service != nil {
		edges = append(edges, serviceresource.EdgeService)
	}
	if m.connector != nil {
		edges = append(edges, serviceresource.EdgeConnector)
	}
	if m.composition != nil {
		edges = append(edges, serviceresource.EdgeComposition)
	}
	if m.components != nil {
		edges = append(edges, serviceresource.EdgeComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceresource.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeComposition:
		if id := m.composition; id != nil {
			return []ent.Value{*id}
		}
	case serviceresource.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomponents != nil {
		edges = append(edges, serviceresource.EdgeComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceresource.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedservice {
		edges = append(edges, serviceresource.EdgeService)
	}
	if m.clearedconnector {
		edges = append(edges, serviceresource.EdgeConnector)
	}
	if m.clearedcomposition {
		edges = append(edges, serviceresource.EdgeComposition)
	}
	if m.clearedcomponents {
		edges = append(edges, serviceresource.EdgeComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceresource.EdgeService:
		return m.clearedservice
	case serviceresource.EdgeConnector:
		return m.clearedconnector
	case serviceresource.EdgeComposition:
		return m.clearedcomposition
	case serviceresource.EdgeComponents:
		return m.clearedcomponents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceResourceMutation) ClearEdge(name string) error {
	switch name {
	case serviceresource.EdgeService:
		m.ClearService()
		return nil
	case serviceresource.EdgeConnector:
		m.ClearConnector()
		return nil
	case serviceresource.EdgeComposition:
		m.ClearComposition()
		return nil
	}
	return fmt.Errorf("unknown ServiceResource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceResourceMutation) ResetEdge(name string) error {
	switch name {
	case serviceresource.EdgeService:
		m.ResetService()
		return nil
	case serviceresource.EdgeConnector:
		m.ResetConnector()
		return nil
	case serviceresource.EdgeComposition:
		m.ResetComposition()
		return nil
	case serviceresource.EdgeComponents:
		m.ResetComponents()
		return nil
	}
	return fmt.Errorf("unknown ServiceResource edge %s", name)
}

// ServiceRevisionMutation represents an operation that mutates the ServiceRevision nodes in the graph.
type ServiceRevisionMutation struct {
	config
	op                              Op
	typ                             string
	id                              *oid.ID
	createTime                      *time.Time
	status                          *string
	statusMessage                   *string
	templateID                      *string
	templateVersion                 *string
	attributes                      *property.Values
	secrets                         *crypto.Map[string, string]
	inputPlan                       *string
	output                          *string
	deployerType                    *string
	duration                        *int
	addduration                     *int
	previousRequiredProviders       *[]types.ProviderRequirement
	appendpreviousRequiredProviders []types.ProviderRequirement
	tags                            *[]string
	appendtags                      []string
	clearedFields                   map[string]struct{}
	project                         *oid.ID
	clearedproject                  bool
	environment                     *oid.ID
	clearedenvironment              bool
	service                         *oid.ID
	clearedservice                  bool
	done                            bool
	oldValue                        func(context.Context) (*ServiceRevision, error)
	predicates                      []predicate.ServiceRevision
}

var _ ent.Mutation = (*ServiceRevisionMutation)(nil)

// serviceRevisionOption allows management of the mutation configuration using functional options.
type serviceRevisionOption func(*ServiceRevisionMutation)

// newServiceRevisionMutation creates new mutation for the ServiceRevision entity.
func newServiceRevisionMutation(c config, op Op, opts ...serviceRevisionOption) *ServiceRevisionMutation {
	m := &ServiceRevisionMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceRevision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceRevisionID sets the ID field of the mutation.
func withServiceRevisionID(id oid.ID) serviceRevisionOption {
	return func(m *ServiceRevisionMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceRevision
		)
		m.oldValue = func(ctx context.Context) (*ServiceRevision, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceRevision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceRevision sets the old ServiceRevision of the mutation.
func withServiceRevision(node *ServiceRevision) serviceRevisionOption {
	return func(m *ServiceRevisionMutation) {
		m.oldValue = func(context.Context) (*ServiceRevision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceRevisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceRevisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceRevision entities.
func (m *ServiceRevisionMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceRevisionMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceRevisionMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceRevision.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *ServiceRevisionMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *ServiceRevisionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *ServiceRevisionMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetProjectID sets the "projectID" field.
func (m *ServiceRevisionMutation) SetProjectID(o oid.ID) {
	m.project = &o
}

// ProjectID returns the value of the "projectID" field in the mutation.
func (m *ServiceRevisionMutation) ProjectID() (r oid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "projectID" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldProjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "projectID" field.
func (m *ServiceRevisionMutation) ResetProjectID() {
	m.project = nil
}

// SetStatus sets the "status" field.
func (m *ServiceRevisionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceRevisionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ServiceRevisionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[servicerevision.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ServiceRevisionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[servicerevision.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceRevisionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, servicerevision.FieldStatus)
}

// SetStatusMessage sets the "statusMessage" field.
func (m *ServiceRevisionMutation) SetStatusMessage(s string) {
	m.statusMessage = &s
}

// StatusMessage returns the value of the "statusMessage" field in the mutation.
func (m *ServiceRevisionMutation) StatusMessage() (r string, exists bool) {
	v := m.statusMessage
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusMessage returns the old "statusMessage" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldStatusMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusMessage: %w", err)
	}
	return oldValue.StatusMessage, nil
}

// ClearStatusMessage clears the value of the "statusMessage" field.
func (m *ServiceRevisionMutation) ClearStatusMessage() {
	m.statusMessage = nil
	m.clearedFields[servicerevision.FieldStatusMessage] = struct{}{}
}

// StatusMessageCleared returns if the "statusMessage" field was cleared in this mutation.
func (m *ServiceRevisionMutation) StatusMessageCleared() bool {
	_, ok := m.clearedFields[servicerevision.FieldStatusMessage]
	return ok
}

// ResetStatusMessage resets all changes to the "statusMessage" field.
func (m *ServiceRevisionMutation) ResetStatusMessage() {
	m.statusMessage = nil
	delete(m.clearedFields, servicerevision.FieldStatusMessage)
}

// SetServiceID sets the "serviceID" field.
func (m *ServiceRevisionMutation) SetServiceID(o oid.ID) {
	m.service = &o
}

// ServiceID returns the value of the "serviceID" field in the mutation.
func (m *ServiceRevisionMutation) ServiceID() (r oid.ID, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "serviceID" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldServiceID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID resets all changes to the "serviceID" field.
func (m *ServiceRevisionMutation) ResetServiceID() {
	m.service = nil
}

// SetEnvironmentID sets the "environmentID" field.
func (m *ServiceRevisionMutation) SetEnvironmentID(o oid.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environmentID" field in the mutation.
func (m *ServiceRevisionMutation) EnvironmentID() (r oid.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environmentID" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldEnvironmentID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environmentID" field.
func (m *ServiceRevisionMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetTemplateID sets the "templateID" field.
func (m *ServiceRevisionMutation) SetTemplateID(s string) {
	m.templateID = &s
}

// TemplateID returns the value of the "templateID" field in the mutation.
func (m *ServiceRevisionMutation) TemplateID() (r string, exists bool) {
	v := m.templateID
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "templateID" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "templateID" field.
func (m *ServiceRevisionMutation) ResetTemplateID() {
	m.templateID = nil
}

// SetTemplateVersion sets the "templateVersion" field.
func (m *ServiceRevisionMutation) SetTemplateVersion(s string) {
	m.templateVersion = &s
}

// TemplateVersion returns the value of the "templateVersion" field in the mutation.
func (m *ServiceRevisionMutation) TemplateVersion() (r string, exists bool) {
	v := m.templateVersion
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateVersion returns the old "templateVersion" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldTemplateVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateVersion: %w", err)
	}
	return oldValue.TemplateVersion, nil
}

// ResetTemplateVersion resets all changes to the "templateVersion" field.
func (m *ServiceRevisionMutation) ResetTemplateVersion() {
	m.templateVersion = nil
}

// SetAttributes sets the "attributes" field.
func (m *ServiceRevisionMutation) SetAttributes(pr property.Values) {
	m.attributes = &pr
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ServiceRevisionMutation) Attributes() (r property.Values, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldAttributes(ctx context.Context) (v property.Values, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ServiceRevisionMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[servicerevision.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ServiceRevisionMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[servicerevision.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ServiceRevisionMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, servicerevision.FieldAttributes)
}

// SetSecrets sets the "secrets" field.
func (m *ServiceRevisionMutation) SetSecrets(c crypto.Map[string, string]) {
	m.secrets = &c
}

// Secrets returns the value of the "secrets" field in the mutation.
func (m *ServiceRevisionMutation) Secrets() (r crypto.Map[string, string], exists bool) {
	v := m.secrets
	if v == nil {
		return
	}
	return *v, true
}

// OldSecrets returns the old "secrets" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldSecrets(ctx context.Context) (v crypto.Map[string, string], err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecrets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecrets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecrets: %w", err)
	}
	return oldValue.Secrets, nil
}

// ResetSecrets resets all changes to the "secrets" field.
func (m *ServiceRevisionMutation) ResetSecrets() {
	m.secrets = nil
}

// SetInputPlan sets the "inputPlan" field.
func (m *ServiceRevisionMutation) SetInputPlan(s string) {
	m.inputPlan = &s
}

// InputPlan returns the value of the "inputPlan" field in the mutation.
func (m *ServiceRevisionMutation) InputPlan() (r string, exists bool) {
	v := m.inputPlan
	if v == nil {
		return
	}
	return *v, true
}

// OldInputPlan returns the old "inputPlan" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldInputPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputPlan: %w", err)
	}
	return oldValue.InputPlan, nil
}

// ResetInputPlan resets all changes to the "inputPlan" field.
func (m *ServiceRevisionMutation) ResetInputPlan() {
	m.inputPlan = nil
}

// SetOutput sets the "output" field.
func (m *ServiceRevisionMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *ServiceRevisionMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *ServiceRevisionMutation) ResetOutput() {
	m.output = nil
}

// SetDeployerType sets the "deployerType" field.
func (m *ServiceRevisionMutation) SetDeployerType(s string) {
	m.deployerType = &s
}

// DeployerType returns the value of the "deployerType" field in the mutation.
func (m *ServiceRevisionMutation) DeployerType() (r string, exists bool) {
	v := m.deployerType
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployerType returns the old "deployerType" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldDeployerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployerType: %w", err)
	}
	return oldValue.DeployerType, nil
}

// ResetDeployerType resets all changes to the "deployerType" field.
func (m *ServiceRevisionMutation) ResetDeployerType() {
	m.deployerType = nil
}

// SetDuration sets the "duration" field.
func (m *ServiceRevisionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ServiceRevisionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ServiceRevisionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ServiceRevisionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *ServiceRevisionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetPreviousRequiredProviders sets the "previousRequiredProviders" field.
func (m *ServiceRevisionMutation) SetPreviousRequiredProviders(tr []types.ProviderRequirement) {
	m.previousRequiredProviders = &tr
	m.appendpreviousRequiredProviders = nil
}

// PreviousRequiredProviders returns the value of the "previousRequiredProviders" field in the mutation.
func (m *ServiceRevisionMutation) PreviousRequiredProviders() (r []types.ProviderRequirement, exists bool) {
	v := m.previousRequiredProviders
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousRequiredProviders returns the old "previousRequiredProviders" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldPreviousRequiredProviders(ctx context.Context) (v []types.ProviderRequirement, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousRequiredProviders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousRequiredProviders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousRequiredProviders: %w", err)
	}
	return oldValue.PreviousRequiredProviders, nil
}

// AppendPreviousRequiredProviders adds tr to the "previousRequiredProviders" field.
func (m *ServiceRevisionMutation) AppendPreviousRequiredProviders(tr []types.ProviderRequirement) {
	m.appendpreviousRequiredProviders = append(m.appendpreviousRequiredProviders, tr...)
}

// AppendedPreviousRequiredProviders returns the list of values that were appended to the "previousRequiredProviders" field in this mutation.
func (m *ServiceRevisionMutation) AppendedPreviousRequiredProviders() ([]types.ProviderRequirement, bool) {
	if len(m.appendpreviousRequiredProviders) == 0 {
		return nil, false
	}
	return m.appendpreviousRequiredProviders, true
}

// ResetPreviousRequiredProviders resets all changes to the "previousRequiredProviders" field.
func (m *ServiceRevisionMutation) ResetPreviousRequiredProviders() {
	m.previousRequiredProviders = nil
	m.appendpreviousRequiredProviders = nil
}

// SetTags sets the "tags" field.
func (m *ServiceRevisionMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ServiceRevisionMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ServiceRevision entity.
// If the ServiceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRevisionMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ServiceRevisionMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ServiceRevisionMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *ServiceRevisionMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ServiceRevisionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ServiceRevisionMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ServiceRevisionMutation) ProjectIDs() (ids []oid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ServiceRevisionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *ServiceRevisionMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *ServiceRevisionMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ServiceRevisionMutation) EnvironmentIDs() (ids []oid.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *ServiceRevisionMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearService clears the "service" edge to the Service entity.
func (m *ServiceRevisionMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *ServiceRevisionMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceRevisionMutation) ServiceIDs() (ids []oid.ID) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *ServiceRevisionMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Where appends a list predicates to the ServiceRevisionMutation builder.
func (m *ServiceRevisionMutation) Where(ps ...predicate.ServiceRevision) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceRevisionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceRevisionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceRevision, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceRevisionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceRevisionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceRevision).
func (m *ServiceRevisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceRevisionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.createTime != nil {
		fields = append(fields, servicerevision.FieldCreateTime)
	}
	if m.project != nil {
		fields = append(fields, servicerevision.FieldProjectID)
	}
	if m.status != nil {
		fields = append(fields, servicerevision.FieldStatus)
	}
	if m.statusMessage != nil {
		fields = append(fields, servicerevision.FieldStatusMessage)
	}
	if m.service != nil {
		fields = append(fields, servicerevision.FieldServiceID)
	}
	if m.environment != nil {
		fields = append(fields, servicerevision.FieldEnvironmentID)
	}
	if m.templateID != nil {
		fields = append(fields, servicerevision.FieldTemplateID)
	}
	if m.templateVersion != nil {
		fields = append(fields, servicerevision.FieldTemplateVersion)
	}
	if m.attributes != nil {
		fields = append(fields, servicerevision.FieldAttributes)
	}
	if m.secrets != nil {
		fields = append(fields, servicerevision.FieldSecrets)
	}
	if m.inputPlan != nil {
		fields = append(fields, servicerevision.FieldInputPlan)
	}
	if m.output != nil {
		fields = append(fields, servicerevision.FieldOutput)
	}
	if m.deployerType != nil {
		fields = append(fields, servicerevision.FieldDeployerType)
	}
	if m.duration != nil {
		fields = append(fields, servicerevision.FieldDuration)
	}
	if m.previousRequiredProviders != nil {
		fields = append(fields, servicerevision.FieldPreviousRequiredProviders)
	}
	if m.tags != nil {
		fields = append(fields, servicerevision.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceRevisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicerevision.FieldCreateTime:
		return m.CreateTime()
	case servicerevision.FieldProjectID:
		return m.ProjectID()
	case servicerevision.FieldStatus:
		return m.Status()
	case servicerevision.FieldStatusMessage:
		return m.StatusMessage()
	case servicerevision.FieldServiceID:
		return m.ServiceID()
	case servicerevision.FieldEnvironmentID:
		return m.EnvironmentID()
	case servicerevision.FieldTemplateID:
		return m.TemplateID()
	case servicerevision.FieldTemplateVersion:
		return m.TemplateVersion()
	case servicerevision.FieldAttributes:
		return m.Attributes()
	case servicerevision.FieldSecrets:
		return m.Secrets()
	case servicerevision.FieldInputPlan:
		return m.InputPlan()
	case servicerevision.FieldOutput:
		return m.Output()
	case servicerevision.FieldDeployerType:
		return m.DeployerType()
	case servicerevision.FieldDuration:
		return m.Duration()
	case servicerevision.FieldPreviousRequiredProviders:
		return m.PreviousRequiredProviders()
	case servicerevision.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceRevisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicerevision.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case servicerevision.FieldProjectID:
		return m.OldProjectID(ctx)
	case servicerevision.FieldStatus:
		return m.OldStatus(ctx)
	case servicerevision.FieldStatusMessage:
		return m.OldStatusMessage(ctx)
	case servicerevision.FieldServiceID:
		return m.OldServiceID(ctx)
	case servicerevision.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case servicerevision.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case servicerevision.FieldTemplateVersion:
		return m.OldTemplateVersion(ctx)
	case servicerevision.FieldAttributes:
		return m.OldAttributes(ctx)
	case servicerevision.FieldSecrets:
		return m.OldSecrets(ctx)
	case servicerevision.FieldInputPlan:
		return m.OldInputPlan(ctx)
	case servicerevision.FieldOutput:
		return m.OldOutput(ctx)
	case servicerevision.FieldDeployerType:
		return m.OldDeployerType(ctx)
	case servicerevision.FieldDuration:
		return m.OldDuration(ctx)
	case servicerevision.FieldPreviousRequiredProviders:
		return m.OldPreviousRequiredProviders(ctx)
	case servicerevision.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceRevision field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRevisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicerevision.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case servicerevision.FieldProjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case servicerevision.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicerevision.FieldStatusMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusMessage(v)
		return nil
	case servicerevision.FieldServiceID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case servicerevision.FieldEnvironmentID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case servicerevision.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case servicerevision.FieldTemplateVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateVersion(v)
		return nil
	case servicerevision.FieldAttributes:
		v, ok := value.(property.Values)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case servicerevision.FieldSecrets:
		v, ok := value.(crypto.Map[string, string])
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecrets(v)
		return nil
	case servicerevision.FieldInputPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputPlan(v)
		return nil
	case servicerevision.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case servicerevision.FieldDeployerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployerType(v)
		return nil
	case servicerevision.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case servicerevision.FieldPreviousRequiredProviders:
		v, ok := value.([]types.ProviderRequirement)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousRequiredProviders(v)
		return nil
	case servicerevision.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceRevisionMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, servicerevision.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceRevisionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicerevision.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRevisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicerevision.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceRevisionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicerevision.FieldStatus) {
		fields = append(fields, servicerevision.FieldStatus)
	}
	if m.FieldCleared(servicerevision.FieldStatusMessage) {
		fields = append(fields, servicerevision.FieldStatusMessage)
	}
	if m.FieldCleared(servicerevision.FieldAttributes) {
		fields = append(fields, servicerevision.FieldAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceRevisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceRevisionMutation) ClearField(name string) error {
	switch name {
	case servicerevision.FieldStatus:
		m.ClearStatus()
		return nil
	case servicerevision.FieldStatusMessage:
		m.ClearStatusMessage()
		return nil
	case servicerevision.FieldAttributes:
		m.ClearAttributes()
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceRevisionMutation) ResetField(name string) error {
	switch name {
	case servicerevision.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case servicerevision.FieldProjectID:
		m.ResetProjectID()
		return nil
	case servicerevision.FieldStatus:
		m.ResetStatus()
		return nil
	case servicerevision.FieldStatusMessage:
		m.ResetStatusMessage()
		return nil
	case servicerevision.FieldServiceID:
		m.ResetServiceID()
		return nil
	case servicerevision.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case servicerevision.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case servicerevision.FieldTemplateVersion:
		m.ResetTemplateVersion()
		return nil
	case servicerevision.FieldAttributes:
		m.ResetAttributes()
		return nil
	case servicerevision.FieldSecrets:
		m.ResetSecrets()
		return nil
	case servicerevision.FieldInputPlan:
		m.ResetInputPlan()
		return nil
	case servicerevision.FieldOutput:
		m.ResetOutput()
		return nil
	case servicerevision.FieldDeployerType:
		m.ResetDeployerType()
		return nil
	case servicerevision.FieldDuration:
		m.ResetDuration()
		return nil
	case servicerevision.FieldPreviousRequiredProviders:
		m.ResetPreviousRequiredProviders()
		return nil
	case servicerevision.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceRevisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, servicerevision.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, servicerevision.EdgeEnvironment)
	}
	if m.service != nil {
		edges = append(edges, servicerevision.EdgeService)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceRevisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicerevision.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case servicerevision.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case servicerevision.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceRevisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceRevisionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceRevisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, servicerevision.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, servicerevision.EdgeEnvironment)
	}
	if m.clearedservice {
		edges = append(edges, servicerevision.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceRevisionMutation) EdgeCleared(name string) bool {
	switch name {
	case servicerevision.EdgeProject:
		return m.clearedproject
	case servicerevision.EdgeEnvironment:
		return m.clearedenvironment
	case servicerevision.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceRevisionMutation) ClearEdge(name string) error {
	switch name {
	case servicerevision.EdgeProject:
		m.ClearProject()
		return nil
	case servicerevision.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case servicerevision.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceRevisionMutation) ResetEdge(name string) error {
	switch name {
	case servicerevision.EdgeProject:
		m.ResetProject()
		return nil
	case servicerevision.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case servicerevision.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown ServiceRevision edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *oid.ID
	createTime    *time.Time
	updateTime    *time.Time
	name          *string
	value         *string
	hidden        *bool
	editable      *bool
	private       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id oid.ID) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *SettingMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *SettingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *SettingMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *SettingMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *SettingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *SettingMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetHidden sets the "hidden" field.
func (m *SettingMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *SettingMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldHidden(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *SettingMutation) ResetHidden() {
	m.hidden = nil
}

// SetEditable sets the "editable" field.
func (m *SettingMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *SettingMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldEditable(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable resets all changes to the "editable" field.
func (m *SettingMutation) ResetEditable() {
	m.editable = nil
}

// SetPrivate sets the "private" field.
func (m *SettingMutation) SetPrivate(b bool) {
	m.private = &b
}

// Private returns the value of the "private" field in the mutation.
func (m *SettingMutation) Private() (r bool, exists bool) {
	v := m.private
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivate returns the old "private" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldPrivate(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivate: %w", err)
	}
	return oldValue.Private, nil
}

// ResetPrivate resets all changes to the "private" field.
func (m *SettingMutation) ResetPrivate() {
	m.private = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.createTime != nil {
		fields = append(fields, setting.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, setting.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.hidden != nil {
		fields = append(fields, setting.FieldHidden)
	}
	if m.editable != nil {
		fields = append(fields, setting.FieldEditable)
	}
	if m.private != nil {
		fields = append(fields, setting.FieldPrivate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreateTime:
		return m.CreateTime()
	case setting.FieldUpdateTime:
		return m.UpdateTime()
	case setting.FieldName:
		return m.Name()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldHidden:
		return m.Hidden()
	case setting.FieldEditable:
		return m.Editable()
	case setting.FieldPrivate:
		return m.Private()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case setting.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldHidden:
		return m.OldHidden(ctx)
	case setting.FieldEditable:
		return m.OldEditable(ctx)
	case setting.FieldPrivate:
		return m.OldPrivate(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case setting.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case setting.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	case setting.FieldPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivate(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case setting.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldHidden:
		m.ResetHidden()
		return nil
	case setting.FieldEditable:
		m.ResetEditable()
		return nil
	case setting.FieldPrivate:
		m.ResetPrivate()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SubjectMutation represents an operation that mutates the Subject nodes in the graph.
type SubjectMutation struct {
	config
	op            Op
	typ           string
	id            *oid.ID
	createTime    *time.Time
	updateTime    *time.Time
	kind          *string
	domain        *string
	name          *string
	description   *string
	builtin       *bool
	clearedFields map[string]struct{}
	tokens        map[oid.ID]struct{}
	removedtokens map[oid.ID]struct{}
	clearedtokens bool
	roles         map[oid.ID]struct{}
	removedroles  map[oid.ID]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Subject, error)
	predicates    []predicate.Subject
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows management of the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for the Subject entity.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the ID field of the mutation.
func withSubjectID(id oid.ID) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subject entities.
func (m *SubjectMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *SubjectMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *SubjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *SubjectMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *SubjectMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *SubjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *SubjectMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetKind sets the "kind" field.
func (m *SubjectMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *SubjectMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *SubjectMutation) ResetKind() {
	m.kind = nil
}

// SetDomain sets the "domain" field.
func (m *SubjectMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *SubjectMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *SubjectMutation) ResetDomain() {
	m.domain = nil
}

// SetName sets the "name" field.
func (m *SubjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subject.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subject.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subject.FieldDescription)
}

// SetBuiltin sets the "builtin" field.
func (m *SubjectMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *SubjectMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *SubjectMutation) ResetBuiltin() {
	m.builtin = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *SubjectMutation) AddTokenIDs(ids ...oid.ID) {
	if m.tokens == nil {
		m.tokens = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *SubjectMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *SubjectMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *SubjectMutation) RemoveTokenIDs(ids ...oid.ID) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *SubjectMutation) RemovedTokensIDs() (ids []oid.ID) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *SubjectMutation) TokensIDs() (ids []oid.ID) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *SubjectMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddRoleIDs adds the "roles" edge to the SubjectRoleRelationship entity by ids.
func (m *SubjectMutation) AddRoleIDs(ids ...oid.ID) {
	if m.roles == nil {
		m.roles = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the SubjectRoleRelationship entity.
func (m *SubjectMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the SubjectRoleRelationship entity was cleared.
func (m *SubjectMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the SubjectRoleRelationship entity by IDs.
func (m *SubjectMutation) RemoveRoleIDs(ids ...oid.ID) {
	if m.removedroles == nil {
		m.removedroles = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the SubjectRoleRelationship entity.
func (m *SubjectMutation) RemovedRolesIDs() (ids []oid.ID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *SubjectMutation) RolesIDs() (ids []oid.ID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *SubjectMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the SubjectMutation builder.
func (m *SubjectMutation) Where(ps ...predicate.Subject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.createTime != nil {
		fields = append(fields, subject.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, subject.FieldUpdateTime)
	}
	if m.kind != nil {
		fields = append(fields, subject.FieldKind)
	}
	if m.domain != nil {
		fields = append(fields, subject.FieldDomain)
	}
	if m.name != nil {
		fields = append(fields, subject.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subject.FieldDescription)
	}
	if m.builtin != nil {
		fields = append(fields, subject.FieldBuiltin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCreateTime:
		return m.CreateTime()
	case subject.FieldUpdateTime:
		return m.UpdateTime()
	case subject.FieldKind:
		return m.Kind()
	case subject.FieldDomain:
		return m.Domain()
	case subject.FieldName:
		return m.Name()
	case subject.FieldDescription:
		return m.Description()
	case subject.FieldBuiltin:
		return m.Builtin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subject.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case subject.FieldKind:
		return m.OldKind(ctx)
	case subject.FieldDomain:
		return m.OldDomain(ctx)
	case subject.FieldName:
		return m.OldName(ctx)
	case subject.FieldDescription:
		return m.OldDescription(ctx)
	case subject.FieldBuiltin:
		return m.OldBuiltin(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subject.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case subject.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case subject.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case subject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subject.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subject.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subject.FieldDescription) {
		fields = append(fields, subject.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	switch name {
	case subject.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subject.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case subject.FieldKind:
		m.ResetKind()
		return nil
	case subject.FieldDomain:
		m.ResetDomain()
		return nil
	case subject.FieldName:
		m.ResetName()
		return nil
	case subject.FieldDescription:
		m.ResetDescription()
		return nil
	case subject.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tokens != nil {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.roles != nil {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtokens != nil {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.removedroles != nil {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtokens {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.clearedroles {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case subject.EdgeTokens:
		return m.clearedtokens
	case subject.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeTokens:
		m.ResetTokens()
		return nil
	case subject.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// SubjectRoleRelationshipMutation represents an operation that mutates the SubjectRoleRelationship nodes in the graph.
type SubjectRoleRelationshipMutation struct {
	config
	op             Op
	typ            string
	id             *oid.ID
	createTime     *time.Time
	clearedFields  map[string]struct{}
	project        *oid.ID
	clearedproject bool
	subject        *oid.ID
	clearedsubject bool
	role           *string
	clearedrole    bool
	done           bool
	oldValue       func(context.Context) (*SubjectRoleRelationship, error)
	predicates     []predicate.SubjectRoleRelationship
}

var _ ent.Mutation = (*SubjectRoleRelationshipMutation)(nil)

// subjectRoleRelationshipOption allows management of the mutation configuration using functional options.
type subjectRoleRelationshipOption func(*SubjectRoleRelationshipMutation)

// newSubjectRoleRelationshipMutation creates new mutation for the SubjectRoleRelationship entity.
func newSubjectRoleRelationshipMutation(c config, op Op, opts ...subjectRoleRelationshipOption) *SubjectRoleRelationshipMutation {
	m := &SubjectRoleRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeSubjectRoleRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectRoleRelationshipID sets the ID field of the mutation.
func withSubjectRoleRelationshipID(id oid.ID) subjectRoleRelationshipOption {
	return func(m *SubjectRoleRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *SubjectRoleRelationship
		)
		m.oldValue = func(ctx context.Context) (*SubjectRoleRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubjectRoleRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubjectRoleRelationship sets the old SubjectRoleRelationship of the mutation.
func withSubjectRoleRelationship(node *SubjectRoleRelationship) subjectRoleRelationshipOption {
	return func(m *SubjectRoleRelationshipMutation) {
		m.oldValue = func(context.Context) (*SubjectRoleRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectRoleRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectRoleRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubjectRoleRelationship entities.
func (m *SubjectRoleRelationshipMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectRoleRelationshipMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectRoleRelationshipMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubjectRoleRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *SubjectRoleRelationshipMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *SubjectRoleRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *SubjectRoleRelationshipMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetProjectID sets the "projectID" field.
func (m *SubjectRoleRelationshipMutation) SetProjectID(o oid.ID) {
	m.project = &o
}

// ProjectID returns the value of the "projectID" field in the mutation.
func (m *SubjectRoleRelationshipMutation) ProjectID() (r oid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "projectID" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldProjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "projectID" field.
func (m *SubjectRoleRelationshipMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[subjectrolerelationship.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "projectID" field was cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[subjectrolerelationship.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "projectID" field.
func (m *SubjectRoleRelationshipMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, subjectrolerelationship.FieldProjectID)
}

// SetSubjectID sets the "subject_id" field.
func (m *SubjectRoleRelationshipMutation) SetSubjectID(o oid.ID) {
	m.subject = &o
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *SubjectRoleRelationshipMutation) SubjectID() (r oid.ID, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldSubjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *SubjectRoleRelationshipMutation) ResetSubjectID() {
	m.subject = nil
}

// SetRoleID sets the "role_id" field.
func (m *SubjectRoleRelationshipMutation) SetRoleID(s string) {
	m.role = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *SubjectRoleRelationshipMutation) RoleID() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *SubjectRoleRelationshipMutation) ResetRoleID() {
	m.role = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *SubjectRoleRelationshipMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *SubjectRoleRelationshipMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) ProjectIDs() (ids []oid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *SubjectRoleRelationshipMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *SubjectRoleRelationshipMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *SubjectRoleRelationshipMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) SubjectIDs() (ids []oid.ID) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *SubjectRoleRelationshipMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *SubjectRoleRelationshipMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *SubjectRoleRelationshipMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *SubjectRoleRelationshipMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the SubjectRoleRelationshipMutation builder.
func (m *SubjectRoleRelationshipMutation) Where(ps ...predicate.SubjectRoleRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubjectRoleRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubjectRoleRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubjectRoleRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubjectRoleRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubjectRoleRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubjectRoleRelationship).
func (m *SubjectRoleRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectRoleRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.createTime != nil {
		fields = append(fields, subjectrolerelationship.FieldCreateTime)
	}
	if m.project != nil {
		fields = append(fields, subjectrolerelationship.FieldProjectID)
	}
	if m.subject != nil {
		fields = append(fields, subjectrolerelationship.FieldSubjectID)
	}
	if m.role != nil {
		fields = append(fields, subjectrolerelationship.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectRoleRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		return m.CreateTime()
	case subjectrolerelationship.FieldProjectID:
		return m.ProjectID()
	case subjectrolerelationship.FieldSubjectID:
		return m.SubjectID()
	case subjectrolerelationship.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectRoleRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subjectrolerelationship.FieldProjectID:
		return m.OldProjectID(ctx)
	case subjectrolerelationship.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case subjectrolerelationship.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectRoleRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subjectrolerelationship.FieldProjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case subjectrolerelationship.FieldSubjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case subjectrolerelationship.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectRoleRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectRoleRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectRoleRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubjectRoleRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectRoleRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subjectrolerelationship.FieldProjectID) {
		fields = append(fields, subjectrolerelationship.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ClearField(name string) error {
	switch name {
	case subjectrolerelationship.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ResetField(name string) error {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subjectrolerelationship.FieldProjectID:
		m.ResetProjectID()
		return nil
	case subjectrolerelationship.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case subjectrolerelationship.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectRoleRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, subjectrolerelationship.EdgeProject)
	}
	if m.subject != nil {
		edges = append(edges, subjectrolerelationship.EdgeSubject)
	}
	if m.role != nil {
		edges = append(edges, subjectrolerelationship.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectRoleRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subjectrolerelationship.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case subjectrolerelationship.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	case subjectrolerelationship.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectRoleRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectRoleRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, subjectrolerelationship.EdgeProject)
	}
	if m.clearedsubject {
		edges = append(edges, subjectrolerelationship.EdgeSubject)
	}
	if m.clearedrole {
		edges = append(edges, subjectrolerelationship.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case subjectrolerelationship.EdgeProject:
		return m.clearedproject
	case subjectrolerelationship.EdgeSubject:
		return m.clearedsubject
	case subjectrolerelationship.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case subjectrolerelationship.EdgeProject:
		m.ClearProject()
		return nil
	case subjectrolerelationship.EdgeSubject:
		m.ClearSubject()
		return nil
	case subjectrolerelationship.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case subjectrolerelationship.EdgeProject:
		m.ResetProject()
		return nil
	case subjectrolerelationship.EdgeSubject:
		m.ResetSubject()
		return nil
	case subjectrolerelationship.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op              Op
	typ             string
	id              *string
	createTime      *time.Time
	updateTime      *time.Time
	status          *string
	statusMessage   *string
	description     *string
	icon            *string
	labels          *map[string]string
	source          *string
	clearedFields   map[string]struct{}
	versions        map[oid.ID]struct{}
	removedversions map[oid.ID]struct{}
	clearedversions bool
	done            bool
	oldValue        func(context.Context) (*Template, error)
	predicates      []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id string) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Template entities.
func (m *TemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *TemplateMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *TemplateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *TemplateMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *TemplateMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *TemplateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *TemplateMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetStatus sets the "status" field.
func (m *TemplateMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TemplateMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TemplateMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[template.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TemplateMutation) StatusCleared() bool {
	_, ok := m.clearedFields[template.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TemplateMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, template.FieldStatus)
}

// SetStatusMessage sets the "statusMessage" field.
func (m *TemplateMutation) SetStatusMessage(s string) {
	m.statusMessage = &s
}

// StatusMessage returns the value of the "statusMessage" field in the mutation.
func (m *TemplateMutation) StatusMessage() (r string, exists bool) {
	v := m.statusMessage
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusMessage returns the old "statusMessage" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldStatusMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusMessage: %w", err)
	}
	return oldValue.StatusMessage, nil
}

// ClearStatusMessage clears the value of the "statusMessage" field.
func (m *TemplateMutation) ClearStatusMessage() {
	m.statusMessage = nil
	m.clearedFields[template.FieldStatusMessage] = struct{}{}
}

// StatusMessageCleared returns if the "statusMessage" field was cleared in this mutation.
func (m *TemplateMutation) StatusMessageCleared() bool {
	_, ok := m.clearedFields[template.FieldStatusMessage]
	return ok
}

// ResetStatusMessage resets all changes to the "statusMessage" field.
func (m *TemplateMutation) ResetStatusMessage() {
	m.statusMessage = nil
	delete(m.clearedFields, template.FieldStatusMessage)
}

// SetDescription sets the "description" field.
func (m *TemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[template.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[template.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, template.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *TemplateMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *TemplateMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *TemplateMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[template.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *TemplateMutation) IconCleared() bool {
	_, ok := m.clearedFields[template.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *TemplateMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, template.FieldIcon)
}

// SetLabels sets the "labels" field.
func (m *TemplateMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *TemplateMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ResetLabels resets all changes to the "labels" field.
func (m *TemplateMutation) ResetLabels() {
	m.labels = nil
}

// SetSource sets the "source" field.
func (m *TemplateMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TemplateMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TemplateMutation) ResetSource() {
	m.source = nil
}

// AddVersionIDs adds the "versions" edge to the TemplateVersion entity by ids.
func (m *TemplateMutation) AddVersionIDs(ids ...oid.ID) {
	if m.versions == nil {
		m.versions = make(map[oid.ID]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the TemplateVersion entity.
func (m *TemplateMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the TemplateVersion entity was cleared.
func (m *TemplateMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the TemplateVersion entity by IDs.
func (m *TemplateMutation) RemoveVersionIDs(ids ...oid.ID) {
	if m.removedversions == nil {
		m.removedversions = make(map[oid.ID]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the TemplateVersion entity.
func (m *TemplateMutation) RemovedVersionsIDs() (ids []oid.ID) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *TemplateMutation) VersionsIDs() (ids []oid.ID) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *TemplateMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.createTime != nil {
		fields = append(fields, template.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, template.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, template.FieldStatus)
	}
	if m.statusMessage != nil {
		fields = append(fields, template.FieldStatusMessage)
	}
	if m.description != nil {
		fields = append(fields, template.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, template.FieldIcon)
	}
	if m.labels != nil {
		fields = append(fields, template.FieldLabels)
	}
	if m.source != nil {
		fields = append(fields, template.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldCreateTime:
		return m.CreateTime()
	case template.FieldUpdateTime:
		return m.UpdateTime()
	case template.FieldStatus:
		return m.Status()
	case template.FieldStatusMessage:
		return m.StatusMessage()
	case template.FieldDescription:
		return m.Description()
	case template.FieldIcon:
		return m.Icon()
	case template.FieldLabels:
		return m.Labels()
	case template.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case template.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case template.FieldStatus:
		return m.OldStatus(ctx)
	case template.FieldStatusMessage:
		return m.OldStatusMessage(ctx)
	case template.FieldDescription:
		return m.OldDescription(ctx)
	case template.FieldIcon:
		return m.OldIcon(ctx)
	case template.FieldLabels:
		return m.OldLabels(ctx)
	case template.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case template.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case template.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case template.FieldStatusMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusMessage(v)
		return nil
	case template.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case template.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case template.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case template.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldStatus) {
		fields = append(fields, template.FieldStatus)
	}
	if m.FieldCleared(template.FieldStatusMessage) {
		fields = append(fields, template.FieldStatusMessage)
	}
	if m.FieldCleared(template.FieldDescription) {
		fields = append(fields, template.FieldDescription)
	}
	if m.FieldCleared(template.FieldIcon) {
		fields = append(fields, template.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldStatus:
		m.ClearStatus()
		return nil
	case template.FieldStatusMessage:
		m.ClearStatusMessage()
		return nil
	case template.FieldDescription:
		m.ClearDescription()
		return nil
	case template.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case template.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case template.FieldStatus:
		m.ResetStatus()
		return nil
	case template.FieldStatusMessage:
		m.ResetStatusMessage()
		return nil
	case template.FieldDescription:
		m.ResetDescription()
		return nil
	case template.FieldIcon:
		m.ResetIcon()
		return nil
	case template.FieldLabels:
		m.ResetLabels()
		return nil
	case template.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.versions != nil {
		edges = append(edges, template.EdgeVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedversions != nil {
		edges = append(edges, template.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedversions {
		edges = append(edges, template.EdgeVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case template.EdgeVersions:
		return m.clearedversions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	switch name {
	case template.EdgeVersions:
		m.ResetVersions()
		return nil
	}
	return fmt.Errorf("unknown Template edge %s", name)
}

// TemplateVersionMutation represents an operation that mutates the TemplateVersion nodes in the graph.
type TemplateVersionMutation struct {
	config
	op              Op
	typ             string
	id              *oid.ID
	createTime      *time.Time
	updateTime      *time.Time
	version         *string
	source          *string
	schema          **types.TemplateSchema
	clearedFields   map[string]struct{}
	template        *string
	clearedtemplate bool
	done            bool
	oldValue        func(context.Context) (*TemplateVersion, error)
	predicates      []predicate.TemplateVersion
}

var _ ent.Mutation = (*TemplateVersionMutation)(nil)

// templateVersionOption allows management of the mutation configuration using functional options.
type templateVersionOption func(*TemplateVersionMutation)

// newTemplateVersionMutation creates new mutation for the TemplateVersion entity.
func newTemplateVersionMutation(c config, op Op, opts ...templateVersionOption) *TemplateVersionMutation {
	m := &TemplateVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplateVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateVersionID sets the ID field of the mutation.
func withTemplateVersionID(id oid.ID) templateVersionOption {
	return func(m *TemplateVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *TemplateVersion
		)
		m.oldValue = func(ctx context.Context) (*TemplateVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemplateVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplateVersion sets the old TemplateVersion of the mutation.
func withTemplateVersion(node *TemplateVersion) templateVersionOption {
	return func(m *TemplateVersionMutation) {
		m.oldValue = func(context.Context) (*TemplateVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemplateVersion entities.
func (m *TemplateVersionMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateVersionMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateVersionMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemplateVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *TemplateVersionMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *TemplateVersionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *TemplateVersionMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *TemplateVersionMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *TemplateVersionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *TemplateVersionMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetTemplateID sets the "templateID" field.
func (m *TemplateVersionMutation) SetTemplateID(s string) {
	m.template = &s
}

// TemplateID returns the value of the "templateID" field in the mutation.
func (m *TemplateVersionMutation) TemplateID() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "templateID" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "templateID" field.
func (m *TemplateVersionMutation) ResetTemplateID() {
	m.template = nil
}

// SetVersion sets the "version" field.
func (m *TemplateVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *TemplateVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *TemplateVersionMutation) ResetVersion() {
	m.version = nil
}

// SetSource sets the "source" field.
func (m *TemplateVersionMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TemplateVersionMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TemplateVersionMutation) ResetSource() {
	m.source = nil
}

// SetSchema sets the "schema" field.
func (m *TemplateVersionMutation) SetSchema(ts *types.TemplateSchema) {
	m.schema = &ts
}

// Schema returns the value of the "schema" field in the mutation.
func (m *TemplateVersionMutation) Schema() (r *types.TemplateSchema, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchema returns the old "schema" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldSchema(ctx context.Context) (v *types.TemplateSchema, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchema: %w", err)
	}
	return oldValue.Schema, nil
}

// ResetSchema resets all changes to the "schema" field.
func (m *TemplateVersionMutation) ResetSchema() {
	m.schema = nil
}

// ClearTemplate clears the "template" edge to the Template entity.
func (m *TemplateVersionMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared reports if the "template" edge to the Template entity was cleared.
func (m *TemplateVersionMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *TemplateVersionMutation) TemplateIDs() (ids []string) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *TemplateVersionMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// Where appends a list predicates to the TemplateVersionMutation builder.
func (m *TemplateVersionMutation) Where(ps ...predicate.TemplateVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemplateVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemplateVersion).
func (m *TemplateVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateVersionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.createTime != nil {
		fields = append(fields, templateversion.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, templateversion.FieldUpdateTime)
	}
	if m.template != nil {
		fields = append(fields, templateversion.FieldTemplateID)
	}
	if m.version != nil {
		fields = append(fields, templateversion.FieldVersion)
	}
	if m.source != nil {
		fields = append(fields, templateversion.FieldSource)
	}
	if m.schema != nil {
		fields = append(fields, templateversion.FieldSchema)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case templateversion.FieldCreateTime:
		return m.CreateTime()
	case templateversion.FieldUpdateTime:
		return m.UpdateTime()
	case templateversion.FieldTemplateID:
		return m.TemplateID()
	case templateversion.FieldVersion:
		return m.Version()
	case templateversion.FieldSource:
		return m.Source()
	case templateversion.FieldSchema:
		return m.Schema()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case templateversion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case templateversion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case templateversion.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case templateversion.FieldVersion:
		return m.OldVersion(ctx)
	case templateversion.FieldSource:
		return m.OldSource(ctx)
	case templateversion.FieldSchema:
		return m.OldSchema(ctx)
	}
	return nil, fmt.Errorf("unknown TemplateVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case templateversion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case templateversion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case templateversion.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case templateversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case templateversion.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case templateversion.FieldSchema:
		v, ok := value.(*types.TemplateSchema)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchema(v)
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TemplateVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TemplateVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateVersionMutation) ResetField(name string) error {
	switch name {
	case templateversion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case templateversion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case templateversion.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case templateversion.FieldVersion:
		m.ResetVersion()
		return nil
	case templateversion.FieldSource:
		m.ResetSource()
		return nil
	case templateversion.FieldSchema:
		m.ResetSchema()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.template != nil {
		edges = append(edges, templateversion.EdgeTemplate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case templateversion.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtemplate {
		edges = append(edges, templateversion.EdgeTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case templateversion.EdgeTemplate:
		return m.clearedtemplate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateVersionMutation) ClearEdge(name string) error {
	switch name {
	case templateversion.EdgeTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateVersionMutation) ResetEdge(name string) error {
	switch name {
	case templateversion.EdgeTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op             Op
	typ            string
	id             *oid.ID
	createTime     *time.Time
	kind           *string
	name           *string
	expiration     *time.Time
	value          *crypto.String
	clearedFields  map[string]struct{}
	subject        *oid.ID
	clearedsubject bool
	done           bool
	oldValue       func(context.Context) (*Token, error)
	predicates     []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id oid.ID) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id oid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id oid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]oid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []oid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "createTime" field.
func (m *TokenMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *TokenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *TokenMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetSubjectID sets the "subjectID" field.
func (m *TokenMutation) SetSubjectID(o oid.ID) {
	m.subject = &o
}

// SubjectID returns the value of the "subjectID" field in the mutation.
func (m *TokenMutation) SubjectID() (r oid.ID, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subjectID" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSubjectID(ctx context.Context) (v oid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subjectID" field.
func (m *TokenMutation) ResetSubjectID() {
	m.subject = nil
}

// SetKind sets the "kind" field.
func (m *TokenMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *TokenMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *TokenMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *TokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TokenMutation) ResetName() {
	m.name = nil
}

// SetExpiration sets the "expiration" field.
func (m *TokenMutation) SetExpiration(t time.Time) {
	m.expiration = &t
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *TokenMutation) Expiration() (r time.Time, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiration(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ClearExpiration clears the value of the "expiration" field.
func (m *TokenMutation) ClearExpiration() {
	m.expiration = nil
	m.clearedFields[token.FieldExpiration] = struct{}{}
}

// ExpirationCleared returns if the "expiration" field was cleared in this mutation.
func (m *TokenMutation) ExpirationCleared() bool {
	_, ok := m.clearedFields[token.FieldExpiration]
	return ok
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *TokenMutation) ResetExpiration() {
	m.expiration = nil
	delete(m.clearedFields, token.FieldExpiration)
}

// SetValue sets the "value" field.
func (m *TokenMutation) SetValue(c crypto.String) {
	m.value = &c
}

// Value returns the value of the "value" field in the mutation.
func (m *TokenMutation) Value() (r crypto.String, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldValue(ctx context.Context) (v crypto.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *TokenMutation) ResetValue() {
	m.value = nil
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *TokenMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *TokenMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) SubjectIDs() (ids []oid.ID) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *TokenMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.createTime != nil {
		fields = append(fields, token.FieldCreateTime)
	}
	if m.subject != nil {
		fields = append(fields, token.FieldSubjectID)
	}
	if m.kind != nil {
		fields = append(fields, token.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, token.FieldName)
	}
	if m.expiration != nil {
		fields = append(fields, token.FieldExpiration)
	}
	if m.value != nil {
		fields = append(fields, token.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreateTime:
		return m.CreateTime()
	case token.FieldSubjectID:
		return m.SubjectID()
	case token.FieldKind:
		return m.Kind()
	case token.FieldName:
		return m.Name()
	case token.FieldExpiration:
		return m.Expiration()
	case token.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case token.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case token.FieldKind:
		return m.OldKind(ctx)
	case token.FieldName:
		return m.OldName(ctx)
	case token.FieldExpiration:
		return m.OldExpiration(ctx)
	case token.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case token.FieldSubjectID:
		v, ok := value.(oid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case token.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case token.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case token.FieldExpiration:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case token.FieldValue:
		v, ok := value.(crypto.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldExpiration) {
		fields = append(fields, token.FieldExpiration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldExpiration:
		m.ClearExpiration()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case token.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case token.FieldKind:
		m.ResetKind()
		return nil
	case token.FieldName:
		m.ResetName()
		return nil
	case token.FieldExpiration:
		m.ResetExpiration()
		return nil
	case token.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subject != nil {
		edges = append(edges, token.EdgeSubject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubject {
		edges = append(edges, token.EdgeSubject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeSubject:
		return m.clearedsubject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}
