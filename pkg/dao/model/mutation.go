// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"

	"github.com/seal-io/walrus/pkg/dao/model/catalog"
	"github.com/seal-io/walrus/pkg/dao/model/connector"
	"github.com/seal-io/walrus/pkg/dao/model/costreport"
	"github.com/seal-io/walrus/pkg/dao/model/distributelock"
	"github.com/seal-io/walrus/pkg/dao/model/environment"
	"github.com/seal-io/walrus/pkg/dao/model/environmentconnectorrelationship"
	"github.com/seal-io/walrus/pkg/dao/model/perspective"
	"github.com/seal-io/walrus/pkg/dao/model/predicate"
	"github.com/seal-io/walrus/pkg/dao/model/project"
	"github.com/seal-io/walrus/pkg/dao/model/resource"
	"github.com/seal-io/walrus/pkg/dao/model/resourcecomponent"
	"github.com/seal-io/walrus/pkg/dao/model/resourcecomponentrelationship"
	"github.com/seal-io/walrus/pkg/dao/model/resourcedefinition"
	"github.com/seal-io/walrus/pkg/dao/model/resourcedefinitionmatchingrule"
	"github.com/seal-io/walrus/pkg/dao/model/resourcerelationship"
	"github.com/seal-io/walrus/pkg/dao/model/resourcerevision"
	"github.com/seal-io/walrus/pkg/dao/model/role"
	"github.com/seal-io/walrus/pkg/dao/model/setting"
	"github.com/seal-io/walrus/pkg/dao/model/subject"
	"github.com/seal-io/walrus/pkg/dao/model/subjectrolerelationship"
	"github.com/seal-io/walrus/pkg/dao/model/template"
	"github.com/seal-io/walrus/pkg/dao/model/templateversion"
	"github.com/seal-io/walrus/pkg/dao/model/token"
	"github.com/seal-io/walrus/pkg/dao/model/variable"
	"github.com/seal-io/walrus/pkg/dao/model/workflow"
	"github.com/seal-io/walrus/pkg/dao/model/workflowexecution"
	"github.com/seal-io/walrus/pkg/dao/model/workflowstage"
	"github.com/seal-io/walrus/pkg/dao/model/workflowstageexecution"
	"github.com/seal-io/walrus/pkg/dao/model/workflowstep"
	"github.com/seal-io/walrus/pkg/dao/model/workflowstepexecution"
	"github.com/seal-io/walrus/pkg/dao/types"
	"github.com/seal-io/walrus/pkg/dao/types/crypto"
	"github.com/seal-io/walrus/pkg/dao/types/object"
	"github.com/seal-io/walrus/pkg/dao/types/property"
	"github.com/seal-io/walrus/pkg/dao/types/status"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCatalog                          = "Catalog"
	TypeConnector                        = "Connector"
	TypeCostReport                       = "CostReport"
	TypeDistributeLock                   = "DistributeLock"
	TypeEnvironment                      = "Environment"
	TypeEnvironmentConnectorRelationship = "EnvironmentConnectorRelationship"
	TypePerspective                      = "Perspective"
	TypeProject                          = "Project"
	TypeResource                         = "Resource"
	TypeResourceComponent                = "ResourceComponent"
	TypeResourceComponentRelationship    = "ResourceComponentRelationship"
	TypeResourceDefinition               = "ResourceDefinition"
	TypeResourceDefinitionMatchingRule   = "ResourceDefinitionMatchingRule"
	TypeResourceRelationship             = "ResourceRelationship"
	TypeResourceRevision                 = "ResourceRevision"
	TypeRole                             = "Role"
	TypeSetting                          = "Setting"
	TypeSubject                          = "Subject"
	TypeSubjectRoleRelationship          = "SubjectRoleRelationship"
	TypeTemplate                         = "Template"
	TypeTemplateVersion                  = "TemplateVersion"
	TypeToken                            = "Token"
	TypeVariable                         = "Variable"
	TypeWorkflow                         = "Workflow"
	TypeWorkflowExecution                = "WorkflowExecution"
	TypeWorkflowStage                    = "WorkflowStage"
	TypeWorkflowStageExecution           = "WorkflowStageExecution"
	TypeWorkflowStep                     = "WorkflowStep"
	TypeWorkflowStepExecution            = "WorkflowStepExecution"
)

// CatalogMutation represents an operation that mutates the Catalog nodes in the graph.
type CatalogMutation struct {
	config
	op               Op
	typ              string
	id               *object.ID
	name             *string
	description      *string
	labels           *map[string]string
	annotations      *map[string]string
	create_time      *time.Time
	update_time      *time.Time
	status           *status.Status
	_type            *string
	source           *string
	sync             **types.CatalogSync
	clearedFields    map[string]struct{}
	templates        map[object.ID]struct{}
	removedtemplates map[object.ID]struct{}
	clearedtemplates bool
	project          *object.ID
	clearedproject   bool
	done             bool
	oldValue         func(context.Context) (*Catalog, error)
	predicates       []predicate.Catalog
}

var _ ent.Mutation = (*CatalogMutation)(nil)

// catalogOption allows management of the mutation configuration using functional options.
type catalogOption func(*CatalogMutation)

// newCatalogMutation creates new mutation for the Catalog entity.
func newCatalogMutation(c config, op Op, opts ...catalogOption) *CatalogMutation {
	m := &CatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCatalogID sets the ID field of the mutation.
func withCatalogID(id object.ID) catalogOption {
	return func(m *CatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *Catalog
		)
		m.oldValue = func(ctx context.Context) (*Catalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Catalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCatalog sets the old Catalog of the mutation.
func withCatalog(node *Catalog) catalogOption {
	return func(m *CatalogMutation) {
		m.oldValue = func(context.Context) (*Catalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Catalog entities.
func (m *CatalogMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CatalogMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CatalogMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Catalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CatalogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CatalogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CatalogMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CatalogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CatalogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CatalogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[catalog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CatalogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[catalog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CatalogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, catalog.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *CatalogMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *CatalogMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *CatalogMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[catalog.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *CatalogMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[catalog.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *CatalogMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, catalog.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *CatalogMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *CatalogMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *CatalogMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[catalog.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *CatalogMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[catalog.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *CatalogMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, catalog.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *CatalogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CatalogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CatalogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CatalogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CatalogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CatalogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *CatalogMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CatalogMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *CatalogMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[catalog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *CatalogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[catalog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *CatalogMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, catalog.FieldStatus)
}

// SetType sets the "type" field.
func (m *CatalogMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CatalogMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CatalogMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *CatalogMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *CatalogMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *CatalogMutation) ResetSource() {
	m.source = nil
}

// SetSync sets the "sync" field.
func (m *CatalogMutation) SetSync(ts *types.CatalogSync) {
	m.sync = &ts
}

// Sync returns the value of the "sync" field in the mutation.
func (m *CatalogMutation) Sync() (r *types.CatalogSync, exists bool) {
	v := m.sync
	if v == nil {
		return
	}
	return *v, true
}

// OldSync returns the old "sync" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldSync(ctx context.Context) (v *types.CatalogSync, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSync: %w", err)
	}
	return oldValue.Sync, nil
}

// ClearSync clears the value of the "sync" field.
func (m *CatalogMutation) ClearSync() {
	m.sync = nil
	m.clearedFields[catalog.FieldSync] = struct{}{}
}

// SyncCleared returns if the "sync" field was cleared in this mutation.
func (m *CatalogMutation) SyncCleared() bool {
	_, ok := m.clearedFields[catalog.FieldSync]
	return ok
}

// ResetSync resets all changes to the "sync" field.
func (m *CatalogMutation) ResetSync() {
	m.sync = nil
	delete(m.clearedFields, catalog.FieldSync)
}

// SetProjectID sets the "project_id" field.
func (m *CatalogMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *CatalogMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *CatalogMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[catalog.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *CatalogMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[catalog.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *CatalogMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, catalog.FieldProjectID)
}

// AddTemplateIDs adds the "templates" edge to the Template entity by ids.
func (m *CatalogMutation) AddTemplateIDs(ids ...object.ID) {
	if m.templates == nil {
		m.templates = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the "templates" edge to the Template entity.
func (m *CatalogMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared reports if the "templates" edge to the Template entity was cleared.
func (m *CatalogMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the "templates" edge to the Template entity by IDs.
func (m *CatalogMutation) RemoveTemplateIDs(ids ...object.ID) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.templates, ids[i])
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed IDs of the "templates" edge to the Template entity.
func (m *CatalogMutation) RemovedTemplatesIDs() (ids []object.ID) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the "templates" edge IDs in the mutation.
func (m *CatalogMutation) TemplatesIDs() (ids []object.ID) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates resets all changes to the "templates" edge.
func (m *CatalogMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *CatalogMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *CatalogMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *CatalogMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *CatalogMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the CatalogMutation builder.
func (m *CatalogMutation) Where(ps ...predicate.Catalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Catalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Catalog).
func (m *CatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CatalogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, catalog.FieldName)
	}
	if m.description != nil {
		fields = append(fields, catalog.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, catalog.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, catalog.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, catalog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, catalog.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, catalog.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, catalog.FieldType)
	}
	if m.source != nil {
		fields = append(fields, catalog.FieldSource)
	}
	if m.sync != nil {
		fields = append(fields, catalog.FieldSync)
	}
	if m.project != nil {
		fields = append(fields, catalog.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case catalog.FieldName:
		return m.Name()
	case catalog.FieldDescription:
		return m.Description()
	case catalog.FieldLabels:
		return m.Labels()
	case catalog.FieldAnnotations:
		return m.Annotations()
	case catalog.FieldCreateTime:
		return m.CreateTime()
	case catalog.FieldUpdateTime:
		return m.UpdateTime()
	case catalog.FieldStatus:
		return m.Status()
	case catalog.FieldType:
		return m.GetType()
	case catalog.FieldSource:
		return m.Source()
	case catalog.FieldSync:
		return m.Sync()
	case catalog.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case catalog.FieldName:
		return m.OldName(ctx)
	case catalog.FieldDescription:
		return m.OldDescription(ctx)
	case catalog.FieldLabels:
		return m.OldLabels(ctx)
	case catalog.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case catalog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case catalog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case catalog.FieldStatus:
		return m.OldStatus(ctx)
	case catalog.FieldType:
		return m.OldType(ctx)
	case catalog.FieldSource:
		return m.OldSource(ctx)
	case catalog.FieldSync:
		return m.OldSync(ctx)
	case catalog.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown Catalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case catalog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case catalog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case catalog.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case catalog.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case catalog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case catalog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case catalog.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case catalog.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case catalog.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case catalog.FieldSync:
		v, ok := value.(*types.CatalogSync)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSync(v)
		return nil
	case catalog.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Catalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CatalogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CatalogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Catalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(catalog.FieldDescription) {
		fields = append(fields, catalog.FieldDescription)
	}
	if m.FieldCleared(catalog.FieldLabels) {
		fields = append(fields, catalog.FieldLabels)
	}
	if m.FieldCleared(catalog.FieldAnnotations) {
		fields = append(fields, catalog.FieldAnnotations)
	}
	if m.FieldCleared(catalog.FieldStatus) {
		fields = append(fields, catalog.FieldStatus)
	}
	if m.FieldCleared(catalog.FieldSync) {
		fields = append(fields, catalog.FieldSync)
	}
	if m.FieldCleared(catalog.FieldProjectID) {
		fields = append(fields, catalog.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CatalogMutation) ClearField(name string) error {
	switch name {
	case catalog.FieldDescription:
		m.ClearDescription()
		return nil
	case catalog.FieldLabels:
		m.ClearLabels()
		return nil
	case catalog.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case catalog.FieldStatus:
		m.ClearStatus()
		return nil
	case catalog.FieldSync:
		m.ClearSync()
		return nil
	case catalog.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown Catalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CatalogMutation) ResetField(name string) error {
	switch name {
	case catalog.FieldName:
		m.ResetName()
		return nil
	case catalog.FieldDescription:
		m.ResetDescription()
		return nil
	case catalog.FieldLabels:
		m.ResetLabels()
		return nil
	case catalog.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case catalog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case catalog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case catalog.FieldStatus:
		m.ResetStatus()
		return nil
	case catalog.FieldType:
		m.ResetType()
		return nil
	case catalog.FieldSource:
		m.ResetSource()
		return nil
	case catalog.FieldSync:
		m.ResetSync()
		return nil
	case catalog.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown Catalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.templates != nil {
		edges = append(edges, catalog.EdgeTemplates)
	}
	if m.project != nil {
		edges = append(edges, catalog.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CatalogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case catalog.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	case catalog.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtemplates != nil {
		edges = append(edges, catalog.EdgeTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CatalogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case catalog.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtemplates {
		edges = append(edges, catalog.EdgeTemplates)
	}
	if m.clearedproject {
		edges = append(edges, catalog.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CatalogMutation) EdgeCleared(name string) bool {
	switch name {
	case catalog.EdgeTemplates:
		return m.clearedtemplates
	case catalog.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CatalogMutation) ClearEdge(name string) error {
	switch name {
	case catalog.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Catalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CatalogMutation) ResetEdge(name string) error {
	switch name {
	case catalog.EdgeTemplates:
		m.ResetTemplates()
		return nil
	case catalog.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Catalog edge %s", name)
}

// ConnectorMutation represents an operation that mutates the Connector nodes in the graph.
type ConnectorMutation struct {
	config
	op                          Op
	typ                         string
	id                          *object.ID
	name                        *string
	description                 *string
	labels                      *map[string]string
	annotations                 *map[string]string
	create_time                 *time.Time
	update_time                 *time.Time
	status                      *status.Status
	category                    *string
	_type                       *string
	applicable_environment_type *string
	config_version              *string
	config_data                 *crypto.Properties
	enable_fin_ops              *bool
	fin_ops_custom_pricing      **types.FinOpsCustomPricing
	clearedFields               map[string]struct{}
	project                     *object.ID
	clearedproject              bool
	environments                map[object.ID]struct{}
	removedenvironments         map[object.ID]struct{}
	clearedenvironments         bool
	resource_components         map[object.ID]struct{}
	removedresource_components  map[object.ID]struct{}
	clearedresource_components  bool
	cost_reports                map[int]struct{}
	removedcost_reports         map[int]struct{}
	clearedcost_reports         bool
	done                        bool
	oldValue                    func(context.Context) (*Connector, error)
	predicates                  []predicate.Connector
}

var _ ent.Mutation = (*ConnectorMutation)(nil)

// connectorOption allows management of the mutation configuration using functional options.
type connectorOption func(*ConnectorMutation)

// newConnectorMutation creates new mutation for the Connector entity.
func newConnectorMutation(c config, op Op, opts ...connectorOption) *ConnectorMutation {
	m := &ConnectorMutation{
		config:        c,
		op:            op,
		typ:           TypeConnector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectorID sets the ID field of the mutation.
func withConnectorID(id object.ID) connectorOption {
	return func(m *ConnectorMutation) {
		var (
			err   error
			once  sync.Once
			value *Connector
		)
		m.oldValue = func(ctx context.Context) (*Connector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnector sets the old Connector of the mutation.
func withConnector(node *Connector) connectorOption {
	return func(m *ConnectorMutation) {
		m.oldValue = func(context.Context) (*Connector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connector entities.
func (m *ConnectorMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectorMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectorMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConnectorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectorMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ConnectorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConnectorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConnectorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[connector.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConnectorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[connector.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConnectorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, connector.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ConnectorMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ConnectorMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ConnectorMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[connector.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ConnectorMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[connector.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ConnectorMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, connector.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ConnectorMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ConnectorMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ConnectorMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[connector.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ConnectorMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[connector.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ConnectorMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, connector.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *ConnectorMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ConnectorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ConnectorMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ConnectorMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ConnectorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ConnectorMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *ConnectorMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConnectorMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ConnectorMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[connector.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ConnectorMutation) StatusCleared() bool {
	_, ok := m.clearedFields[connector.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ConnectorMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, connector.FieldStatus)
}

// SetProjectID sets the "project_id" field.
func (m *ConnectorMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ConnectorMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *ConnectorMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[connector.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *ConnectorMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[connector.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ConnectorMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, connector.FieldProjectID)
}

// SetCategory sets the "category" field.
func (m *ConnectorMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ConnectorMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ConnectorMutation) ResetCategory() {
	m.category = nil
}

// SetType sets the "type" field.
func (m *ConnectorMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConnectorMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ConnectorMutation) ResetType() {
	m._type = nil
}

// SetApplicableEnvironmentType sets the "applicable_environment_type" field.
func (m *ConnectorMutation) SetApplicableEnvironmentType(s string) {
	m.applicable_environment_type = &s
}

// ApplicableEnvironmentType returns the value of the "applicable_environment_type" field in the mutation.
func (m *ConnectorMutation) ApplicableEnvironmentType() (r string, exists bool) {
	v := m.applicable_environment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicableEnvironmentType returns the old "applicable_environment_type" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldApplicableEnvironmentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicableEnvironmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicableEnvironmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicableEnvironmentType: %w", err)
	}
	return oldValue.ApplicableEnvironmentType, nil
}

// ResetApplicableEnvironmentType resets all changes to the "applicable_environment_type" field.
func (m *ConnectorMutation) ResetApplicableEnvironmentType() {
	m.applicable_environment_type = nil
}

// SetConfigVersion sets the "config_version" field.
func (m *ConnectorMutation) SetConfigVersion(s string) {
	m.config_version = &s
}

// ConfigVersion returns the value of the "config_version" field in the mutation.
func (m *ConnectorMutation) ConfigVersion() (r string, exists bool) {
	v := m.config_version
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigVersion returns the old "config_version" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldConfigVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigVersion: %w", err)
	}
	return oldValue.ConfigVersion, nil
}

// ResetConfigVersion resets all changes to the "config_version" field.
func (m *ConnectorMutation) ResetConfigVersion() {
	m.config_version = nil
}

// SetConfigData sets the "config_data" field.
func (m *ConnectorMutation) SetConfigData(c crypto.Properties) {
	m.config_data = &c
}

// ConfigData returns the value of the "config_data" field in the mutation.
func (m *ConnectorMutation) ConfigData() (r crypto.Properties, exists bool) {
	v := m.config_data
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigData returns the old "config_data" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldConfigData(ctx context.Context) (v crypto.Properties, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigData: %w", err)
	}
	return oldValue.ConfigData, nil
}

// ClearConfigData clears the value of the "config_data" field.
func (m *ConnectorMutation) ClearConfigData() {
	m.config_data = nil
	m.clearedFields[connector.FieldConfigData] = struct{}{}
}

// ConfigDataCleared returns if the "config_data" field was cleared in this mutation.
func (m *ConnectorMutation) ConfigDataCleared() bool {
	_, ok := m.clearedFields[connector.FieldConfigData]
	return ok
}

// ResetConfigData resets all changes to the "config_data" field.
func (m *ConnectorMutation) ResetConfigData() {
	m.config_data = nil
	delete(m.clearedFields, connector.FieldConfigData)
}

// SetEnableFinOps sets the "enable_fin_ops" field.
func (m *ConnectorMutation) SetEnableFinOps(b bool) {
	m.enable_fin_ops = &b
}

// EnableFinOps returns the value of the "enable_fin_ops" field in the mutation.
func (m *ConnectorMutation) EnableFinOps() (r bool, exists bool) {
	v := m.enable_fin_ops
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableFinOps returns the old "enable_fin_ops" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldEnableFinOps(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableFinOps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableFinOps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableFinOps: %w", err)
	}
	return oldValue.EnableFinOps, nil
}

// ResetEnableFinOps resets all changes to the "enable_fin_ops" field.
func (m *ConnectorMutation) ResetEnableFinOps() {
	m.enable_fin_ops = nil
}

// SetFinOpsCustomPricing sets the "fin_ops_custom_pricing" field.
func (m *ConnectorMutation) SetFinOpsCustomPricing(tocp *types.FinOpsCustomPricing) {
	m.fin_ops_custom_pricing = &tocp
}

// FinOpsCustomPricing returns the value of the "fin_ops_custom_pricing" field in the mutation.
func (m *ConnectorMutation) FinOpsCustomPricing() (r *types.FinOpsCustomPricing, exists bool) {
	v := m.fin_ops_custom_pricing
	if v == nil {
		return
	}
	return *v, true
}

// OldFinOpsCustomPricing returns the old "fin_ops_custom_pricing" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldFinOpsCustomPricing(ctx context.Context) (v *types.FinOpsCustomPricing, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinOpsCustomPricing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinOpsCustomPricing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinOpsCustomPricing: %w", err)
	}
	return oldValue.FinOpsCustomPricing, nil
}

// ClearFinOpsCustomPricing clears the value of the "fin_ops_custom_pricing" field.
func (m *ConnectorMutation) ClearFinOpsCustomPricing() {
	m.fin_ops_custom_pricing = nil
	m.clearedFields[connector.FieldFinOpsCustomPricing] = struct{}{}
}

// FinOpsCustomPricingCleared returns if the "fin_ops_custom_pricing" field was cleared in this mutation.
func (m *ConnectorMutation) FinOpsCustomPricingCleared() bool {
	_, ok := m.clearedFields[connector.FieldFinOpsCustomPricing]
	return ok
}

// ResetFinOpsCustomPricing resets all changes to the "fin_ops_custom_pricing" field.
func (m *ConnectorMutation) ResetFinOpsCustomPricing() {
	m.fin_ops_custom_pricing = nil
	delete(m.clearedFields, connector.FieldFinOpsCustomPricing)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ConnectorMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ConnectorMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ConnectorMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ConnectorMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddEnvironmentIDs adds the "environments" edge to the EnvironmentConnectorRelationship entity by ids.
func (m *ConnectorMutation) AddEnvironmentIDs(ids ...object.ID) {
	if m.environments == nil {
		m.environments = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "environments" edge to the EnvironmentConnectorRelationship entity.
func (m *ConnectorMutation) ClearEnvironments() {
	m.clearedenvironments = true
}

// EnvironmentsCleared reports if the "environments" edge to the EnvironmentConnectorRelationship entity was cleared.
func (m *ConnectorMutation) EnvironmentsCleared() bool {
	return m.clearedenvironments
}

// RemoveEnvironmentIDs removes the "environments" edge to the EnvironmentConnectorRelationship entity by IDs.
func (m *ConnectorMutation) RemoveEnvironmentIDs(ids ...object.ID) {
	if m.removedenvironments == nil {
		m.removedenvironments = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.environments, ids[i])
		m.removedenvironments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "environments" edge to the EnvironmentConnectorRelationship entity.
func (m *ConnectorMutation) RemovedEnvironmentsIDs() (ids []object.ID) {
	for id := range m.removedenvironments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "environments" edge IDs in the mutation.
func (m *ConnectorMutation) EnvironmentsIDs() (ids []object.ID) {
	for id := range m.environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "environments" edge.
func (m *ConnectorMutation) ResetEnvironments() {
	m.environments = nil
	m.clearedenvironments = false
	m.removedenvironments = nil
}

// AddResourceComponentIDs adds the "resource_components" edge to the ResourceComponent entity by ids.
func (m *ConnectorMutation) AddResourceComponentIDs(ids ...object.ID) {
	if m.resource_components == nil {
		m.resource_components = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resource_components[ids[i]] = struct{}{}
	}
}

// ClearResourceComponents clears the "resource_components" edge to the ResourceComponent entity.
func (m *ConnectorMutation) ClearResourceComponents() {
	m.clearedresource_components = true
}

// ResourceComponentsCleared reports if the "resource_components" edge to the ResourceComponent entity was cleared.
func (m *ConnectorMutation) ResourceComponentsCleared() bool {
	return m.clearedresource_components
}

// RemoveResourceComponentIDs removes the "resource_components" edge to the ResourceComponent entity by IDs.
func (m *ConnectorMutation) RemoveResourceComponentIDs(ids ...object.ID) {
	if m.removedresource_components == nil {
		m.removedresource_components = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resource_components, ids[i])
		m.removedresource_components[ids[i]] = struct{}{}
	}
}

// RemovedResourceComponents returns the removed IDs of the "resource_components" edge to the ResourceComponent entity.
func (m *ConnectorMutation) RemovedResourceComponentsIDs() (ids []object.ID) {
	for id := range m.removedresource_components {
		ids = append(ids, id)
	}
	return
}

// ResourceComponentsIDs returns the "resource_components" edge IDs in the mutation.
func (m *ConnectorMutation) ResourceComponentsIDs() (ids []object.ID) {
	for id := range m.resource_components {
		ids = append(ids, id)
	}
	return
}

// ResetResourceComponents resets all changes to the "resource_components" edge.
func (m *ConnectorMutation) ResetResourceComponents() {
	m.resource_components = nil
	m.clearedresource_components = false
	m.removedresource_components = nil
}

// AddCostReportIDs adds the "cost_reports" edge to the CostReport entity by ids.
func (m *ConnectorMutation) AddCostReportIDs(ids ...int) {
	if m.cost_reports == nil {
		m.cost_reports = make(map[int]struct{})
	}
	for i := range ids {
		m.cost_reports[ids[i]] = struct{}{}
	}
}

// ClearCostReports clears the "cost_reports" edge to the CostReport entity.
func (m *ConnectorMutation) ClearCostReports() {
	m.clearedcost_reports = true
}

// CostReportsCleared reports if the "cost_reports" edge to the CostReport entity was cleared.
func (m *ConnectorMutation) CostReportsCleared() bool {
	return m.clearedcost_reports
}

// RemoveCostReportIDs removes the "cost_reports" edge to the CostReport entity by IDs.
func (m *ConnectorMutation) RemoveCostReportIDs(ids ...int) {
	if m.removedcost_reports == nil {
		m.removedcost_reports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cost_reports, ids[i])
		m.removedcost_reports[ids[i]] = struct{}{}
	}
}

// RemovedCostReports returns the removed IDs of the "cost_reports" edge to the CostReport entity.
func (m *ConnectorMutation) RemovedCostReportsIDs() (ids []int) {
	for id := range m.removedcost_reports {
		ids = append(ids, id)
	}
	return
}

// CostReportsIDs returns the "cost_reports" edge IDs in the mutation.
func (m *ConnectorMutation) CostReportsIDs() (ids []int) {
	for id := range m.cost_reports {
		ids = append(ids, id)
	}
	return
}

// ResetCostReports resets all changes to the "cost_reports" edge.
func (m *ConnectorMutation) ResetCostReports() {
	m.cost_reports = nil
	m.clearedcost_reports = false
	m.removedcost_reports = nil
}

// Where appends a list predicates to the ConnectorMutation builder.
func (m *ConnectorMutation) Where(ps ...predicate.Connector) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Connector, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Connector).
func (m *ConnectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectorMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.name != nil {
		fields = append(fields, connector.FieldName)
	}
	if m.description != nil {
		fields = append(fields, connector.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, connector.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, connector.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, connector.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, connector.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, connector.FieldStatus)
	}
	if m.project != nil {
		fields = append(fields, connector.FieldProjectID)
	}
	if m.category != nil {
		fields = append(fields, connector.FieldCategory)
	}
	if m._type != nil {
		fields = append(fields, connector.FieldType)
	}
	if m.applicable_environment_type != nil {
		fields = append(fields, connector.FieldApplicableEnvironmentType)
	}
	if m.config_version != nil {
		fields = append(fields, connector.FieldConfigVersion)
	}
	if m.config_data != nil {
		fields = append(fields, connector.FieldConfigData)
	}
	if m.enable_fin_ops != nil {
		fields = append(fields, connector.FieldEnableFinOps)
	}
	if m.fin_ops_custom_pricing != nil {
		fields = append(fields, connector.FieldFinOpsCustomPricing)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connector.FieldName:
		return m.Name()
	case connector.FieldDescription:
		return m.Description()
	case connector.FieldLabels:
		return m.Labels()
	case connector.FieldAnnotations:
		return m.Annotations()
	case connector.FieldCreateTime:
		return m.CreateTime()
	case connector.FieldUpdateTime:
		return m.UpdateTime()
	case connector.FieldStatus:
		return m.Status()
	case connector.FieldProjectID:
		return m.ProjectID()
	case connector.FieldCategory:
		return m.Category()
	case connector.FieldType:
		return m.GetType()
	case connector.FieldApplicableEnvironmentType:
		return m.ApplicableEnvironmentType()
	case connector.FieldConfigVersion:
		return m.ConfigVersion()
	case connector.FieldConfigData:
		return m.ConfigData()
	case connector.FieldEnableFinOps:
		return m.EnableFinOps()
	case connector.FieldFinOpsCustomPricing:
		return m.FinOpsCustomPricing()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connector.FieldName:
		return m.OldName(ctx)
	case connector.FieldDescription:
		return m.OldDescription(ctx)
	case connector.FieldLabels:
		return m.OldLabels(ctx)
	case connector.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case connector.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case connector.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case connector.FieldStatus:
		return m.OldStatus(ctx)
	case connector.FieldProjectID:
		return m.OldProjectID(ctx)
	case connector.FieldCategory:
		return m.OldCategory(ctx)
	case connector.FieldType:
		return m.OldType(ctx)
	case connector.FieldApplicableEnvironmentType:
		return m.OldApplicableEnvironmentType(ctx)
	case connector.FieldConfigVersion:
		return m.OldConfigVersion(ctx)
	case connector.FieldConfigData:
		return m.OldConfigData(ctx)
	case connector.FieldEnableFinOps:
		return m.OldEnableFinOps(ctx)
	case connector.FieldFinOpsCustomPricing:
		return m.OldFinOpsCustomPricing(ctx)
	}
	return nil, fmt.Errorf("unknown Connector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connector.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case connector.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case connector.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case connector.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case connector.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case connector.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case connector.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case connector.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case connector.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case connector.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case connector.FieldApplicableEnvironmentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicableEnvironmentType(v)
		return nil
	case connector.FieldConfigVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigVersion(v)
		return nil
	case connector.FieldConfigData:
		v, ok := value.(crypto.Properties)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigData(v)
		return nil
	case connector.FieldEnableFinOps:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableFinOps(v)
		return nil
	case connector.FieldFinOpsCustomPricing:
		v, ok := value.(*types.FinOpsCustomPricing)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinOpsCustomPricing(v)
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Connector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connector.FieldDescription) {
		fields = append(fields, connector.FieldDescription)
	}
	if m.FieldCleared(connector.FieldLabels) {
		fields = append(fields, connector.FieldLabels)
	}
	if m.FieldCleared(connector.FieldAnnotations) {
		fields = append(fields, connector.FieldAnnotations)
	}
	if m.FieldCleared(connector.FieldStatus) {
		fields = append(fields, connector.FieldStatus)
	}
	if m.FieldCleared(connector.FieldProjectID) {
		fields = append(fields, connector.FieldProjectID)
	}
	if m.FieldCleared(connector.FieldConfigData) {
		fields = append(fields, connector.FieldConfigData)
	}
	if m.FieldCleared(connector.FieldFinOpsCustomPricing) {
		fields = append(fields, connector.FieldFinOpsCustomPricing)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectorMutation) ClearField(name string) error {
	switch name {
	case connector.FieldDescription:
		m.ClearDescription()
		return nil
	case connector.FieldLabels:
		m.ClearLabels()
		return nil
	case connector.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case connector.FieldStatus:
		m.ClearStatus()
		return nil
	case connector.FieldProjectID:
		m.ClearProjectID()
		return nil
	case connector.FieldConfigData:
		m.ClearConfigData()
		return nil
	case connector.FieldFinOpsCustomPricing:
		m.ClearFinOpsCustomPricing()
		return nil
	}
	return fmt.Errorf("unknown Connector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectorMutation) ResetField(name string) error {
	switch name {
	case connector.FieldName:
		m.ResetName()
		return nil
	case connector.FieldDescription:
		m.ResetDescription()
		return nil
	case connector.FieldLabels:
		m.ResetLabels()
		return nil
	case connector.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case connector.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case connector.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case connector.FieldStatus:
		m.ResetStatus()
		return nil
	case connector.FieldProjectID:
		m.ResetProjectID()
		return nil
	case connector.FieldCategory:
		m.ResetCategory()
		return nil
	case connector.FieldType:
		m.ResetType()
		return nil
	case connector.FieldApplicableEnvironmentType:
		m.ResetApplicableEnvironmentType()
		return nil
	case connector.FieldConfigVersion:
		m.ResetConfigVersion()
		return nil
	case connector.FieldConfigData:
		m.ResetConfigData()
		return nil
	case connector.FieldEnableFinOps:
		m.ResetEnableFinOps()
		return nil
	case connector.FieldFinOpsCustomPricing:
		m.ResetFinOpsCustomPricing()
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.project != nil {
		edges = append(edges, connector.EdgeProject)
	}
	if m.environments != nil {
		edges = append(edges, connector.EdgeEnvironments)
	}
	if m.resource_components != nil {
		edges = append(edges, connector.EdgeResourceComponents)
	}
	if m.cost_reports != nil {
		edges = append(edges, connector.EdgeCostReports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connector.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case connector.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.environments))
		for id := range m.environments {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeResourceComponents:
		ids := make([]ent.Value, 0, len(m.resource_components))
		for id := range m.resource_components {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeCostReports:
		ids := make([]ent.Value, 0, len(m.cost_reports))
		for id := range m.cost_reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedenvironments != nil {
		edges = append(edges, connector.EdgeEnvironments)
	}
	if m.removedresource_components != nil {
		edges = append(edges, connector.EdgeResourceComponents)
	}
	if m.removedcost_reports != nil {
		edges = append(edges, connector.EdgeCostReports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connector.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removedenvironments))
		for id := range m.removedenvironments {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeResourceComponents:
		ids := make([]ent.Value, 0, len(m.removedresource_components))
		for id := range m.removedresource_components {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeCostReports:
		ids := make([]ent.Value, 0, len(m.removedcost_reports))
		for id := range m.removedcost_reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproject {
		edges = append(edges, connector.EdgeProject)
	}
	if m.clearedenvironments {
		edges = append(edges, connector.EdgeEnvironments)
	}
	if m.clearedresource_components {
		edges = append(edges, connector.EdgeResourceComponents)
	}
	if m.clearedcost_reports {
		edges = append(edges, connector.EdgeCostReports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectorMutation) EdgeCleared(name string) bool {
	switch name {
	case connector.EdgeProject:
		return m.clearedproject
	case connector.EdgeEnvironments:
		return m.clearedenvironments
	case connector.EdgeResourceComponents:
		return m.clearedresource_components
	case connector.EdgeCostReports:
		return m.clearedcost_reports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectorMutation) ClearEdge(name string) error {
	switch name {
	case connector.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Connector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectorMutation) ResetEdge(name string) error {
	switch name {
	case connector.EdgeProject:
		m.ResetProject()
		return nil
	case connector.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case connector.EdgeResourceComponents:
		m.ResetResourceComponents()
		return nil
	case connector.EdgeCostReports:
		m.ResetCostReports()
		return nil
	}
	return fmt.Errorf("unknown Connector edge %s", name)
}

// CostReportMutation represents an operation that mutates the CostReport nodes in the graph.
type CostReportMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	start_time                *time.Time
	end_time                  *time.Time
	minutes                   *float64
	addminutes                *float64
	name                      *string
	fingerprint               *string
	cluster_name              *string
	namespace                 *string
	node                      *string
	controller                *string
	controller_kind           *string
	pod                       *string
	container                 *string
	pvs                       *map[string]types.PVCost
	labels                    *map[string]string
	totalCost                 *float64
	addtotalCost              *float64
	currency                  *int
	addcurrency               *int
	cpu_cost                  *float64
	addcpu_cost               *float64
	cpu_core_request          *float64
	addcpu_core_request       *float64
	gpu_cost                  *float64
	addgpu_cost               *float64
	gpu_count                 *float64
	addgpu_count              *float64
	ram_cost                  *float64
	addram_cost               *float64
	ram_byte_request          *float64
	addram_byte_request       *float64
	pv_cost                   *float64
	addpv_cost                *float64
	pv_bytes                  *float64
	addpv_bytes               *float64
	load_balancer_cost        *float64
	addload_balancer_cost     *float64
	cpu_core_usage_average    *float64
	addcpu_core_usage_average *float64
	cpu_core_usage_max        *float64
	addcpu_core_usage_max     *float64
	ram_byte_usage_average    *float64
	addram_byte_usage_average *float64
	ram_byte_usage_max        *float64
	addram_byte_usage_max     *float64
	clearedFields             map[string]struct{}
	connector                 *object.ID
	clearedconnector          bool
	done                      bool
	oldValue                  func(context.Context) (*CostReport, error)
	predicates                []predicate.CostReport
}

var _ ent.Mutation = (*CostReportMutation)(nil)

// costReportOption allows management of the mutation configuration using functional options.
type costReportOption func(*CostReportMutation)

// newCostReportMutation creates new mutation for the CostReport entity.
func newCostReportMutation(c config, op Op, opts ...costReportOption) *CostReportMutation {
	m := &CostReportMutation{
		config:        c,
		op:            op,
		typ:           TypeCostReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostReportID sets the ID field of the mutation.
func withCostReportID(id int) costReportOption {
	return func(m *CostReportMutation) {
		var (
			err   error
			once  sync.Once
			value *CostReport
		)
		m.oldValue = func(ctx context.Context) (*CostReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostReport sets the old CostReport of the mutation.
func withCostReport(node *CostReport) costReportOption {
	return func(m *CostReportMutation) {
		m.oldValue = func(context.Context) (*CostReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CostReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartTime sets the "start_time" field.
func (m *CostReportMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CostReportMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CostReportMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *CostReportMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CostReportMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CostReportMutation) ResetEndTime() {
	m.end_time = nil
}

// SetMinutes sets the "minutes" field.
func (m *CostReportMutation) SetMinutes(f float64) {
	m.minutes = &f
	m.addminutes = nil
}

// Minutes returns the value of the "minutes" field in the mutation.
func (m *CostReportMutation) Minutes() (r float64, exists bool) {
	v := m.minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldMinutes returns the old "minutes" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldMinutes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinutes: %w", err)
	}
	return oldValue.Minutes, nil
}

// AddMinutes adds f to the "minutes" field.
func (m *CostReportMutation) AddMinutes(f float64) {
	if m.addminutes != nil {
		*m.addminutes += f
	} else {
		m.addminutes = &f
	}
}

// AddedMinutes returns the value that was added to the "minutes" field in this mutation.
func (m *CostReportMutation) AddedMinutes() (r float64, exists bool) {
	v := m.addminutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinutes resets all changes to the "minutes" field.
func (m *CostReportMutation) ResetMinutes() {
	m.minutes = nil
	m.addminutes = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *CostReportMutation) SetConnectorID(o object.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *CostReportMutation) ConnectorID() (r object.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldConnectorID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *CostReportMutation) ResetConnectorID() {
	m.connector = nil
}

// SetName sets the "name" field.
func (m *CostReportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CostReportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CostReportMutation) ResetName() {
	m.name = nil
}

// SetFingerprint sets the "fingerprint" field.
func (m *CostReportMutation) SetFingerprint(s string) {
	m.fingerprint = &s
}

// Fingerprint returns the value of the "fingerprint" field in the mutation.
func (m *CostReportMutation) Fingerprint() (r string, exists bool) {
	v := m.fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprint returns the old "fingerprint" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprint: %w", err)
	}
	return oldValue.Fingerprint, nil
}

// ResetFingerprint resets all changes to the "fingerprint" field.
func (m *CostReportMutation) ResetFingerprint() {
	m.fingerprint = nil
}

// SetClusterName sets the "cluster_name" field.
func (m *CostReportMutation) SetClusterName(s string) {
	m.cluster_name = &s
}

// ClusterName returns the value of the "cluster_name" field in the mutation.
func (m *CostReportMutation) ClusterName() (r string, exists bool) {
	v := m.cluster_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterName returns the old "cluster_name" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldClusterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClusterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClusterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterName: %w", err)
	}
	return oldValue.ClusterName, nil
}

// ClearClusterName clears the value of the "cluster_name" field.
func (m *CostReportMutation) ClearClusterName() {
	m.cluster_name = nil
	m.clearedFields[costreport.FieldClusterName] = struct{}{}
}

// ClusterNameCleared returns if the "cluster_name" field was cleared in this mutation.
func (m *CostReportMutation) ClusterNameCleared() bool {
	_, ok := m.clearedFields[costreport.FieldClusterName]
	return ok
}

// ResetClusterName resets all changes to the "cluster_name" field.
func (m *CostReportMutation) ResetClusterName() {
	m.cluster_name = nil
	delete(m.clearedFields, costreport.FieldClusterName)
}

// SetNamespace sets the "namespace" field.
func (m *CostReportMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *CostReportMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ClearNamespace clears the value of the "namespace" field.
func (m *CostReportMutation) ClearNamespace() {
	m.namespace = nil
	m.clearedFields[costreport.FieldNamespace] = struct{}{}
}

// NamespaceCleared returns if the "namespace" field was cleared in this mutation.
func (m *CostReportMutation) NamespaceCleared() bool {
	_, ok := m.clearedFields[costreport.FieldNamespace]
	return ok
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *CostReportMutation) ResetNamespace() {
	m.namespace = nil
	delete(m.clearedFields, costreport.FieldNamespace)
}

// SetNode sets the "node" field.
func (m *CostReportMutation) SetNode(s string) {
	m.node = &s
}

// Node returns the value of the "node" field in the mutation.
func (m *CostReportMutation) Node() (r string, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNode returns the old "node" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldNode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNode: %w", err)
	}
	return oldValue.Node, nil
}

// ClearNode clears the value of the "node" field.
func (m *CostReportMutation) ClearNode() {
	m.node = nil
	m.clearedFields[costreport.FieldNode] = struct{}{}
}

// NodeCleared returns if the "node" field was cleared in this mutation.
func (m *CostReportMutation) NodeCleared() bool {
	_, ok := m.clearedFields[costreport.FieldNode]
	return ok
}

// ResetNode resets all changes to the "node" field.
func (m *CostReportMutation) ResetNode() {
	m.node = nil
	delete(m.clearedFields, costreport.FieldNode)
}

// SetController sets the "controller" field.
func (m *CostReportMutation) SetController(s string) {
	m.controller = &s
}

// Controller returns the value of the "controller" field in the mutation.
func (m *CostReportMutation) Controller() (r string, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldController returns the old "controller" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldController(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldController: %w", err)
	}
	return oldValue.Controller, nil
}

// ClearController clears the value of the "controller" field.
func (m *CostReportMutation) ClearController() {
	m.controller = nil
	m.clearedFields[costreport.FieldController] = struct{}{}
}

// ControllerCleared returns if the "controller" field was cleared in this mutation.
func (m *CostReportMutation) ControllerCleared() bool {
	_, ok := m.clearedFields[costreport.FieldController]
	return ok
}

// ResetController resets all changes to the "controller" field.
func (m *CostReportMutation) ResetController() {
	m.controller = nil
	delete(m.clearedFields, costreport.FieldController)
}

// SetControllerKind sets the "controller_kind" field.
func (m *CostReportMutation) SetControllerKind(s string) {
	m.controller_kind = &s
}

// ControllerKind returns the value of the "controller_kind" field in the mutation.
func (m *CostReportMutation) ControllerKind() (r string, exists bool) {
	v := m.controller_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldControllerKind returns the old "controller_kind" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldControllerKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControllerKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControllerKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControllerKind: %w", err)
	}
	return oldValue.ControllerKind, nil
}

// ClearControllerKind clears the value of the "controller_kind" field.
func (m *CostReportMutation) ClearControllerKind() {
	m.controller_kind = nil
	m.clearedFields[costreport.FieldControllerKind] = struct{}{}
}

// ControllerKindCleared returns if the "controller_kind" field was cleared in this mutation.
func (m *CostReportMutation) ControllerKindCleared() bool {
	_, ok := m.clearedFields[costreport.FieldControllerKind]
	return ok
}

// ResetControllerKind resets all changes to the "controller_kind" field.
func (m *CostReportMutation) ResetControllerKind() {
	m.controller_kind = nil
	delete(m.clearedFields, costreport.FieldControllerKind)
}

// SetPod sets the "pod" field.
func (m *CostReportMutation) SetPod(s string) {
	m.pod = &s
}

// Pod returns the value of the "pod" field in the mutation.
func (m *CostReportMutation) Pod() (r string, exists bool) {
	v := m.pod
	if v == nil {
		return
	}
	return *v, true
}

// OldPod returns the old "pod" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldPod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPod: %w", err)
	}
	return oldValue.Pod, nil
}

// ClearPod clears the value of the "pod" field.
func (m *CostReportMutation) ClearPod() {
	m.pod = nil
	m.clearedFields[costreport.FieldPod] = struct{}{}
}

// PodCleared returns if the "pod" field was cleared in this mutation.
func (m *CostReportMutation) PodCleared() bool {
	_, ok := m.clearedFields[costreport.FieldPod]
	return ok
}

// ResetPod resets all changes to the "pod" field.
func (m *CostReportMutation) ResetPod() {
	m.pod = nil
	delete(m.clearedFields, costreport.FieldPod)
}

// SetContainer sets the "container" field.
func (m *CostReportMutation) SetContainer(s string) {
	m.container = &s
}

// Container returns the value of the "container" field in the mutation.
func (m *CostReportMutation) Container() (r string, exists bool) {
	v := m.container
	if v == nil {
		return
	}
	return *v, true
}

// OldContainer returns the old "container" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldContainer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainer: %w", err)
	}
	return oldValue.Container, nil
}

// ClearContainer clears the value of the "container" field.
func (m *CostReportMutation) ClearContainer() {
	m.container = nil
	m.clearedFields[costreport.FieldContainer] = struct{}{}
}

// ContainerCleared returns if the "container" field was cleared in this mutation.
func (m *CostReportMutation) ContainerCleared() bool {
	_, ok := m.clearedFields[costreport.FieldContainer]
	return ok
}

// ResetContainer resets all changes to the "container" field.
func (m *CostReportMutation) ResetContainer() {
	m.container = nil
	delete(m.clearedFields, costreport.FieldContainer)
}

// SetPvs sets the "pvs" field.
func (m *CostReportMutation) SetPvs(mc map[string]types.PVCost) {
	m.pvs = &mc
}

// Pvs returns the value of the "pvs" field in the mutation.
func (m *CostReportMutation) Pvs() (r map[string]types.PVCost, exists bool) {
	v := m.pvs
	if v == nil {
		return
	}
	return *v, true
}

// OldPvs returns the old "pvs" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldPvs(ctx context.Context) (v map[string]types.PVCost, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPvs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPvs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPvs: %w", err)
	}
	return oldValue.Pvs, nil
}

// ResetPvs resets all changes to the "pvs" field.
func (m *CostReportMutation) ResetPvs() {
	m.pvs = nil
}

// SetLabels sets the "labels" field.
func (m *CostReportMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *CostReportMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ResetLabels resets all changes to the "labels" field.
func (m *CostReportMutation) ResetLabels() {
	m.labels = nil
}

// SetTotalCost sets the "totalCost" field.
func (m *CostReportMutation) SetTotalCost(f float64) {
	m.totalCost = &f
	m.addtotalCost = nil
}

// TotalCost returns the value of the "totalCost" field in the mutation.
func (m *CostReportMutation) TotalCost() (r float64, exists bool) {
	v := m.totalCost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "totalCost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldTotalCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "totalCost" field.
func (m *CostReportMutation) AddTotalCost(f float64) {
	if m.addtotalCost != nil {
		*m.addtotalCost += f
	} else {
		m.addtotalCost = &f
	}
}

// AddedTotalCost returns the value that was added to the "totalCost" field in this mutation.
func (m *CostReportMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotalCost
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCost resets all changes to the "totalCost" field.
func (m *CostReportMutation) ResetTotalCost() {
	m.totalCost = nil
	m.addtotalCost = nil
}

// SetCurrency sets the "currency" field.
func (m *CostReportMutation) SetCurrency(i int) {
	m.currency = &i
	m.addcurrency = nil
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CostReportMutation) Currency() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// AddCurrency adds i to the "currency" field.
func (m *CostReportMutation) AddCurrency(i int) {
	if m.addcurrency != nil {
		*m.addcurrency += i
	} else {
		m.addcurrency = &i
	}
}

// AddedCurrency returns the value that was added to the "currency" field in this mutation.
func (m *CostReportMutation) AddedCurrency() (r int, exists bool) {
	v := m.addcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrency clears the value of the "currency" field.
func (m *CostReportMutation) ClearCurrency() {
	m.currency = nil
	m.addcurrency = nil
	m.clearedFields[costreport.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *CostReportMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[costreport.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CostReportMutation) ResetCurrency() {
	m.currency = nil
	m.addcurrency = nil
	delete(m.clearedFields, costreport.FieldCurrency)
}

// SetCPUCost sets the "cpu_cost" field.
func (m *CostReportMutation) SetCPUCost(f float64) {
	m.cpu_cost = &f
	m.addcpu_cost = nil
}

// CPUCost returns the value of the "cpu_cost" field in the mutation.
func (m *CostReportMutation) CPUCost() (r float64, exists bool) {
	v := m.cpu_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCost returns the old "cpu_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCPUCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCost: %w", err)
	}
	return oldValue.CPUCost, nil
}

// AddCPUCost adds f to the "cpu_cost" field.
func (m *CostReportMutation) AddCPUCost(f float64) {
	if m.addcpu_cost != nil {
		*m.addcpu_cost += f
	} else {
		m.addcpu_cost = &f
	}
}

// AddedCPUCost returns the value that was added to the "cpu_cost" field in this mutation.
func (m *CostReportMutation) AddedCPUCost() (r float64, exists bool) {
	v := m.addcpu_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCost resets all changes to the "cpu_cost" field.
func (m *CostReportMutation) ResetCPUCost() {
	m.cpu_cost = nil
	m.addcpu_cost = nil
}

// SetCPUCoreRequest sets the "cpu_core_request" field.
func (m *CostReportMutation) SetCPUCoreRequest(f float64) {
	m.cpu_core_request = &f
	m.addcpu_core_request = nil
}

// CPUCoreRequest returns the value of the "cpu_core_request" field in the mutation.
func (m *CostReportMutation) CPUCoreRequest() (r float64, exists bool) {
	v := m.cpu_core_request
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCoreRequest returns the old "cpu_core_request" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCPUCoreRequest(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCoreRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCoreRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCoreRequest: %w", err)
	}
	return oldValue.CPUCoreRequest, nil
}

// AddCPUCoreRequest adds f to the "cpu_core_request" field.
func (m *CostReportMutation) AddCPUCoreRequest(f float64) {
	if m.addcpu_core_request != nil {
		*m.addcpu_core_request += f
	} else {
		m.addcpu_core_request = &f
	}
}

// AddedCPUCoreRequest returns the value that was added to the "cpu_core_request" field in this mutation.
func (m *CostReportMutation) AddedCPUCoreRequest() (r float64, exists bool) {
	v := m.addcpu_core_request
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCoreRequest resets all changes to the "cpu_core_request" field.
func (m *CostReportMutation) ResetCPUCoreRequest() {
	m.cpu_core_request = nil
	m.addcpu_core_request = nil
}

// SetGPUCost sets the "gpu_cost" field.
func (m *CostReportMutation) SetGPUCost(f float64) {
	m.gpu_cost = &f
	m.addgpu_cost = nil
}

// GPUCost returns the value of the "gpu_cost" field in the mutation.
func (m *CostReportMutation) GPUCost() (r float64, exists bool) {
	v := m.gpu_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldGPUCost returns the old "gpu_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldGPUCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGPUCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGPUCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGPUCost: %w", err)
	}
	return oldValue.GPUCost, nil
}

// AddGPUCost adds f to the "gpu_cost" field.
func (m *CostReportMutation) AddGPUCost(f float64) {
	if m.addgpu_cost != nil {
		*m.addgpu_cost += f
	} else {
		m.addgpu_cost = &f
	}
}

// AddedGPUCost returns the value that was added to the "gpu_cost" field in this mutation.
func (m *CostReportMutation) AddedGPUCost() (r float64, exists bool) {
	v := m.addgpu_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetGPUCost resets all changes to the "gpu_cost" field.
func (m *CostReportMutation) ResetGPUCost() {
	m.gpu_cost = nil
	m.addgpu_cost = nil
}

// SetGPUCount sets the "gpu_count" field.
func (m *CostReportMutation) SetGPUCount(f float64) {
	m.gpu_count = &f
	m.addgpu_count = nil
}

// GPUCount returns the value of the "gpu_count" field in the mutation.
func (m *CostReportMutation) GPUCount() (r float64, exists bool) {
	v := m.gpu_count
	if v == nil {
		return
	}
	return *v, true
}

// OldGPUCount returns the old "gpu_count" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldGPUCount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGPUCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGPUCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGPUCount: %w", err)
	}
	return oldValue.GPUCount, nil
}

// AddGPUCount adds f to the "gpu_count" field.
func (m *CostReportMutation) AddGPUCount(f float64) {
	if m.addgpu_count != nil {
		*m.addgpu_count += f
	} else {
		m.addgpu_count = &f
	}
}

// AddedGPUCount returns the value that was added to the "gpu_count" field in this mutation.
func (m *CostReportMutation) AddedGPUCount() (r float64, exists bool) {
	v := m.addgpu_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetGPUCount resets all changes to the "gpu_count" field.
func (m *CostReportMutation) ResetGPUCount() {
	m.gpu_count = nil
	m.addgpu_count = nil
}

// SetRAMCost sets the "ram_cost" field.
func (m *CostReportMutation) SetRAMCost(f float64) {
	m.ram_cost = &f
	m.addram_cost = nil
}

// RAMCost returns the value of the "ram_cost" field in the mutation.
func (m *CostReportMutation) RAMCost() (r float64, exists bool) {
	v := m.ram_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMCost returns the old "ram_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldRAMCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMCost: %w", err)
	}
	return oldValue.RAMCost, nil
}

// AddRAMCost adds f to the "ram_cost" field.
func (m *CostReportMutation) AddRAMCost(f float64) {
	if m.addram_cost != nil {
		*m.addram_cost += f
	} else {
		m.addram_cost = &f
	}
}

// AddedRAMCost returns the value that was added to the "ram_cost" field in this mutation.
func (m *CostReportMutation) AddedRAMCost() (r float64, exists bool) {
	v := m.addram_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMCost resets all changes to the "ram_cost" field.
func (m *CostReportMutation) ResetRAMCost() {
	m.ram_cost = nil
	m.addram_cost = nil
}

// SetRAMByteRequest sets the "ram_byte_request" field.
func (m *CostReportMutation) SetRAMByteRequest(f float64) {
	m.ram_byte_request = &f
	m.addram_byte_request = nil
}

// RAMByteRequest returns the value of the "ram_byte_request" field in the mutation.
func (m *CostReportMutation) RAMByteRequest() (r float64, exists bool) {
	v := m.ram_byte_request
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMByteRequest returns the old "ram_byte_request" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldRAMByteRequest(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMByteRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMByteRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMByteRequest: %w", err)
	}
	return oldValue.RAMByteRequest, nil
}

// AddRAMByteRequest adds f to the "ram_byte_request" field.
func (m *CostReportMutation) AddRAMByteRequest(f float64) {
	if m.addram_byte_request != nil {
		*m.addram_byte_request += f
	} else {
		m.addram_byte_request = &f
	}
}

// AddedRAMByteRequest returns the value that was added to the "ram_byte_request" field in this mutation.
func (m *CostReportMutation) AddedRAMByteRequest() (r float64, exists bool) {
	v := m.addram_byte_request
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMByteRequest resets all changes to the "ram_byte_request" field.
func (m *CostReportMutation) ResetRAMByteRequest() {
	m.ram_byte_request = nil
	m.addram_byte_request = nil
}

// SetPVCost sets the "pv_cost" field.
func (m *CostReportMutation) SetPVCost(f float64) {
	m.pv_cost = &f
	m.addpv_cost = nil
}

// PVCost returns the value of the "pv_cost" field in the mutation.
func (m *CostReportMutation) PVCost() (r float64, exists bool) {
	v := m.pv_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldPVCost returns the old "pv_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldPVCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPVCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPVCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPVCost: %w", err)
	}
	return oldValue.PVCost, nil
}

// AddPVCost adds f to the "pv_cost" field.
func (m *CostReportMutation) AddPVCost(f float64) {
	if m.addpv_cost != nil {
		*m.addpv_cost += f
	} else {
		m.addpv_cost = &f
	}
}

// AddedPVCost returns the value that was added to the "pv_cost" field in this mutation.
func (m *CostReportMutation) AddedPVCost() (r float64, exists bool) {
	v := m.addpv_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetPVCost resets all changes to the "pv_cost" field.
func (m *CostReportMutation) ResetPVCost() {
	m.pv_cost = nil
	m.addpv_cost = nil
}

// SetPVBytes sets the "pv_bytes" field.
func (m *CostReportMutation) SetPVBytes(f float64) {
	m.pv_bytes = &f
	m.addpv_bytes = nil
}

// PVBytes returns the value of the "pv_bytes" field in the mutation.
func (m *CostReportMutation) PVBytes() (r float64, exists bool) {
	v := m.pv_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldPVBytes returns the old "pv_bytes" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldPVBytes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPVBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPVBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPVBytes: %w", err)
	}
	return oldValue.PVBytes, nil
}

// AddPVBytes adds f to the "pv_bytes" field.
func (m *CostReportMutation) AddPVBytes(f float64) {
	if m.addpv_bytes != nil {
		*m.addpv_bytes += f
	} else {
		m.addpv_bytes = &f
	}
}

// AddedPVBytes returns the value that was added to the "pv_bytes" field in this mutation.
func (m *CostReportMutation) AddedPVBytes() (r float64, exists bool) {
	v := m.addpv_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetPVBytes resets all changes to the "pv_bytes" field.
func (m *CostReportMutation) ResetPVBytes() {
	m.pv_bytes = nil
	m.addpv_bytes = nil
}

// SetLoadBalancerCost sets the "load_balancer_cost" field.
func (m *CostReportMutation) SetLoadBalancerCost(f float64) {
	m.load_balancer_cost = &f
	m.addload_balancer_cost = nil
}

// LoadBalancerCost returns the value of the "load_balancer_cost" field in the mutation.
func (m *CostReportMutation) LoadBalancerCost() (r float64, exists bool) {
	v := m.load_balancer_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadBalancerCost returns the old "load_balancer_cost" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldLoadBalancerCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoadBalancerCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoadBalancerCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadBalancerCost: %w", err)
	}
	return oldValue.LoadBalancerCost, nil
}

// AddLoadBalancerCost adds f to the "load_balancer_cost" field.
func (m *CostReportMutation) AddLoadBalancerCost(f float64) {
	if m.addload_balancer_cost != nil {
		*m.addload_balancer_cost += f
	} else {
		m.addload_balancer_cost = &f
	}
}

// AddedLoadBalancerCost returns the value that was added to the "load_balancer_cost" field in this mutation.
func (m *CostReportMutation) AddedLoadBalancerCost() (r float64, exists bool) {
	v := m.addload_balancer_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoadBalancerCost resets all changes to the "load_balancer_cost" field.
func (m *CostReportMutation) ResetLoadBalancerCost() {
	m.load_balancer_cost = nil
	m.addload_balancer_cost = nil
}

// SetCPUCoreUsageAverage sets the "cpu_core_usage_average" field.
func (m *CostReportMutation) SetCPUCoreUsageAverage(f float64) {
	m.cpu_core_usage_average = &f
	m.addcpu_core_usage_average = nil
}

// CPUCoreUsageAverage returns the value of the "cpu_core_usage_average" field in the mutation.
func (m *CostReportMutation) CPUCoreUsageAverage() (r float64, exists bool) {
	v := m.cpu_core_usage_average
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCoreUsageAverage returns the old "cpu_core_usage_average" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCPUCoreUsageAverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCoreUsageAverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCoreUsageAverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCoreUsageAverage: %w", err)
	}
	return oldValue.CPUCoreUsageAverage, nil
}

// AddCPUCoreUsageAverage adds f to the "cpu_core_usage_average" field.
func (m *CostReportMutation) AddCPUCoreUsageAverage(f float64) {
	if m.addcpu_core_usage_average != nil {
		*m.addcpu_core_usage_average += f
	} else {
		m.addcpu_core_usage_average = &f
	}
}

// AddedCPUCoreUsageAverage returns the value that was added to the "cpu_core_usage_average" field in this mutation.
func (m *CostReportMutation) AddedCPUCoreUsageAverage() (r float64, exists bool) {
	v := m.addcpu_core_usage_average
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCoreUsageAverage resets all changes to the "cpu_core_usage_average" field.
func (m *CostReportMutation) ResetCPUCoreUsageAverage() {
	m.cpu_core_usage_average = nil
	m.addcpu_core_usage_average = nil
}

// SetCPUCoreUsageMax sets the "cpu_core_usage_max" field.
func (m *CostReportMutation) SetCPUCoreUsageMax(f float64) {
	m.cpu_core_usage_max = &f
	m.addcpu_core_usage_max = nil
}

// CPUCoreUsageMax returns the value of the "cpu_core_usage_max" field in the mutation.
func (m *CostReportMutation) CPUCoreUsageMax() (r float64, exists bool) {
	v := m.cpu_core_usage_max
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCoreUsageMax returns the old "cpu_core_usage_max" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldCPUCoreUsageMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCoreUsageMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCoreUsageMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCoreUsageMax: %w", err)
	}
	return oldValue.CPUCoreUsageMax, nil
}

// AddCPUCoreUsageMax adds f to the "cpu_core_usage_max" field.
func (m *CostReportMutation) AddCPUCoreUsageMax(f float64) {
	if m.addcpu_core_usage_max != nil {
		*m.addcpu_core_usage_max += f
	} else {
		m.addcpu_core_usage_max = &f
	}
}

// AddedCPUCoreUsageMax returns the value that was added to the "cpu_core_usage_max" field in this mutation.
func (m *CostReportMutation) AddedCPUCoreUsageMax() (r float64, exists bool) {
	v := m.addcpu_core_usage_max
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCoreUsageMax resets all changes to the "cpu_core_usage_max" field.
func (m *CostReportMutation) ResetCPUCoreUsageMax() {
	m.cpu_core_usage_max = nil
	m.addcpu_core_usage_max = nil
}

// SetRAMByteUsageAverage sets the "ram_byte_usage_average" field.
func (m *CostReportMutation) SetRAMByteUsageAverage(f float64) {
	m.ram_byte_usage_average = &f
	m.addram_byte_usage_average = nil
}

// RAMByteUsageAverage returns the value of the "ram_byte_usage_average" field in the mutation.
func (m *CostReportMutation) RAMByteUsageAverage() (r float64, exists bool) {
	v := m.ram_byte_usage_average
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMByteUsageAverage returns the old "ram_byte_usage_average" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldRAMByteUsageAverage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMByteUsageAverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMByteUsageAverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMByteUsageAverage: %w", err)
	}
	return oldValue.RAMByteUsageAverage, nil
}

// AddRAMByteUsageAverage adds f to the "ram_byte_usage_average" field.
func (m *CostReportMutation) AddRAMByteUsageAverage(f float64) {
	if m.addram_byte_usage_average != nil {
		*m.addram_byte_usage_average += f
	} else {
		m.addram_byte_usage_average = &f
	}
}

// AddedRAMByteUsageAverage returns the value that was added to the "ram_byte_usage_average" field in this mutation.
func (m *CostReportMutation) AddedRAMByteUsageAverage() (r float64, exists bool) {
	v := m.addram_byte_usage_average
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMByteUsageAverage resets all changes to the "ram_byte_usage_average" field.
func (m *CostReportMutation) ResetRAMByteUsageAverage() {
	m.ram_byte_usage_average = nil
	m.addram_byte_usage_average = nil
}

// SetRAMByteUsageMax sets the "ram_byte_usage_max" field.
func (m *CostReportMutation) SetRAMByteUsageMax(f float64) {
	m.ram_byte_usage_max = &f
	m.addram_byte_usage_max = nil
}

// RAMByteUsageMax returns the value of the "ram_byte_usage_max" field in the mutation.
func (m *CostReportMutation) RAMByteUsageMax() (r float64, exists bool) {
	v := m.ram_byte_usage_max
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMByteUsageMax returns the old "ram_byte_usage_max" field's value of the CostReport entity.
// If the CostReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostReportMutation) OldRAMByteUsageMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMByteUsageMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMByteUsageMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMByteUsageMax: %w", err)
	}
	return oldValue.RAMByteUsageMax, nil
}

// AddRAMByteUsageMax adds f to the "ram_byte_usage_max" field.
func (m *CostReportMutation) AddRAMByteUsageMax(f float64) {
	if m.addram_byte_usage_max != nil {
		*m.addram_byte_usage_max += f
	} else {
		m.addram_byte_usage_max = &f
	}
}

// AddedRAMByteUsageMax returns the value that was added to the "ram_byte_usage_max" field in this mutation.
func (m *CostReportMutation) AddedRAMByteUsageMax() (r float64, exists bool) {
	v := m.addram_byte_usage_max
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMByteUsageMax resets all changes to the "ram_byte_usage_max" field.
func (m *CostReportMutation) ResetRAMByteUsageMax() {
	m.ram_byte_usage_max = nil
	m.addram_byte_usage_max = nil
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *CostReportMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *CostReportMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *CostReportMutation) ConnectorIDs() (ids []object.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *CostReportMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// Where appends a list predicates to the CostReportMutation builder.
func (m *CostReportMutation) Where(ps ...predicate.CostReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CostReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CostReport).
func (m *CostReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostReportMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.start_time != nil {
		fields = append(fields, costreport.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, costreport.FieldEndTime)
	}
	if m.minutes != nil {
		fields = append(fields, costreport.FieldMinutes)
	}
	if m.connector != nil {
		fields = append(fields, costreport.FieldConnectorID)
	}
	if m.name != nil {
		fields = append(fields, costreport.FieldName)
	}
	if m.fingerprint != nil {
		fields = append(fields, costreport.FieldFingerprint)
	}
	if m.cluster_name != nil {
		fields = append(fields, costreport.FieldClusterName)
	}
	if m.namespace != nil {
		fields = append(fields, costreport.FieldNamespace)
	}
	if m.node != nil {
		fields = append(fields, costreport.FieldNode)
	}
	if m.controller != nil {
		fields = append(fields, costreport.FieldController)
	}
	if m.controller_kind != nil {
		fields = append(fields, costreport.FieldControllerKind)
	}
	if m.pod != nil {
		fields = append(fields, costreport.FieldPod)
	}
	if m.container != nil {
		fields = append(fields, costreport.FieldContainer)
	}
	if m.pvs != nil {
		fields = append(fields, costreport.FieldPvs)
	}
	if m.labels != nil {
		fields = append(fields, costreport.FieldLabels)
	}
	if m.totalCost != nil {
		fields = append(fields, costreport.FieldTotalCost)
	}
	if m.currency != nil {
		fields = append(fields, costreport.FieldCurrency)
	}
	if m.cpu_cost != nil {
		fields = append(fields, costreport.FieldCPUCost)
	}
	if m.cpu_core_request != nil {
		fields = append(fields, costreport.FieldCPUCoreRequest)
	}
	if m.gpu_cost != nil {
		fields = append(fields, costreport.FieldGPUCost)
	}
	if m.gpu_count != nil {
		fields = append(fields, costreport.FieldGPUCount)
	}
	if m.ram_cost != nil {
		fields = append(fields, costreport.FieldRAMCost)
	}
	if m.ram_byte_request != nil {
		fields = append(fields, costreport.FieldRAMByteRequest)
	}
	if m.pv_cost != nil {
		fields = append(fields, costreport.FieldPVCost)
	}
	if m.pv_bytes != nil {
		fields = append(fields, costreport.FieldPVBytes)
	}
	if m.load_balancer_cost != nil {
		fields = append(fields, costreport.FieldLoadBalancerCost)
	}
	if m.cpu_core_usage_average != nil {
		fields = append(fields, costreport.FieldCPUCoreUsageAverage)
	}
	if m.cpu_core_usage_max != nil {
		fields = append(fields, costreport.FieldCPUCoreUsageMax)
	}
	if m.ram_byte_usage_average != nil {
		fields = append(fields, costreport.FieldRAMByteUsageAverage)
	}
	if m.ram_byte_usage_max != nil {
		fields = append(fields, costreport.FieldRAMByteUsageMax)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costreport.FieldStartTime:
		return m.StartTime()
	case costreport.FieldEndTime:
		return m.EndTime()
	case costreport.FieldMinutes:
		return m.Minutes()
	case costreport.FieldConnectorID:
		return m.ConnectorID()
	case costreport.FieldName:
		return m.Name()
	case costreport.FieldFingerprint:
		return m.Fingerprint()
	case costreport.FieldClusterName:
		return m.ClusterName()
	case costreport.FieldNamespace:
		return m.Namespace()
	case costreport.FieldNode:
		return m.Node()
	case costreport.FieldController:
		return m.Controller()
	case costreport.FieldControllerKind:
		return m.ControllerKind()
	case costreport.FieldPod:
		return m.Pod()
	case costreport.FieldContainer:
		return m.Container()
	case costreport.FieldPvs:
		return m.Pvs()
	case costreport.FieldLabels:
		return m.Labels()
	case costreport.FieldTotalCost:
		return m.TotalCost()
	case costreport.FieldCurrency:
		return m.Currency()
	case costreport.FieldCPUCost:
		return m.CPUCost()
	case costreport.FieldCPUCoreRequest:
		return m.CPUCoreRequest()
	case costreport.FieldGPUCost:
		return m.GPUCost()
	case costreport.FieldGPUCount:
		return m.GPUCount()
	case costreport.FieldRAMCost:
		return m.RAMCost()
	case costreport.FieldRAMByteRequest:
		return m.RAMByteRequest()
	case costreport.FieldPVCost:
		return m.PVCost()
	case costreport.FieldPVBytes:
		return m.PVBytes()
	case costreport.FieldLoadBalancerCost:
		return m.LoadBalancerCost()
	case costreport.FieldCPUCoreUsageAverage:
		return m.CPUCoreUsageAverage()
	case costreport.FieldCPUCoreUsageMax:
		return m.CPUCoreUsageMax()
	case costreport.FieldRAMByteUsageAverage:
		return m.RAMByteUsageAverage()
	case costreport.FieldRAMByteUsageMax:
		return m.RAMByteUsageMax()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costreport.FieldStartTime:
		return m.OldStartTime(ctx)
	case costreport.FieldEndTime:
		return m.OldEndTime(ctx)
	case costreport.FieldMinutes:
		return m.OldMinutes(ctx)
	case costreport.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case costreport.FieldName:
		return m.OldName(ctx)
	case costreport.FieldFingerprint:
		return m.OldFingerprint(ctx)
	case costreport.FieldClusterName:
		return m.OldClusterName(ctx)
	case costreport.FieldNamespace:
		return m.OldNamespace(ctx)
	case costreport.FieldNode:
		return m.OldNode(ctx)
	case costreport.FieldController:
		return m.OldController(ctx)
	case costreport.FieldControllerKind:
		return m.OldControllerKind(ctx)
	case costreport.FieldPod:
		return m.OldPod(ctx)
	case costreport.FieldContainer:
		return m.OldContainer(ctx)
	case costreport.FieldPvs:
		return m.OldPvs(ctx)
	case costreport.FieldLabels:
		return m.OldLabels(ctx)
	case costreport.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case costreport.FieldCurrency:
		return m.OldCurrency(ctx)
	case costreport.FieldCPUCost:
		return m.OldCPUCost(ctx)
	case costreport.FieldCPUCoreRequest:
		return m.OldCPUCoreRequest(ctx)
	case costreport.FieldGPUCost:
		return m.OldGPUCost(ctx)
	case costreport.FieldGPUCount:
		return m.OldGPUCount(ctx)
	case costreport.FieldRAMCost:
		return m.OldRAMCost(ctx)
	case costreport.FieldRAMByteRequest:
		return m.OldRAMByteRequest(ctx)
	case costreport.FieldPVCost:
		return m.OldPVCost(ctx)
	case costreport.FieldPVBytes:
		return m.OldPVBytes(ctx)
	case costreport.FieldLoadBalancerCost:
		return m.OldLoadBalancerCost(ctx)
	case costreport.FieldCPUCoreUsageAverage:
		return m.OldCPUCoreUsageAverage(ctx)
	case costreport.FieldCPUCoreUsageMax:
		return m.OldCPUCoreUsageMax(ctx)
	case costreport.FieldRAMByteUsageAverage:
		return m.OldRAMByteUsageAverage(ctx)
	case costreport.FieldRAMByteUsageMax:
		return m.OldRAMByteUsageMax(ctx)
	}
	return nil, fmt.Errorf("unknown CostReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costreport.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case costreport.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case costreport.FieldMinutes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinutes(v)
		return nil
	case costreport.FieldConnectorID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case costreport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case costreport.FieldFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprint(v)
		return nil
	case costreport.FieldClusterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterName(v)
		return nil
	case costreport.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case costreport.FieldNode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNode(v)
		return nil
	case costreport.FieldController:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetController(v)
		return nil
	case costreport.FieldControllerKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControllerKind(v)
		return nil
	case costreport.FieldPod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPod(v)
		return nil
	case costreport.FieldContainer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainer(v)
		return nil
	case costreport.FieldPvs:
		v, ok := value.(map[string]types.PVCost)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPvs(v)
		return nil
	case costreport.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case costreport.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case costreport.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case costreport.FieldCPUCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCost(v)
		return nil
	case costreport.FieldCPUCoreRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCoreRequest(v)
		return nil
	case costreport.FieldGPUCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGPUCost(v)
		return nil
	case costreport.FieldGPUCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGPUCount(v)
		return nil
	case costreport.FieldRAMCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMCost(v)
		return nil
	case costreport.FieldRAMByteRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMByteRequest(v)
		return nil
	case costreport.FieldPVCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPVCost(v)
		return nil
	case costreport.FieldPVBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPVBytes(v)
		return nil
	case costreport.FieldLoadBalancerCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadBalancerCost(v)
		return nil
	case costreport.FieldCPUCoreUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCoreUsageAverage(v)
		return nil
	case costreport.FieldCPUCoreUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCoreUsageMax(v)
		return nil
	case costreport.FieldRAMByteUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMByteUsageAverage(v)
		return nil
	case costreport.FieldRAMByteUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMByteUsageMax(v)
		return nil
	}
	return fmt.Errorf("unknown CostReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostReportMutation) AddedFields() []string {
	var fields []string
	if m.addminutes != nil {
		fields = append(fields, costreport.FieldMinutes)
	}
	if m.addtotalCost != nil {
		fields = append(fields, costreport.FieldTotalCost)
	}
	if m.addcurrency != nil {
		fields = append(fields, costreport.FieldCurrency)
	}
	if m.addcpu_cost != nil {
		fields = append(fields, costreport.FieldCPUCost)
	}
	if m.addcpu_core_request != nil {
		fields = append(fields, costreport.FieldCPUCoreRequest)
	}
	if m.addgpu_cost != nil {
		fields = append(fields, costreport.FieldGPUCost)
	}
	if m.addgpu_count != nil {
		fields = append(fields, costreport.FieldGPUCount)
	}
	if m.addram_cost != nil {
		fields = append(fields, costreport.FieldRAMCost)
	}
	if m.addram_byte_request != nil {
		fields = append(fields, costreport.FieldRAMByteRequest)
	}
	if m.addpv_cost != nil {
		fields = append(fields, costreport.FieldPVCost)
	}
	if m.addpv_bytes != nil {
		fields = append(fields, costreport.FieldPVBytes)
	}
	if m.addload_balancer_cost != nil {
		fields = append(fields, costreport.FieldLoadBalancerCost)
	}
	if m.addcpu_core_usage_average != nil {
		fields = append(fields, costreport.FieldCPUCoreUsageAverage)
	}
	if m.addcpu_core_usage_max != nil {
		fields = append(fields, costreport.FieldCPUCoreUsageMax)
	}
	if m.addram_byte_usage_average != nil {
		fields = append(fields, costreport.FieldRAMByteUsageAverage)
	}
	if m.addram_byte_usage_max != nil {
		fields = append(fields, costreport.FieldRAMByteUsageMax)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case costreport.FieldMinutes:
		return m.AddedMinutes()
	case costreport.FieldTotalCost:
		return m.AddedTotalCost()
	case costreport.FieldCurrency:
		return m.AddedCurrency()
	case costreport.FieldCPUCost:
		return m.AddedCPUCost()
	case costreport.FieldCPUCoreRequest:
		return m.AddedCPUCoreRequest()
	case costreport.FieldGPUCost:
		return m.AddedGPUCost()
	case costreport.FieldGPUCount:
		return m.AddedGPUCount()
	case costreport.FieldRAMCost:
		return m.AddedRAMCost()
	case costreport.FieldRAMByteRequest:
		return m.AddedRAMByteRequest()
	case costreport.FieldPVCost:
		return m.AddedPVCost()
	case costreport.FieldPVBytes:
		return m.AddedPVBytes()
	case costreport.FieldLoadBalancerCost:
		return m.AddedLoadBalancerCost()
	case costreport.FieldCPUCoreUsageAverage:
		return m.AddedCPUCoreUsageAverage()
	case costreport.FieldCPUCoreUsageMax:
		return m.AddedCPUCoreUsageMax()
	case costreport.FieldRAMByteUsageAverage:
		return m.AddedRAMByteUsageAverage()
	case costreport.FieldRAMByteUsageMax:
		return m.AddedRAMByteUsageMax()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case costreport.FieldMinutes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinutes(v)
		return nil
	case costreport.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	case costreport.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrency(v)
		return nil
	case costreport.FieldCPUCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCost(v)
		return nil
	case costreport.FieldCPUCoreRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCoreRequest(v)
		return nil
	case costreport.FieldGPUCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGPUCost(v)
		return nil
	case costreport.FieldGPUCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGPUCount(v)
		return nil
	case costreport.FieldRAMCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMCost(v)
		return nil
	case costreport.FieldRAMByteRequest:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMByteRequest(v)
		return nil
	case costreport.FieldPVCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPVCost(v)
		return nil
	case costreport.FieldPVBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPVBytes(v)
		return nil
	case costreport.FieldLoadBalancerCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadBalancerCost(v)
		return nil
	case costreport.FieldCPUCoreUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCoreUsageAverage(v)
		return nil
	case costreport.FieldCPUCoreUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCoreUsageMax(v)
		return nil
	case costreport.FieldRAMByteUsageAverage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMByteUsageAverage(v)
		return nil
	case costreport.FieldRAMByteUsageMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMByteUsageMax(v)
		return nil
	}
	return fmt.Errorf("unknown CostReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(costreport.FieldClusterName) {
		fields = append(fields, costreport.FieldClusterName)
	}
	if m.FieldCleared(costreport.FieldNamespace) {
		fields = append(fields, costreport.FieldNamespace)
	}
	if m.FieldCleared(costreport.FieldNode) {
		fields = append(fields, costreport.FieldNode)
	}
	if m.FieldCleared(costreport.FieldController) {
		fields = append(fields, costreport.FieldController)
	}
	if m.FieldCleared(costreport.FieldControllerKind) {
		fields = append(fields, costreport.FieldControllerKind)
	}
	if m.FieldCleared(costreport.FieldPod) {
		fields = append(fields, costreport.FieldPod)
	}
	if m.FieldCleared(costreport.FieldContainer) {
		fields = append(fields, costreport.FieldContainer)
	}
	if m.FieldCleared(costreport.FieldCurrency) {
		fields = append(fields, costreport.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostReportMutation) ClearField(name string) error {
	switch name {
	case costreport.FieldClusterName:
		m.ClearClusterName()
		return nil
	case costreport.FieldNamespace:
		m.ClearNamespace()
		return nil
	case costreport.FieldNode:
		m.ClearNode()
		return nil
	case costreport.FieldController:
		m.ClearController()
		return nil
	case costreport.FieldControllerKind:
		m.ClearControllerKind()
		return nil
	case costreport.FieldPod:
		m.ClearPod()
		return nil
	case costreport.FieldContainer:
		m.ClearContainer()
		return nil
	case costreport.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown CostReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostReportMutation) ResetField(name string) error {
	switch name {
	case costreport.FieldStartTime:
		m.ResetStartTime()
		return nil
	case costreport.FieldEndTime:
		m.ResetEndTime()
		return nil
	case costreport.FieldMinutes:
		m.ResetMinutes()
		return nil
	case costreport.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case costreport.FieldName:
		m.ResetName()
		return nil
	case costreport.FieldFingerprint:
		m.ResetFingerprint()
		return nil
	case costreport.FieldClusterName:
		m.ResetClusterName()
		return nil
	case costreport.FieldNamespace:
		m.ResetNamespace()
		return nil
	case costreport.FieldNode:
		m.ResetNode()
		return nil
	case costreport.FieldController:
		m.ResetController()
		return nil
	case costreport.FieldControllerKind:
		m.ResetControllerKind()
		return nil
	case costreport.FieldPod:
		m.ResetPod()
		return nil
	case costreport.FieldContainer:
		m.ResetContainer()
		return nil
	case costreport.FieldPvs:
		m.ResetPvs()
		return nil
	case costreport.FieldLabels:
		m.ResetLabels()
		return nil
	case costreport.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case costreport.FieldCurrency:
		m.ResetCurrency()
		return nil
	case costreport.FieldCPUCost:
		m.ResetCPUCost()
		return nil
	case costreport.FieldCPUCoreRequest:
		m.ResetCPUCoreRequest()
		return nil
	case costreport.FieldGPUCost:
		m.ResetGPUCost()
		return nil
	case costreport.FieldGPUCount:
		m.ResetGPUCount()
		return nil
	case costreport.FieldRAMCost:
		m.ResetRAMCost()
		return nil
	case costreport.FieldRAMByteRequest:
		m.ResetRAMByteRequest()
		return nil
	case costreport.FieldPVCost:
		m.ResetPVCost()
		return nil
	case costreport.FieldPVBytes:
		m.ResetPVBytes()
		return nil
	case costreport.FieldLoadBalancerCost:
		m.ResetLoadBalancerCost()
		return nil
	case costreport.FieldCPUCoreUsageAverage:
		m.ResetCPUCoreUsageAverage()
		return nil
	case costreport.FieldCPUCoreUsageMax:
		m.ResetCPUCoreUsageMax()
		return nil
	case costreport.FieldRAMByteUsageAverage:
		m.ResetRAMByteUsageAverage()
		return nil
	case costreport.FieldRAMByteUsageMax:
		m.ResetRAMByteUsageMax()
		return nil
	}
	return fmt.Errorf("unknown CostReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connector != nil {
		edges = append(edges, costreport.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costreport.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnector {
		edges = append(edges, costreport.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostReportMutation) EdgeCleared(name string) bool {
	switch name {
	case costreport.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostReportMutation) ClearEdge(name string) error {
	switch name {
	case costreport.EdgeConnector:
		m.ClearConnector()
		return nil
	}
	return fmt.Errorf("unknown CostReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostReportMutation) ResetEdge(name string) error {
	switch name {
	case costreport.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown CostReport edge %s", name)
}

// DistributeLockMutation represents an operation that mutates the DistributeLock nodes in the graph.
type DistributeLockMutation struct {
	config
	op            Op
	typ           string
	id            *string
	expireAt      *int64
	addexpireAt   *int64
	holder        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DistributeLock, error)
	predicates    []predicate.DistributeLock
}

var _ ent.Mutation = (*DistributeLockMutation)(nil)

// distributeLockOption allows management of the mutation configuration using functional options.
type distributeLockOption func(*DistributeLockMutation)

// newDistributeLockMutation creates new mutation for the DistributeLock entity.
func newDistributeLockMutation(c config, op Op, opts ...distributeLockOption) *DistributeLockMutation {
	m := &DistributeLockMutation{
		config:        c,
		op:            op,
		typ:           TypeDistributeLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistributeLockID sets the ID field of the mutation.
func withDistributeLockID(id string) distributeLockOption {
	return func(m *DistributeLockMutation) {
		var (
			err   error
			once  sync.Once
			value *DistributeLock
		)
		m.oldValue = func(ctx context.Context) (*DistributeLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DistributeLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistributeLock sets the old DistributeLock of the mutation.
func withDistributeLock(node *DistributeLock) distributeLockOption {
	return func(m *DistributeLockMutation) {
		m.oldValue = func(context.Context) (*DistributeLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistributeLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistributeLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DistributeLock entities.
func (m *DistributeLockMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DistributeLockMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DistributeLockMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DistributeLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExpireAt sets the "expireAt" field.
func (m *DistributeLockMutation) SetExpireAt(i int64) {
	m.expireAt = &i
	m.addexpireAt = nil
}

// ExpireAt returns the value of the "expireAt" field in the mutation.
func (m *DistributeLockMutation) ExpireAt() (r int64, exists bool) {
	v := m.expireAt
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expireAt" field's value of the DistributeLock entity.
// If the DistributeLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistributeLockMutation) OldExpireAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// AddExpireAt adds i to the "expireAt" field.
func (m *DistributeLockMutation) AddExpireAt(i int64) {
	if m.addexpireAt != nil {
		*m.addexpireAt += i
	} else {
		m.addexpireAt = &i
	}
}

// AddedExpireAt returns the value that was added to the "expireAt" field in this mutation.
func (m *DistributeLockMutation) AddedExpireAt() (r int64, exists bool) {
	v := m.addexpireAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpireAt resets all changes to the "expireAt" field.
func (m *DistributeLockMutation) ResetExpireAt() {
	m.expireAt = nil
	m.addexpireAt = nil
}

// SetHolder sets the "holder" field.
func (m *DistributeLockMutation) SetHolder(s string) {
	m.holder = &s
}

// Holder returns the value of the "holder" field in the mutation.
func (m *DistributeLockMutation) Holder() (r string, exists bool) {
	v := m.holder
	if v == nil {
		return
	}
	return *v, true
}

// OldHolder returns the old "holder" field's value of the DistributeLock entity.
// If the DistributeLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistributeLockMutation) OldHolder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHolder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHolder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHolder: %w", err)
	}
	return oldValue.Holder, nil
}

// ResetHolder resets all changes to the "holder" field.
func (m *DistributeLockMutation) ResetHolder() {
	m.holder = nil
}

// Where appends a list predicates to the DistributeLockMutation builder.
func (m *DistributeLockMutation) Where(ps ...predicate.DistributeLock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DistributeLockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DistributeLockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DistributeLock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DistributeLockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DistributeLockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DistributeLock).
func (m *DistributeLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistributeLockMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.expireAt != nil {
		fields = append(fields, distributelock.FieldExpireAt)
	}
	if m.holder != nil {
		fields = append(fields, distributelock.FieldHolder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistributeLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case distributelock.FieldExpireAt:
		return m.ExpireAt()
	case distributelock.FieldHolder:
		return m.Holder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistributeLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case distributelock.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case distributelock.FieldHolder:
		return m.OldHolder(ctx)
	}
	return nil, fmt.Errorf("unknown DistributeLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistributeLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case distributelock.FieldExpireAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case distributelock.FieldHolder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHolder(v)
		return nil
	}
	return fmt.Errorf("unknown DistributeLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistributeLockMutation) AddedFields() []string {
	var fields []string
	if m.addexpireAt != nil {
		fields = append(fields, distributelock.FieldExpireAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistributeLockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case distributelock.FieldExpireAt:
		return m.AddedExpireAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistributeLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case distributelock.FieldExpireAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireAt(v)
		return nil
	}
	return fmt.Errorf("unknown DistributeLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistributeLockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistributeLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistributeLockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DistributeLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistributeLockMutation) ResetField(name string) error {
	switch name {
	case distributelock.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case distributelock.FieldHolder:
		m.ResetHolder()
		return nil
	}
	return fmt.Errorf("unknown DistributeLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistributeLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistributeLockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistributeLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistributeLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistributeLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistributeLockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistributeLockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DistributeLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistributeLockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DistributeLock edge %s", name)
}

// EnvironmentMutation represents an operation that mutates the Environment nodes in the graph.
type EnvironmentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *object.ID
	name                       *string
	description                *string
	labels                     *map[string]string
	annotations                *map[string]string
	create_time                *time.Time
	update_time                *time.Time
	_type                      *string
	clearedFields              map[string]struct{}
	project                    *object.ID
	clearedproject             bool
	connectors                 map[object.ID]struct{}
	removedconnectors          map[object.ID]struct{}
	clearedconnectors          bool
	resources                  map[object.ID]struct{}
	removedresources           map[object.ID]struct{}
	clearedresources           bool
	resource_revisions         map[object.ID]struct{}
	removedresource_revisions  map[object.ID]struct{}
	clearedresource_revisions  bool
	resource_components        map[object.ID]struct{}
	removedresource_components map[object.ID]struct{}
	clearedresource_components bool
	variables                  map[object.ID]struct{}
	removedvariables           map[object.ID]struct{}
	clearedvariables           bool
	done                       bool
	oldValue                   func(context.Context) (*Environment, error)
	predicates                 []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows management of the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for the Environment entity.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the ID field of the mutation.
func withEnvironmentID(id object.ID) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Environment entities.
func (m *EnvironmentMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Environment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EnvironmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EnvironmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EnvironmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[environment.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EnvironmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[environment.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EnvironmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, environment.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *EnvironmentMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *EnvironmentMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *EnvironmentMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[environment.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *EnvironmentMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[environment.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *EnvironmentMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, environment.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *EnvironmentMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *EnvironmentMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *EnvironmentMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[environment.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *EnvironmentMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[environment.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *EnvironmentMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, environment.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *EnvironmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EnvironmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EnvironmentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EnvironmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EnvironmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EnvironmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *EnvironmentMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *EnvironmentMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *EnvironmentMutation) ResetProjectID() {
	m.project = nil
}

// SetType sets the "type" field.
func (m *EnvironmentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *EnvironmentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EnvironmentMutation) ResetType() {
	m._type = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *EnvironmentMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *EnvironmentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *EnvironmentMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *EnvironmentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddConnectorIDs adds the "connectors" edge to the EnvironmentConnectorRelationship entity by ids.
func (m *EnvironmentMutation) AddConnectorIDs(ids ...object.ID) {
	if m.connectors == nil {
		m.connectors = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.connectors[ids[i]] = struct{}{}
	}
}

// ClearConnectors clears the "connectors" edge to the EnvironmentConnectorRelationship entity.
func (m *EnvironmentMutation) ClearConnectors() {
	m.clearedconnectors = true
}

// ConnectorsCleared reports if the "connectors" edge to the EnvironmentConnectorRelationship entity was cleared.
func (m *EnvironmentMutation) ConnectorsCleared() bool {
	return m.clearedconnectors
}

// RemoveConnectorIDs removes the "connectors" edge to the EnvironmentConnectorRelationship entity by IDs.
func (m *EnvironmentMutation) RemoveConnectorIDs(ids ...object.ID) {
	if m.removedconnectors == nil {
		m.removedconnectors = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.connectors, ids[i])
		m.removedconnectors[ids[i]] = struct{}{}
	}
}

// RemovedConnectors returns the removed IDs of the "connectors" edge to the EnvironmentConnectorRelationship entity.
func (m *EnvironmentMutation) RemovedConnectorsIDs() (ids []object.ID) {
	for id := range m.removedconnectors {
		ids = append(ids, id)
	}
	return
}

// ConnectorsIDs returns the "connectors" edge IDs in the mutation.
func (m *EnvironmentMutation) ConnectorsIDs() (ids []object.ID) {
	for id := range m.connectors {
		ids = append(ids, id)
	}
	return
}

// ResetConnectors resets all changes to the "connectors" edge.
func (m *EnvironmentMutation) ResetConnectors() {
	m.connectors = nil
	m.clearedconnectors = false
	m.removedconnectors = nil
}

// AddResourceIDs adds the "resources" edge to the Resource entity by ids.
func (m *EnvironmentMutation) AddResourceIDs(ids ...object.ID) {
	if m.resources == nil {
		m.resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the Resource entity.
func (m *EnvironmentMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the Resource entity was cleared.
func (m *EnvironmentMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the Resource entity by IDs.
func (m *EnvironmentMutation) RemoveResourceIDs(ids ...object.ID) {
	if m.removedresources == nil {
		m.removedresources = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the Resource entity.
func (m *EnvironmentMutation) RemovedResourcesIDs() (ids []object.ID) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *EnvironmentMutation) ResourcesIDs() (ids []object.ID) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *EnvironmentMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddResourceRevisionIDs adds the "resource_revisions" edge to the ResourceRevision entity by ids.
func (m *EnvironmentMutation) AddResourceRevisionIDs(ids ...object.ID) {
	if m.resource_revisions == nil {
		m.resource_revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resource_revisions[ids[i]] = struct{}{}
	}
}

// ClearResourceRevisions clears the "resource_revisions" edge to the ResourceRevision entity.
func (m *EnvironmentMutation) ClearResourceRevisions() {
	m.clearedresource_revisions = true
}

// ResourceRevisionsCleared reports if the "resource_revisions" edge to the ResourceRevision entity was cleared.
func (m *EnvironmentMutation) ResourceRevisionsCleared() bool {
	return m.clearedresource_revisions
}

// RemoveResourceRevisionIDs removes the "resource_revisions" edge to the ResourceRevision entity by IDs.
func (m *EnvironmentMutation) RemoveResourceRevisionIDs(ids ...object.ID) {
	if m.removedresource_revisions == nil {
		m.removedresource_revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resource_revisions, ids[i])
		m.removedresource_revisions[ids[i]] = struct{}{}
	}
}

// RemovedResourceRevisions returns the removed IDs of the "resource_revisions" edge to the ResourceRevision entity.
func (m *EnvironmentMutation) RemovedResourceRevisionsIDs() (ids []object.ID) {
	for id := range m.removedresource_revisions {
		ids = append(ids, id)
	}
	return
}

// ResourceRevisionsIDs returns the "resource_revisions" edge IDs in the mutation.
func (m *EnvironmentMutation) ResourceRevisionsIDs() (ids []object.ID) {
	for id := range m.resource_revisions {
		ids = append(ids, id)
	}
	return
}

// ResetResourceRevisions resets all changes to the "resource_revisions" edge.
func (m *EnvironmentMutation) ResetResourceRevisions() {
	m.resource_revisions = nil
	m.clearedresource_revisions = false
	m.removedresource_revisions = nil
}

// AddResourceComponentIDs adds the "resource_components" edge to the ResourceComponent entity by ids.
func (m *EnvironmentMutation) AddResourceComponentIDs(ids ...object.ID) {
	if m.resource_components == nil {
		m.resource_components = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resource_components[ids[i]] = struct{}{}
	}
}

// ClearResourceComponents clears the "resource_components" edge to the ResourceComponent entity.
func (m *EnvironmentMutation) ClearResourceComponents() {
	m.clearedresource_components = true
}

// ResourceComponentsCleared reports if the "resource_components" edge to the ResourceComponent entity was cleared.
func (m *EnvironmentMutation) ResourceComponentsCleared() bool {
	return m.clearedresource_components
}

// RemoveResourceComponentIDs removes the "resource_components" edge to the ResourceComponent entity by IDs.
func (m *EnvironmentMutation) RemoveResourceComponentIDs(ids ...object.ID) {
	if m.removedresource_components == nil {
		m.removedresource_components = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resource_components, ids[i])
		m.removedresource_components[ids[i]] = struct{}{}
	}
}

// RemovedResourceComponents returns the removed IDs of the "resource_components" edge to the ResourceComponent entity.
func (m *EnvironmentMutation) RemovedResourceComponentsIDs() (ids []object.ID) {
	for id := range m.removedresource_components {
		ids = append(ids, id)
	}
	return
}

// ResourceComponentsIDs returns the "resource_components" edge IDs in the mutation.
func (m *EnvironmentMutation) ResourceComponentsIDs() (ids []object.ID) {
	for id := range m.resource_components {
		ids = append(ids, id)
	}
	return
}

// ResetResourceComponents resets all changes to the "resource_components" edge.
func (m *EnvironmentMutation) ResetResourceComponents() {
	m.resource_components = nil
	m.clearedresource_components = false
	m.removedresource_components = nil
}

// AddVariableIDs adds the "variables" edge to the Variable entity by ids.
func (m *EnvironmentMutation) AddVariableIDs(ids ...object.ID) {
	if m.variables == nil {
		m.variables = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.variables[ids[i]] = struct{}{}
	}
}

// ClearVariables clears the "variables" edge to the Variable entity.
func (m *EnvironmentMutation) ClearVariables() {
	m.clearedvariables = true
}

// VariablesCleared reports if the "variables" edge to the Variable entity was cleared.
func (m *EnvironmentMutation) VariablesCleared() bool {
	return m.clearedvariables
}

// RemoveVariableIDs removes the "variables" edge to the Variable entity by IDs.
func (m *EnvironmentMutation) RemoveVariableIDs(ids ...object.ID) {
	if m.removedvariables == nil {
		m.removedvariables = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.variables, ids[i])
		m.removedvariables[ids[i]] = struct{}{}
	}
}

// RemovedVariables returns the removed IDs of the "variables" edge to the Variable entity.
func (m *EnvironmentMutation) RemovedVariablesIDs() (ids []object.ID) {
	for id := range m.removedvariables {
		ids = append(ids, id)
	}
	return
}

// VariablesIDs returns the "variables" edge IDs in the mutation.
func (m *EnvironmentMutation) VariablesIDs() (ids []object.ID) {
	for id := range m.variables {
		ids = append(ids, id)
	}
	return
}

// ResetVariables resets all changes to the "variables" edge.
func (m *EnvironmentMutation) ResetVariables() {
	m.variables = nil
	m.clearedvariables = false
	m.removedvariables = nil
}

// Where appends a list predicates to the EnvironmentMutation builder.
func (m *EnvironmentMutation) Where(ps ...predicate.Environment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Environment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	if m.description != nil {
		fields = append(fields, environment.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, environment.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, environment.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, environment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, environment.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, environment.FieldProjectID)
	}
	if m._type != nil {
		fields = append(fields, environment.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldName:
		return m.Name()
	case environment.FieldDescription:
		return m.Description()
	case environment.FieldLabels:
		return m.Labels()
	case environment.FieldAnnotations:
		return m.Annotations()
	case environment.FieldCreateTime:
		return m.CreateTime()
	case environment.FieldUpdateTime:
		return m.UpdateTime()
	case environment.FieldProjectID:
		return m.ProjectID()
	case environment.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldName:
		return m.OldName(ctx)
	case environment.FieldDescription:
		return m.OldDescription(ctx)
	case environment.FieldLabels:
		return m.OldLabels(ctx)
	case environment.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case environment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case environment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case environment.FieldProjectID:
		return m.OldProjectID(ctx)
	case environment.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case environment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case environment.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case environment.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case environment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case environment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case environment.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case environment.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(environment.FieldDescription) {
		fields = append(fields, environment.FieldDescription)
	}
	if m.FieldCleared(environment.FieldLabels) {
		fields = append(fields, environment.FieldLabels)
	}
	if m.FieldCleared(environment.FieldAnnotations) {
		fields = append(fields, environment.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	switch name {
	case environment.FieldDescription:
		m.ClearDescription()
		return nil
	case environment.FieldLabels:
		m.ClearLabels()
		return nil
	case environment.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldName:
		m.ResetName()
		return nil
	case environment.FieldDescription:
		m.ResetDescription()
		return nil
	case environment.FieldLabels:
		m.ResetLabels()
		return nil
	case environment.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case environment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case environment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case environment.FieldProjectID:
		m.ResetProjectID()
		return nil
	case environment.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.project != nil {
		edges = append(edges, environment.EdgeProject)
	}
	if m.connectors != nil {
		edges = append(edges, environment.EdgeConnectors)
	}
	if m.resources != nil {
		edges = append(edges, environment.EdgeResources)
	}
	if m.resource_revisions != nil {
		edges = append(edges, environment.EdgeResourceRevisions)
	}
	if m.resource_components != nil {
		edges = append(edges, environment.EdgeResourceComponents)
	}
	if m.variables != nil {
		edges = append(edges, environment.EdgeVariables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case environment.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.connectors))
		for id := range m.connectors {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeResourceRevisions:
		ids := make([]ent.Value, 0, len(m.resource_revisions))
		for id := range m.resource_revisions {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeResourceComponents:
		ids := make([]ent.Value, 0, len(m.resource_components))
		for id := range m.resource_components {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeVariables:
		ids := make([]ent.Value, 0, len(m.variables))
		for id := range m.variables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedconnectors != nil {
		edges = append(edges, environment.EdgeConnectors)
	}
	if m.removedresources != nil {
		edges = append(edges, environment.EdgeResources)
	}
	if m.removedresource_revisions != nil {
		edges = append(edges, environment.EdgeResourceRevisions)
	}
	if m.removedresource_components != nil {
		edges = append(edges, environment.EdgeResourceComponents)
	}
	if m.removedvariables != nil {
		edges = append(edges, environment.EdgeVariables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.removedconnectors))
		for id := range m.removedconnectors {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeResourceRevisions:
		ids := make([]ent.Value, 0, len(m.removedresource_revisions))
		for id := range m.removedresource_revisions {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeResourceComponents:
		ids := make([]ent.Value, 0, len(m.removedresource_components))
		for id := range m.removedresource_components {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeVariables:
		ids := make([]ent.Value, 0, len(m.removedvariables))
		for id := range m.removedvariables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedproject {
		edges = append(edges, environment.EdgeProject)
	}
	if m.clearedconnectors {
		edges = append(edges, environment.EdgeConnectors)
	}
	if m.clearedresources {
		edges = append(edges, environment.EdgeResources)
	}
	if m.clearedresource_revisions {
		edges = append(edges, environment.EdgeResourceRevisions)
	}
	if m.clearedresource_components {
		edges = append(edges, environment.EdgeResourceComponents)
	}
	if m.clearedvariables {
		edges = append(edges, environment.EdgeVariables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeProject:
		return m.clearedproject
	case environment.EdgeConnectors:
		return m.clearedconnectors
	case environment.EdgeResources:
		return m.clearedresources
	case environment.EdgeResourceRevisions:
		return m.clearedresource_revisions
	case environment.EdgeResourceComponents:
		return m.clearedresource_components
	case environment.EdgeVariables:
		return m.clearedvariables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	case environment.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeProject:
		m.ResetProject()
		return nil
	case environment.EdgeConnectors:
		m.ResetConnectors()
		return nil
	case environment.EdgeResources:
		m.ResetResources()
		return nil
	case environment.EdgeResourceRevisions:
		m.ResetResourceRevisions()
		return nil
	case environment.EdgeResourceComponents:
		m.ResetResourceComponents()
		return nil
	case environment.EdgeVariables:
		m.ResetVariables()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// EnvironmentConnectorRelationshipMutation represents an operation that mutates the EnvironmentConnectorRelationship nodes in the graph.
type EnvironmentConnectorRelationshipMutation struct {
	config
	op                 Op
	typ                string
	id                 *object.ID
	create_time        *time.Time
	clearedFields      map[string]struct{}
	environment        *object.ID
	clearedenvironment bool
	connector          *object.ID
	clearedconnector   bool
	done               bool
	oldValue           func(context.Context) (*EnvironmentConnectorRelationship, error)
	predicates         []predicate.EnvironmentConnectorRelationship
}

var _ ent.Mutation = (*EnvironmentConnectorRelationshipMutation)(nil)

// environmentConnectorRelationshipOption allows management of the mutation configuration using functional options.
type environmentConnectorRelationshipOption func(*EnvironmentConnectorRelationshipMutation)

// newEnvironmentConnectorRelationshipMutation creates new mutation for the EnvironmentConnectorRelationship entity.
func newEnvironmentConnectorRelationshipMutation(c config, op Op, opts ...environmentConnectorRelationshipOption) *EnvironmentConnectorRelationshipMutation {
	m := &EnvironmentConnectorRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironmentConnectorRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentConnectorRelationshipID sets the ID field of the mutation.
func withEnvironmentConnectorRelationshipID(id object.ID) environmentConnectorRelationshipOption {
	return func(m *EnvironmentConnectorRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *EnvironmentConnectorRelationship
		)
		m.oldValue = func(ctx context.Context) (*EnvironmentConnectorRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnvironmentConnectorRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironmentConnectorRelationship sets the old EnvironmentConnectorRelationship of the mutation.
func withEnvironmentConnectorRelationship(node *EnvironmentConnectorRelationship) environmentConnectorRelationshipOption {
	return func(m *EnvironmentConnectorRelationshipMutation) {
		m.oldValue = func(context.Context) (*EnvironmentConnectorRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentConnectorRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentConnectorRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnvironmentConnectorRelationship entities.
func (m *EnvironmentConnectorRelationshipMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentConnectorRelationshipMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentConnectorRelationshipMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnvironmentConnectorRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EnvironmentConnectorRelationshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the EnvironmentConnectorRelationship entity.
// If the EnvironmentConnectorRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentConnectorRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *EnvironmentConnectorRelationshipMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the EnvironmentConnectorRelationship entity.
// If the EnvironmentConnectorRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentConnectorRelationshipMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *EnvironmentConnectorRelationshipMutation) SetConnectorID(o object.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorID() (r object.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the EnvironmentConnectorRelationship entity.
// If the EnvironmentConnectorRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentConnectorRelationshipMutation) OldConnectorID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *EnvironmentConnectorRelationshipMutation) ResetConnectorID() {
	m.connector = nil
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *EnvironmentConnectorRelationshipMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *EnvironmentConnectorRelationshipMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *EnvironmentConnectorRelationshipMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *EnvironmentConnectorRelationshipMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *EnvironmentConnectorRelationshipMutation) ConnectorIDs() (ids []object.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *EnvironmentConnectorRelationshipMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// Where appends a list predicates to the EnvironmentConnectorRelationshipMutation builder.
func (m *EnvironmentConnectorRelationshipMutation) Where(ps ...predicate.EnvironmentConnectorRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentConnectorRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentConnectorRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnvironmentConnectorRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentConnectorRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentConnectorRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnvironmentConnectorRelationship).
func (m *EnvironmentConnectorRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentConnectorRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, environmentconnectorrelationship.FieldCreateTime)
	}
	if m.environment != nil {
		fields = append(fields, environmentconnectorrelationship.FieldEnvironmentID)
	}
	if m.connector != nil {
		fields = append(fields, environmentconnectorrelationship.FieldConnectorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentConnectorRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		return m.CreateTime()
	case environmentconnectorrelationship.FieldEnvironmentID:
		return m.EnvironmentID()
	case environmentconnectorrelationship.FieldConnectorID:
		return m.ConnectorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentConnectorRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case environmentconnectorrelationship.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case environmentconnectorrelationship.FieldConnectorID:
		return m.OldConnectorID(ctx)
	}
	return nil, fmt.Errorf("unknown EnvironmentConnectorRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentConnectorRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case environmentconnectorrelationship.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case environmentconnectorrelationship.FieldConnectorID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentConnectorRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentConnectorRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnvironmentConnectorRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ResetField(name string) error {
	switch name {
	case environmentconnectorrelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case environmentconnectorrelationship.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case environmentconnectorrelationship.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.environment != nil {
		edges = append(edges, environmentconnectorrelationship.EdgeEnvironment)
	}
	if m.connector != nil {
		edges = append(edges, environmentconnectorrelationship.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case environmentconnectorrelationship.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenvironment {
		edges = append(edges, environmentconnectorrelationship.EdgeEnvironment)
	}
	if m.clearedconnector {
		edges = append(edges, environmentconnectorrelationship.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentConnectorRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		return m.clearedenvironment
	case environmentconnectorrelationship.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case environmentconnectorrelationship.EdgeConnector:
		m.ClearConnector()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentConnectorRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case environmentconnectorrelationship.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case environmentconnectorrelationship.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown EnvironmentConnectorRelationship edge %s", name)
}

// PerspectiveMutation represents an operation that mutates the Perspective nodes in the graph.
type PerspectiveMutation struct {
	config
	op                 Op
	typ                string
	id                 *object.ID
	name               *string
	description        *string
	labels             *map[string]string
	annotations        *map[string]string
	create_time        *time.Time
	update_time        *time.Time
	start_time         *string
	end_time           *string
	builtin            *bool
	cost_queries       *[]types.QueryCondition
	appendcost_queries []types.QueryCondition
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Perspective, error)
	predicates         []predicate.Perspective
}

var _ ent.Mutation = (*PerspectiveMutation)(nil)

// perspectiveOption allows management of the mutation configuration using functional options.
type perspectiveOption func(*PerspectiveMutation)

// newPerspectiveMutation creates new mutation for the Perspective entity.
func newPerspectiveMutation(c config, op Op, opts ...perspectiveOption) *PerspectiveMutation {
	m := &PerspectiveMutation{
		config:        c,
		op:            op,
		typ:           TypePerspective,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPerspectiveID sets the ID field of the mutation.
func withPerspectiveID(id object.ID) perspectiveOption {
	return func(m *PerspectiveMutation) {
		var (
			err   error
			once  sync.Once
			value *Perspective
		)
		m.oldValue = func(ctx context.Context) (*Perspective, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Perspective.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerspective sets the old Perspective of the mutation.
func withPerspective(node *Perspective) perspectiveOption {
	return func(m *PerspectiveMutation) {
		m.oldValue = func(context.Context) (*Perspective, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PerspectiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PerspectiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Perspective entities.
func (m *PerspectiveMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PerspectiveMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PerspectiveMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Perspective.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PerspectiveMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PerspectiveMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PerspectiveMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PerspectiveMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PerspectiveMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PerspectiveMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[perspective.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PerspectiveMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[perspective.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PerspectiveMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, perspective.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *PerspectiveMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *PerspectiveMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *PerspectiveMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[perspective.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *PerspectiveMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[perspective.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *PerspectiveMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, perspective.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *PerspectiveMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *PerspectiveMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *PerspectiveMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[perspective.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *PerspectiveMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[perspective.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *PerspectiveMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, perspective.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *PerspectiveMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PerspectiveMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PerspectiveMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PerspectiveMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PerspectiveMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PerspectiveMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStartTime sets the "start_time" field.
func (m *PerspectiveMutation) SetStartTime(s string) {
	m.start_time = &s
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *PerspectiveMutation) StartTime() (r string, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldStartTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *PerspectiveMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *PerspectiveMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *PerspectiveMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *PerspectiveMutation) ResetEndTime() {
	m.end_time = nil
}

// SetBuiltin sets the "builtin" field.
func (m *PerspectiveMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *PerspectiveMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *PerspectiveMutation) ResetBuiltin() {
	m.builtin = nil
}

// SetCostQueries sets the "cost_queries" field.
func (m *PerspectiveMutation) SetCostQueries(tc []types.QueryCondition) {
	m.cost_queries = &tc
	m.appendcost_queries = nil
}

// CostQueries returns the value of the "cost_queries" field in the mutation.
func (m *PerspectiveMutation) CostQueries() (r []types.QueryCondition, exists bool) {
	v := m.cost_queries
	if v == nil {
		return
	}
	return *v, true
}

// OldCostQueries returns the old "cost_queries" field's value of the Perspective entity.
// If the Perspective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerspectiveMutation) OldCostQueries(ctx context.Context) (v []types.QueryCondition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostQueries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostQueries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostQueries: %w", err)
	}
	return oldValue.CostQueries, nil
}

// AppendCostQueries adds tc to the "cost_queries" field.
func (m *PerspectiveMutation) AppendCostQueries(tc []types.QueryCondition) {
	m.appendcost_queries = append(m.appendcost_queries, tc...)
}

// AppendedCostQueries returns the list of values that were appended to the "cost_queries" field in this mutation.
func (m *PerspectiveMutation) AppendedCostQueries() ([]types.QueryCondition, bool) {
	if len(m.appendcost_queries) == 0 {
		return nil, false
	}
	return m.appendcost_queries, true
}

// ResetCostQueries resets all changes to the "cost_queries" field.
func (m *PerspectiveMutation) ResetCostQueries() {
	m.cost_queries = nil
	m.appendcost_queries = nil
}

// Where appends a list predicates to the PerspectiveMutation builder.
func (m *PerspectiveMutation) Where(ps ...predicate.Perspective) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PerspectiveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PerspectiveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Perspective, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PerspectiveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PerspectiveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Perspective).
func (m *PerspectiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PerspectiveMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, perspective.FieldName)
	}
	if m.description != nil {
		fields = append(fields, perspective.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, perspective.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, perspective.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, perspective.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, perspective.FieldUpdateTime)
	}
	if m.start_time != nil {
		fields = append(fields, perspective.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, perspective.FieldEndTime)
	}
	if m.builtin != nil {
		fields = append(fields, perspective.FieldBuiltin)
	}
	if m.cost_queries != nil {
		fields = append(fields, perspective.FieldCostQueries)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PerspectiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case perspective.FieldName:
		return m.Name()
	case perspective.FieldDescription:
		return m.Description()
	case perspective.FieldLabels:
		return m.Labels()
	case perspective.FieldAnnotations:
		return m.Annotations()
	case perspective.FieldCreateTime:
		return m.CreateTime()
	case perspective.FieldUpdateTime:
		return m.UpdateTime()
	case perspective.FieldStartTime:
		return m.StartTime()
	case perspective.FieldEndTime:
		return m.EndTime()
	case perspective.FieldBuiltin:
		return m.Builtin()
	case perspective.FieldCostQueries:
		return m.CostQueries()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PerspectiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case perspective.FieldName:
		return m.OldName(ctx)
	case perspective.FieldDescription:
		return m.OldDescription(ctx)
	case perspective.FieldLabels:
		return m.OldLabels(ctx)
	case perspective.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case perspective.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case perspective.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case perspective.FieldStartTime:
		return m.OldStartTime(ctx)
	case perspective.FieldEndTime:
		return m.OldEndTime(ctx)
	case perspective.FieldBuiltin:
		return m.OldBuiltin(ctx)
	case perspective.FieldCostQueries:
		return m.OldCostQueries(ctx)
	}
	return nil, fmt.Errorf("unknown Perspective field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PerspectiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case perspective.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case perspective.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case perspective.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case perspective.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case perspective.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case perspective.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case perspective.FieldStartTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case perspective.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case perspective.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	case perspective.FieldCostQueries:
		v, ok := value.([]types.QueryCondition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostQueries(v)
		return nil
	}
	return fmt.Errorf("unknown Perspective field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PerspectiveMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PerspectiveMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PerspectiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Perspective numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PerspectiveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(perspective.FieldDescription) {
		fields = append(fields, perspective.FieldDescription)
	}
	if m.FieldCleared(perspective.FieldLabels) {
		fields = append(fields, perspective.FieldLabels)
	}
	if m.FieldCleared(perspective.FieldAnnotations) {
		fields = append(fields, perspective.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PerspectiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PerspectiveMutation) ClearField(name string) error {
	switch name {
	case perspective.FieldDescription:
		m.ClearDescription()
		return nil
	case perspective.FieldLabels:
		m.ClearLabels()
		return nil
	case perspective.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Perspective nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PerspectiveMutation) ResetField(name string) error {
	switch name {
	case perspective.FieldName:
		m.ResetName()
		return nil
	case perspective.FieldDescription:
		m.ResetDescription()
		return nil
	case perspective.FieldLabels:
		m.ResetLabels()
		return nil
	case perspective.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case perspective.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case perspective.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case perspective.FieldStartTime:
		m.ResetStartTime()
		return nil
	case perspective.FieldEndTime:
		m.ResetEndTime()
		return nil
	case perspective.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	case perspective.FieldCostQueries:
		m.ResetCostQueries()
		return nil
	}
	return fmt.Errorf("unknown Perspective field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PerspectiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PerspectiveMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PerspectiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PerspectiveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PerspectiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PerspectiveMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PerspectiveMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Perspective unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PerspectiveMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Perspective edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                               Op
	typ                              string
	id                               *object.ID
	name                             *string
	description                      *string
	labels                           *map[string]string
	annotations                      *map[string]string
	create_time                      *time.Time
	update_time                      *time.Time
	clearedFields                    map[string]struct{}
	environments                     map[object.ID]struct{}
	removedenvironments              map[object.ID]struct{}
	clearedenvironments              bool
	connectors                       map[object.ID]struct{}
	removedconnectors                map[object.ID]struct{}
	clearedconnectors                bool
	subject_roles                    map[object.ID]struct{}
	removedsubject_roles             map[object.ID]struct{}
	clearedsubject_roles             bool
	resources                        map[object.ID]struct{}
	removedresources                 map[object.ID]struct{}
	clearedresources                 bool
	resource_components              map[object.ID]struct{}
	removedresource_components       map[object.ID]struct{}
	clearedresource_components       bool
	resource_revisions               map[object.ID]struct{}
	removedresource_revisions        map[object.ID]struct{}
	clearedresource_revisions        bool
	variables                        map[object.ID]struct{}
	removedvariables                 map[object.ID]struct{}
	clearedvariables                 bool
	templates                        map[object.ID]struct{}
	removedtemplates                 map[object.ID]struct{}
	clearedtemplates                 bool
	template_versions                map[object.ID]struct{}
	removedtemplate_versions         map[object.ID]struct{}
	clearedtemplate_versions         bool
	catalogs                         map[object.ID]struct{}
	removedcatalogs                  map[object.ID]struct{}
	clearedcatalogs                  bool
	workflows                        map[object.ID]struct{}
	removedworkflows                 map[object.ID]struct{}
	clearedworkflows                 bool
	workflow_stages                  map[object.ID]struct{}
	removedworkflow_stages           map[object.ID]struct{}
	clearedworkflow_stages           bool
	workflow_steps                   map[object.ID]struct{}
	removedworkflow_steps            map[object.ID]struct{}
	clearedworkflow_steps            bool
	workflow_executions              map[object.ID]struct{}
	removedworkflow_executions       map[object.ID]struct{}
	clearedworkflow_executions       bool
	workflow_stage_executions        map[object.ID]struct{}
	removedworkflow_stage_executions map[object.ID]struct{}
	clearedworkflow_stage_executions bool
	workflow_step_executions         map[object.ID]struct{}
	removedworkflow_step_executions  map[object.ID]struct{}
	clearedworkflow_step_executions  bool
	done                             bool
	oldValue                         func(context.Context) (*Project, error)
	predicates                       []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id object.ID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ProjectMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ProjectMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ProjectMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[project.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ProjectMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[project.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ProjectMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, project.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ProjectMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ProjectMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ProjectMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[project.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ProjectMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[project.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ProjectMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, project.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *ProjectMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProjectMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProjectMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProjectMutation) ResetUpdateTime() {
	m.update_time = nil
}

// AddEnvironmentIDs adds the "environments" edge to the Environment entity by ids.
func (m *ProjectMutation) AddEnvironmentIDs(ids ...object.ID) {
	if m.environments == nil {
		m.environments = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "environments" edge to the Environment entity.
func (m *ProjectMutation) ClearEnvironments() {
	m.clearedenvironments = true
}

// EnvironmentsCleared reports if the "environments" edge to the Environment entity was cleared.
func (m *ProjectMutation) EnvironmentsCleared() bool {
	return m.clearedenvironments
}

// RemoveEnvironmentIDs removes the "environments" edge to the Environment entity by IDs.
func (m *ProjectMutation) RemoveEnvironmentIDs(ids ...object.ID) {
	if m.removedenvironments == nil {
		m.removedenvironments = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.environments, ids[i])
		m.removedenvironments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "environments" edge to the Environment entity.
func (m *ProjectMutation) RemovedEnvironmentsIDs() (ids []object.ID) {
	for id := range m.removedenvironments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "environments" edge IDs in the mutation.
func (m *ProjectMutation) EnvironmentsIDs() (ids []object.ID) {
	for id := range m.environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "environments" edge.
func (m *ProjectMutation) ResetEnvironments() {
	m.environments = nil
	m.clearedenvironments = false
	m.removedenvironments = nil
}

// AddConnectorIDs adds the "connectors" edge to the Connector entity by ids.
func (m *ProjectMutation) AddConnectorIDs(ids ...object.ID) {
	if m.connectors == nil {
		m.connectors = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.connectors[ids[i]] = struct{}{}
	}
}

// ClearConnectors clears the "connectors" edge to the Connector entity.
func (m *ProjectMutation) ClearConnectors() {
	m.clearedconnectors = true
}

// ConnectorsCleared reports if the "connectors" edge to the Connector entity was cleared.
func (m *ProjectMutation) ConnectorsCleared() bool {
	return m.clearedconnectors
}

// RemoveConnectorIDs removes the "connectors" edge to the Connector entity by IDs.
func (m *ProjectMutation) RemoveConnectorIDs(ids ...object.ID) {
	if m.removedconnectors == nil {
		m.removedconnectors = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.connectors, ids[i])
		m.removedconnectors[ids[i]] = struct{}{}
	}
}

// RemovedConnectors returns the removed IDs of the "connectors" edge to the Connector entity.
func (m *ProjectMutation) RemovedConnectorsIDs() (ids []object.ID) {
	for id := range m.removedconnectors {
		ids = append(ids, id)
	}
	return
}

// ConnectorsIDs returns the "connectors" edge IDs in the mutation.
func (m *ProjectMutation) ConnectorsIDs() (ids []object.ID) {
	for id := range m.connectors {
		ids = append(ids, id)
	}
	return
}

// ResetConnectors resets all changes to the "connectors" edge.
func (m *ProjectMutation) ResetConnectors() {
	m.connectors = nil
	m.clearedconnectors = false
	m.removedconnectors = nil
}

// AddSubjectRoleIDs adds the "subject_roles" edge to the SubjectRoleRelationship entity by ids.
func (m *ProjectMutation) AddSubjectRoleIDs(ids ...object.ID) {
	if m.subject_roles == nil {
		m.subject_roles = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.subject_roles[ids[i]] = struct{}{}
	}
}

// ClearSubjectRoles clears the "subject_roles" edge to the SubjectRoleRelationship entity.
func (m *ProjectMutation) ClearSubjectRoles() {
	m.clearedsubject_roles = true
}

// SubjectRolesCleared reports if the "subject_roles" edge to the SubjectRoleRelationship entity was cleared.
func (m *ProjectMutation) SubjectRolesCleared() bool {
	return m.clearedsubject_roles
}

// RemoveSubjectRoleIDs removes the "subject_roles" edge to the SubjectRoleRelationship entity by IDs.
func (m *ProjectMutation) RemoveSubjectRoleIDs(ids ...object.ID) {
	if m.removedsubject_roles == nil {
		m.removedsubject_roles = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.subject_roles, ids[i])
		m.removedsubject_roles[ids[i]] = struct{}{}
	}
}

// RemovedSubjectRoles returns the removed IDs of the "subject_roles" edge to the SubjectRoleRelationship entity.
func (m *ProjectMutation) RemovedSubjectRolesIDs() (ids []object.ID) {
	for id := range m.removedsubject_roles {
		ids = append(ids, id)
	}
	return
}

// SubjectRolesIDs returns the "subject_roles" edge IDs in the mutation.
func (m *ProjectMutation) SubjectRolesIDs() (ids []object.ID) {
	for id := range m.subject_roles {
		ids = append(ids, id)
	}
	return
}

// ResetSubjectRoles resets all changes to the "subject_roles" edge.
func (m *ProjectMutation) ResetSubjectRoles() {
	m.subject_roles = nil
	m.clearedsubject_roles = false
	m.removedsubject_roles = nil
}

// AddResourceIDs adds the "resources" edge to the Resource entity by ids.
func (m *ProjectMutation) AddResourceIDs(ids ...object.ID) {
	if m.resources == nil {
		m.resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the Resource entity.
func (m *ProjectMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the Resource entity was cleared.
func (m *ProjectMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the Resource entity by IDs.
func (m *ProjectMutation) RemoveResourceIDs(ids ...object.ID) {
	if m.removedresources == nil {
		m.removedresources = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the Resource entity.
func (m *ProjectMutation) RemovedResourcesIDs() (ids []object.ID) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *ProjectMutation) ResourcesIDs() (ids []object.ID) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *ProjectMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddResourceComponentIDs adds the "resource_components" edge to the ResourceComponent entity by ids.
func (m *ProjectMutation) AddResourceComponentIDs(ids ...object.ID) {
	if m.resource_components == nil {
		m.resource_components = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resource_components[ids[i]] = struct{}{}
	}
}

// ClearResourceComponents clears the "resource_components" edge to the ResourceComponent entity.
func (m *ProjectMutation) ClearResourceComponents() {
	m.clearedresource_components = true
}

// ResourceComponentsCleared reports if the "resource_components" edge to the ResourceComponent entity was cleared.
func (m *ProjectMutation) ResourceComponentsCleared() bool {
	return m.clearedresource_components
}

// RemoveResourceComponentIDs removes the "resource_components" edge to the ResourceComponent entity by IDs.
func (m *ProjectMutation) RemoveResourceComponentIDs(ids ...object.ID) {
	if m.removedresource_components == nil {
		m.removedresource_components = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resource_components, ids[i])
		m.removedresource_components[ids[i]] = struct{}{}
	}
}

// RemovedResourceComponents returns the removed IDs of the "resource_components" edge to the ResourceComponent entity.
func (m *ProjectMutation) RemovedResourceComponentsIDs() (ids []object.ID) {
	for id := range m.removedresource_components {
		ids = append(ids, id)
	}
	return
}

// ResourceComponentsIDs returns the "resource_components" edge IDs in the mutation.
func (m *ProjectMutation) ResourceComponentsIDs() (ids []object.ID) {
	for id := range m.resource_components {
		ids = append(ids, id)
	}
	return
}

// ResetResourceComponents resets all changes to the "resource_components" edge.
func (m *ProjectMutation) ResetResourceComponents() {
	m.resource_components = nil
	m.clearedresource_components = false
	m.removedresource_components = nil
}

// AddResourceRevisionIDs adds the "resource_revisions" edge to the ResourceRevision entity by ids.
func (m *ProjectMutation) AddResourceRevisionIDs(ids ...object.ID) {
	if m.resource_revisions == nil {
		m.resource_revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resource_revisions[ids[i]] = struct{}{}
	}
}

// ClearResourceRevisions clears the "resource_revisions" edge to the ResourceRevision entity.
func (m *ProjectMutation) ClearResourceRevisions() {
	m.clearedresource_revisions = true
}

// ResourceRevisionsCleared reports if the "resource_revisions" edge to the ResourceRevision entity was cleared.
func (m *ProjectMutation) ResourceRevisionsCleared() bool {
	return m.clearedresource_revisions
}

// RemoveResourceRevisionIDs removes the "resource_revisions" edge to the ResourceRevision entity by IDs.
func (m *ProjectMutation) RemoveResourceRevisionIDs(ids ...object.ID) {
	if m.removedresource_revisions == nil {
		m.removedresource_revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resource_revisions, ids[i])
		m.removedresource_revisions[ids[i]] = struct{}{}
	}
}

// RemovedResourceRevisions returns the removed IDs of the "resource_revisions" edge to the ResourceRevision entity.
func (m *ProjectMutation) RemovedResourceRevisionsIDs() (ids []object.ID) {
	for id := range m.removedresource_revisions {
		ids = append(ids, id)
	}
	return
}

// ResourceRevisionsIDs returns the "resource_revisions" edge IDs in the mutation.
func (m *ProjectMutation) ResourceRevisionsIDs() (ids []object.ID) {
	for id := range m.resource_revisions {
		ids = append(ids, id)
	}
	return
}

// ResetResourceRevisions resets all changes to the "resource_revisions" edge.
func (m *ProjectMutation) ResetResourceRevisions() {
	m.resource_revisions = nil
	m.clearedresource_revisions = false
	m.removedresource_revisions = nil
}

// AddVariableIDs adds the "variables" edge to the Variable entity by ids.
func (m *ProjectMutation) AddVariableIDs(ids ...object.ID) {
	if m.variables == nil {
		m.variables = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.variables[ids[i]] = struct{}{}
	}
}

// ClearVariables clears the "variables" edge to the Variable entity.
func (m *ProjectMutation) ClearVariables() {
	m.clearedvariables = true
}

// VariablesCleared reports if the "variables" edge to the Variable entity was cleared.
func (m *ProjectMutation) VariablesCleared() bool {
	return m.clearedvariables
}

// RemoveVariableIDs removes the "variables" edge to the Variable entity by IDs.
func (m *ProjectMutation) RemoveVariableIDs(ids ...object.ID) {
	if m.removedvariables == nil {
		m.removedvariables = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.variables, ids[i])
		m.removedvariables[ids[i]] = struct{}{}
	}
}

// RemovedVariables returns the removed IDs of the "variables" edge to the Variable entity.
func (m *ProjectMutation) RemovedVariablesIDs() (ids []object.ID) {
	for id := range m.removedvariables {
		ids = append(ids, id)
	}
	return
}

// VariablesIDs returns the "variables" edge IDs in the mutation.
func (m *ProjectMutation) VariablesIDs() (ids []object.ID) {
	for id := range m.variables {
		ids = append(ids, id)
	}
	return
}

// ResetVariables resets all changes to the "variables" edge.
func (m *ProjectMutation) ResetVariables() {
	m.variables = nil
	m.clearedvariables = false
	m.removedvariables = nil
}

// AddTemplateIDs adds the "templates" edge to the Template entity by ids.
func (m *ProjectMutation) AddTemplateIDs(ids ...object.ID) {
	if m.templates == nil {
		m.templates = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the "templates" edge to the Template entity.
func (m *ProjectMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared reports if the "templates" edge to the Template entity was cleared.
func (m *ProjectMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the "templates" edge to the Template entity by IDs.
func (m *ProjectMutation) RemoveTemplateIDs(ids ...object.ID) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.templates, ids[i])
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed IDs of the "templates" edge to the Template entity.
func (m *ProjectMutation) RemovedTemplatesIDs() (ids []object.ID) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the "templates" edge IDs in the mutation.
func (m *ProjectMutation) TemplatesIDs() (ids []object.ID) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates resets all changes to the "templates" edge.
func (m *ProjectMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// AddTemplateVersionIDs adds the "template_versions" edge to the TemplateVersion entity by ids.
func (m *ProjectMutation) AddTemplateVersionIDs(ids ...object.ID) {
	if m.template_versions == nil {
		m.template_versions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.template_versions[ids[i]] = struct{}{}
	}
}

// ClearTemplateVersions clears the "template_versions" edge to the TemplateVersion entity.
func (m *ProjectMutation) ClearTemplateVersions() {
	m.clearedtemplate_versions = true
}

// TemplateVersionsCleared reports if the "template_versions" edge to the TemplateVersion entity was cleared.
func (m *ProjectMutation) TemplateVersionsCleared() bool {
	return m.clearedtemplate_versions
}

// RemoveTemplateVersionIDs removes the "template_versions" edge to the TemplateVersion entity by IDs.
func (m *ProjectMutation) RemoveTemplateVersionIDs(ids ...object.ID) {
	if m.removedtemplate_versions == nil {
		m.removedtemplate_versions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.template_versions, ids[i])
		m.removedtemplate_versions[ids[i]] = struct{}{}
	}
}

// RemovedTemplateVersions returns the removed IDs of the "template_versions" edge to the TemplateVersion entity.
func (m *ProjectMutation) RemovedTemplateVersionsIDs() (ids []object.ID) {
	for id := range m.removedtemplate_versions {
		ids = append(ids, id)
	}
	return
}

// TemplateVersionsIDs returns the "template_versions" edge IDs in the mutation.
func (m *ProjectMutation) TemplateVersionsIDs() (ids []object.ID) {
	for id := range m.template_versions {
		ids = append(ids, id)
	}
	return
}

// ResetTemplateVersions resets all changes to the "template_versions" edge.
func (m *ProjectMutation) ResetTemplateVersions() {
	m.template_versions = nil
	m.clearedtemplate_versions = false
	m.removedtemplate_versions = nil
}

// AddCatalogIDs adds the "catalogs" edge to the Catalog entity by ids.
func (m *ProjectMutation) AddCatalogIDs(ids ...object.ID) {
	if m.catalogs == nil {
		m.catalogs = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.catalogs[ids[i]] = struct{}{}
	}
}

// ClearCatalogs clears the "catalogs" edge to the Catalog entity.
func (m *ProjectMutation) ClearCatalogs() {
	m.clearedcatalogs = true
}

// CatalogsCleared reports if the "catalogs" edge to the Catalog entity was cleared.
func (m *ProjectMutation) CatalogsCleared() bool {
	return m.clearedcatalogs
}

// RemoveCatalogIDs removes the "catalogs" edge to the Catalog entity by IDs.
func (m *ProjectMutation) RemoveCatalogIDs(ids ...object.ID) {
	if m.removedcatalogs == nil {
		m.removedcatalogs = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.catalogs, ids[i])
		m.removedcatalogs[ids[i]] = struct{}{}
	}
}

// RemovedCatalogs returns the removed IDs of the "catalogs" edge to the Catalog entity.
func (m *ProjectMutation) RemovedCatalogsIDs() (ids []object.ID) {
	for id := range m.removedcatalogs {
		ids = append(ids, id)
	}
	return
}

// CatalogsIDs returns the "catalogs" edge IDs in the mutation.
func (m *ProjectMutation) CatalogsIDs() (ids []object.ID) {
	for id := range m.catalogs {
		ids = append(ids, id)
	}
	return
}

// ResetCatalogs resets all changes to the "catalogs" edge.
func (m *ProjectMutation) ResetCatalogs() {
	m.catalogs = nil
	m.clearedcatalogs = false
	m.removedcatalogs = nil
}

// AddWorkflowIDs adds the "workflows" edge to the Workflow entity by ids.
func (m *ProjectMutation) AddWorkflowIDs(ids ...object.ID) {
	if m.workflows == nil {
		m.workflows = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflow entity.
func (m *ProjectMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflow entity was cleared.
func (m *ProjectMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflow entity by IDs.
func (m *ProjectMutation) RemoveWorkflowIDs(ids ...object.ID) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflow entity.
func (m *ProjectMutation) RemovedWorkflowsIDs() (ids []object.ID) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *ProjectMutation) WorkflowsIDs() (ids []object.ID) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *ProjectMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// AddWorkflowStageIDs adds the "workflow_stages" edge to the WorkflowStage entity by ids.
func (m *ProjectMutation) AddWorkflowStageIDs(ids ...object.ID) {
	if m.workflow_stages == nil {
		m.workflow_stages = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.workflow_stages[ids[i]] = struct{}{}
	}
}

// ClearWorkflowStages clears the "workflow_stages" edge to the WorkflowStage entity.
func (m *ProjectMutation) ClearWorkflowStages() {
	m.clearedworkflow_stages = true
}

// WorkflowStagesCleared reports if the "workflow_stages" edge to the WorkflowStage entity was cleared.
func (m *ProjectMutation) WorkflowStagesCleared() bool {
	return m.clearedworkflow_stages
}

// RemoveWorkflowStageIDs removes the "workflow_stages" edge to the WorkflowStage entity by IDs.
func (m *ProjectMutation) RemoveWorkflowStageIDs(ids ...object.ID) {
	if m.removedworkflow_stages == nil {
		m.removedworkflow_stages = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.workflow_stages, ids[i])
		m.removedworkflow_stages[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowStages returns the removed IDs of the "workflow_stages" edge to the WorkflowStage entity.
func (m *ProjectMutation) RemovedWorkflowStagesIDs() (ids []object.ID) {
	for id := range m.removedworkflow_stages {
		ids = append(ids, id)
	}
	return
}

// WorkflowStagesIDs returns the "workflow_stages" edge IDs in the mutation.
func (m *ProjectMutation) WorkflowStagesIDs() (ids []object.ID) {
	for id := range m.workflow_stages {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowStages resets all changes to the "workflow_stages" edge.
func (m *ProjectMutation) ResetWorkflowStages() {
	m.workflow_stages = nil
	m.clearedworkflow_stages = false
	m.removedworkflow_stages = nil
}

// AddWorkflowStepIDs adds the "workflow_steps" edge to the WorkflowStep entity by ids.
func (m *ProjectMutation) AddWorkflowStepIDs(ids ...object.ID) {
	if m.workflow_steps == nil {
		m.workflow_steps = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.workflow_steps[ids[i]] = struct{}{}
	}
}

// ClearWorkflowSteps clears the "workflow_steps" edge to the WorkflowStep entity.
func (m *ProjectMutation) ClearWorkflowSteps() {
	m.clearedworkflow_steps = true
}

// WorkflowStepsCleared reports if the "workflow_steps" edge to the WorkflowStep entity was cleared.
func (m *ProjectMutation) WorkflowStepsCleared() bool {
	return m.clearedworkflow_steps
}

// RemoveWorkflowStepIDs removes the "workflow_steps" edge to the WorkflowStep entity by IDs.
func (m *ProjectMutation) RemoveWorkflowStepIDs(ids ...object.ID) {
	if m.removedworkflow_steps == nil {
		m.removedworkflow_steps = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.workflow_steps, ids[i])
		m.removedworkflow_steps[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowSteps returns the removed IDs of the "workflow_steps" edge to the WorkflowStep entity.
func (m *ProjectMutation) RemovedWorkflowStepsIDs() (ids []object.ID) {
	for id := range m.removedworkflow_steps {
		ids = append(ids, id)
	}
	return
}

// WorkflowStepsIDs returns the "workflow_steps" edge IDs in the mutation.
func (m *ProjectMutation) WorkflowStepsIDs() (ids []object.ID) {
	for id := range m.workflow_steps {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowSteps resets all changes to the "workflow_steps" edge.
func (m *ProjectMutation) ResetWorkflowSteps() {
	m.workflow_steps = nil
	m.clearedworkflow_steps = false
	m.removedworkflow_steps = nil
}

// AddWorkflowExecutionIDs adds the "workflow_executions" edge to the WorkflowExecution entity by ids.
func (m *ProjectMutation) AddWorkflowExecutionIDs(ids ...object.ID) {
	if m.workflow_executions == nil {
		m.workflow_executions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.workflow_executions[ids[i]] = struct{}{}
	}
}

// ClearWorkflowExecutions clears the "workflow_executions" edge to the WorkflowExecution entity.
func (m *ProjectMutation) ClearWorkflowExecutions() {
	m.clearedworkflow_executions = true
}

// WorkflowExecutionsCleared reports if the "workflow_executions" edge to the WorkflowExecution entity was cleared.
func (m *ProjectMutation) WorkflowExecutionsCleared() bool {
	return m.clearedworkflow_executions
}

// RemoveWorkflowExecutionIDs removes the "workflow_executions" edge to the WorkflowExecution entity by IDs.
func (m *ProjectMutation) RemoveWorkflowExecutionIDs(ids ...object.ID) {
	if m.removedworkflow_executions == nil {
		m.removedworkflow_executions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.workflow_executions, ids[i])
		m.removedworkflow_executions[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowExecutions returns the removed IDs of the "workflow_executions" edge to the WorkflowExecution entity.
func (m *ProjectMutation) RemovedWorkflowExecutionsIDs() (ids []object.ID) {
	for id := range m.removedworkflow_executions {
		ids = append(ids, id)
	}
	return
}

// WorkflowExecutionsIDs returns the "workflow_executions" edge IDs in the mutation.
func (m *ProjectMutation) WorkflowExecutionsIDs() (ids []object.ID) {
	for id := range m.workflow_executions {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowExecutions resets all changes to the "workflow_executions" edge.
func (m *ProjectMutation) ResetWorkflowExecutions() {
	m.workflow_executions = nil
	m.clearedworkflow_executions = false
	m.removedworkflow_executions = nil
}

// AddWorkflowStageExecutionIDs adds the "workflow_stage_executions" edge to the WorkflowStageExecution entity by ids.
func (m *ProjectMutation) AddWorkflowStageExecutionIDs(ids ...object.ID) {
	if m.workflow_stage_executions == nil {
		m.workflow_stage_executions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.workflow_stage_executions[ids[i]] = struct{}{}
	}
}

// ClearWorkflowStageExecutions clears the "workflow_stage_executions" edge to the WorkflowStageExecution entity.
func (m *ProjectMutation) ClearWorkflowStageExecutions() {
	m.clearedworkflow_stage_executions = true
}

// WorkflowStageExecutionsCleared reports if the "workflow_stage_executions" edge to the WorkflowStageExecution entity was cleared.
func (m *ProjectMutation) WorkflowStageExecutionsCleared() bool {
	return m.clearedworkflow_stage_executions
}

// RemoveWorkflowStageExecutionIDs removes the "workflow_stage_executions" edge to the WorkflowStageExecution entity by IDs.
func (m *ProjectMutation) RemoveWorkflowStageExecutionIDs(ids ...object.ID) {
	if m.removedworkflow_stage_executions == nil {
		m.removedworkflow_stage_executions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.workflow_stage_executions, ids[i])
		m.removedworkflow_stage_executions[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowStageExecutions returns the removed IDs of the "workflow_stage_executions" edge to the WorkflowStageExecution entity.
func (m *ProjectMutation) RemovedWorkflowStageExecutionsIDs() (ids []object.ID) {
	for id := range m.removedworkflow_stage_executions {
		ids = append(ids, id)
	}
	return
}

// WorkflowStageExecutionsIDs returns the "workflow_stage_executions" edge IDs in the mutation.
func (m *ProjectMutation) WorkflowStageExecutionsIDs() (ids []object.ID) {
	for id := range m.workflow_stage_executions {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowStageExecutions resets all changes to the "workflow_stage_executions" edge.
func (m *ProjectMutation) ResetWorkflowStageExecutions() {
	m.workflow_stage_executions = nil
	m.clearedworkflow_stage_executions = false
	m.removedworkflow_stage_executions = nil
}

// AddWorkflowStepExecutionIDs adds the "workflow_step_executions" edge to the WorkflowStepExecution entity by ids.
func (m *ProjectMutation) AddWorkflowStepExecutionIDs(ids ...object.ID) {
	if m.workflow_step_executions == nil {
		m.workflow_step_executions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.workflow_step_executions[ids[i]] = struct{}{}
	}
}

// ClearWorkflowStepExecutions clears the "workflow_step_executions" edge to the WorkflowStepExecution entity.
func (m *ProjectMutation) ClearWorkflowStepExecutions() {
	m.clearedworkflow_step_executions = true
}

// WorkflowStepExecutionsCleared reports if the "workflow_step_executions" edge to the WorkflowStepExecution entity was cleared.
func (m *ProjectMutation) WorkflowStepExecutionsCleared() bool {
	return m.clearedworkflow_step_executions
}

// RemoveWorkflowStepExecutionIDs removes the "workflow_step_executions" edge to the WorkflowStepExecution entity by IDs.
func (m *ProjectMutation) RemoveWorkflowStepExecutionIDs(ids ...object.ID) {
	if m.removedworkflow_step_executions == nil {
		m.removedworkflow_step_executions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.workflow_step_executions, ids[i])
		m.removedworkflow_step_executions[ids[i]] = struct{}{}
	}
}

// RemovedWorkflowStepExecutions returns the removed IDs of the "workflow_step_executions" edge to the WorkflowStepExecution entity.
func (m *ProjectMutation) RemovedWorkflowStepExecutionsIDs() (ids []object.ID) {
	for id := range m.removedworkflow_step_executions {
		ids = append(ids, id)
	}
	return
}

// WorkflowStepExecutionsIDs returns the "workflow_step_executions" edge IDs in the mutation.
func (m *ProjectMutation) WorkflowStepExecutionsIDs() (ids []object.ID) {
	for id := range m.workflow_step_executions {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflowStepExecutions resets all changes to the "workflow_step_executions" edge.
func (m *ProjectMutation) ResetWorkflowStepExecutions() {
	m.workflow_step_executions = nil
	m.clearedworkflow_step_executions = false
	m.removedworkflow_step_executions = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, project.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, project.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, project.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, project.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldLabels:
		return m.Labels()
	case project.FieldAnnotations:
		return m.Annotations()
	case project.FieldCreateTime:
		return m.CreateTime()
	case project.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldLabels:
		return m.OldLabels(ctx)
	case project.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case project.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case project.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case project.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case project.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case project.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldLabels) {
		fields = append(fields, project.FieldLabels)
	}
	if m.FieldCleared(project.FieldAnnotations) {
		fields = append(fields, project.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldLabels:
		m.ClearLabels()
		return nil
	case project.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldLabels:
		m.ResetLabels()
		return nil
	case project.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case project.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case project.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.environments != nil {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.connectors != nil {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.subject_roles != nil {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.resources != nil {
		edges = append(edges, project.EdgeResources)
	}
	if m.resource_components != nil {
		edges = append(edges, project.EdgeResourceComponents)
	}
	if m.resource_revisions != nil {
		edges = append(edges, project.EdgeResourceRevisions)
	}
	if m.variables != nil {
		edges = append(edges, project.EdgeVariables)
	}
	if m.templates != nil {
		edges = append(edges, project.EdgeTemplates)
	}
	if m.template_versions != nil {
		edges = append(edges, project.EdgeTemplateVersions)
	}
	if m.catalogs != nil {
		edges = append(edges, project.EdgeCatalogs)
	}
	if m.workflows != nil {
		edges = append(edges, project.EdgeWorkflows)
	}
	if m.workflow_stages != nil {
		edges = append(edges, project.EdgeWorkflowStages)
	}
	if m.workflow_steps != nil {
		edges = append(edges, project.EdgeWorkflowSteps)
	}
	if m.workflow_executions != nil {
		edges = append(edges, project.EdgeWorkflowExecutions)
	}
	if m.workflow_stage_executions != nil {
		edges = append(edges, project.EdgeWorkflowStageExecutions)
	}
	if m.workflow_step_executions != nil {
		edges = append(edges, project.EdgeWorkflowStepExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.environments))
		for id := range m.environments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.connectors))
		for id := range m.connectors {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSubjectRoles:
		ids := make([]ent.Value, 0, len(m.subject_roles))
		for id := range m.subject_roles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeResourceComponents:
		ids := make([]ent.Value, 0, len(m.resource_components))
		for id := range m.resource_components {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeResourceRevisions:
		ids := make([]ent.Value, 0, len(m.resource_revisions))
		for id := range m.resource_revisions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeVariables:
		ids := make([]ent.Value, 0, len(m.variables))
		for id := range m.variables {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplateVersions:
		ids := make([]ent.Value, 0, len(m.template_versions))
		for id := range m.template_versions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCatalogs:
		ids := make([]ent.Value, 0, len(m.catalogs))
		for id := range m.catalogs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowStages:
		ids := make([]ent.Value, 0, len(m.workflow_stages))
		for id := range m.workflow_stages {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowSteps:
		ids := make([]ent.Value, 0, len(m.workflow_steps))
		for id := range m.workflow_steps {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowExecutions:
		ids := make([]ent.Value, 0, len(m.workflow_executions))
		for id := range m.workflow_executions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowStageExecutions:
		ids := make([]ent.Value, 0, len(m.workflow_stage_executions))
		for id := range m.workflow_stage_executions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowStepExecutions:
		ids := make([]ent.Value, 0, len(m.workflow_step_executions))
		for id := range m.workflow_step_executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedenvironments != nil {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.removedconnectors != nil {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.removedsubject_roles != nil {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.removedresources != nil {
		edges = append(edges, project.EdgeResources)
	}
	if m.removedresource_components != nil {
		edges = append(edges, project.EdgeResourceComponents)
	}
	if m.removedresource_revisions != nil {
		edges = append(edges, project.EdgeResourceRevisions)
	}
	if m.removedvariables != nil {
		edges = append(edges, project.EdgeVariables)
	}
	if m.removedtemplates != nil {
		edges = append(edges, project.EdgeTemplates)
	}
	if m.removedtemplate_versions != nil {
		edges = append(edges, project.EdgeTemplateVersions)
	}
	if m.removedcatalogs != nil {
		edges = append(edges, project.EdgeCatalogs)
	}
	if m.removedworkflows != nil {
		edges = append(edges, project.EdgeWorkflows)
	}
	if m.removedworkflow_stages != nil {
		edges = append(edges, project.EdgeWorkflowStages)
	}
	if m.removedworkflow_steps != nil {
		edges = append(edges, project.EdgeWorkflowSteps)
	}
	if m.removedworkflow_executions != nil {
		edges = append(edges, project.EdgeWorkflowExecutions)
	}
	if m.removedworkflow_stage_executions != nil {
		edges = append(edges, project.EdgeWorkflowStageExecutions)
	}
	if m.removedworkflow_step_executions != nil {
		edges = append(edges, project.EdgeWorkflowStepExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removedenvironments))
		for id := range m.removedenvironments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeConnectors:
		ids := make([]ent.Value, 0, len(m.removedconnectors))
		for id := range m.removedconnectors {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSubjectRoles:
		ids := make([]ent.Value, 0, len(m.removedsubject_roles))
		for id := range m.removedsubject_roles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeResourceComponents:
		ids := make([]ent.Value, 0, len(m.removedresource_components))
		for id := range m.removedresource_components {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeResourceRevisions:
		ids := make([]ent.Value, 0, len(m.removedresource_revisions))
		for id := range m.removedresource_revisions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeVariables:
		ids := make([]ent.Value, 0, len(m.removedvariables))
		for id := range m.removedvariables {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTemplateVersions:
		ids := make([]ent.Value, 0, len(m.removedtemplate_versions))
		for id := range m.removedtemplate_versions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCatalogs:
		ids := make([]ent.Value, 0, len(m.removedcatalogs))
		for id := range m.removedcatalogs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowStages:
		ids := make([]ent.Value, 0, len(m.removedworkflow_stages))
		for id := range m.removedworkflow_stages {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowSteps:
		ids := make([]ent.Value, 0, len(m.removedworkflow_steps))
		for id := range m.removedworkflow_steps {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowExecutions:
		ids := make([]ent.Value, 0, len(m.removedworkflow_executions))
		for id := range m.removedworkflow_executions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowStageExecutions:
		ids := make([]ent.Value, 0, len(m.removedworkflow_stage_executions))
		for id := range m.removedworkflow_stage_executions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkflowStepExecutions:
		ids := make([]ent.Value, 0, len(m.removedworkflow_step_executions))
		for id := range m.removedworkflow_step_executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedenvironments {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.clearedconnectors {
		edges = append(edges, project.EdgeConnectors)
	}
	if m.clearedsubject_roles {
		edges = append(edges, project.EdgeSubjectRoles)
	}
	if m.clearedresources {
		edges = append(edges, project.EdgeResources)
	}
	if m.clearedresource_components {
		edges = append(edges, project.EdgeResourceComponents)
	}
	if m.clearedresource_revisions {
		edges = append(edges, project.EdgeResourceRevisions)
	}
	if m.clearedvariables {
		edges = append(edges, project.EdgeVariables)
	}
	if m.clearedtemplates {
		edges = append(edges, project.EdgeTemplates)
	}
	if m.clearedtemplate_versions {
		edges = append(edges, project.EdgeTemplateVersions)
	}
	if m.clearedcatalogs {
		edges = append(edges, project.EdgeCatalogs)
	}
	if m.clearedworkflows {
		edges = append(edges, project.EdgeWorkflows)
	}
	if m.clearedworkflow_stages {
		edges = append(edges, project.EdgeWorkflowStages)
	}
	if m.clearedworkflow_steps {
		edges = append(edges, project.EdgeWorkflowSteps)
	}
	if m.clearedworkflow_executions {
		edges = append(edges, project.EdgeWorkflowExecutions)
	}
	if m.clearedworkflow_stage_executions {
		edges = append(edges, project.EdgeWorkflowStageExecutions)
	}
	if m.clearedworkflow_step_executions {
		edges = append(edges, project.EdgeWorkflowStepExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeEnvironments:
		return m.clearedenvironments
	case project.EdgeConnectors:
		return m.clearedconnectors
	case project.EdgeSubjectRoles:
		return m.clearedsubject_roles
	case project.EdgeResources:
		return m.clearedresources
	case project.EdgeResourceComponents:
		return m.clearedresource_components
	case project.EdgeResourceRevisions:
		return m.clearedresource_revisions
	case project.EdgeVariables:
		return m.clearedvariables
	case project.EdgeTemplates:
		return m.clearedtemplates
	case project.EdgeTemplateVersions:
		return m.clearedtemplate_versions
	case project.EdgeCatalogs:
		return m.clearedcatalogs
	case project.EdgeWorkflows:
		return m.clearedworkflows
	case project.EdgeWorkflowStages:
		return m.clearedworkflow_stages
	case project.EdgeWorkflowSteps:
		return m.clearedworkflow_steps
	case project.EdgeWorkflowExecutions:
		return m.clearedworkflow_executions
	case project.EdgeWorkflowStageExecutions:
		return m.clearedworkflow_stage_executions
	case project.EdgeWorkflowStepExecutions:
		return m.clearedworkflow_step_executions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case project.EdgeConnectors:
		m.ResetConnectors()
		return nil
	case project.EdgeSubjectRoles:
		m.ResetSubjectRoles()
		return nil
	case project.EdgeResources:
		m.ResetResources()
		return nil
	case project.EdgeResourceComponents:
		m.ResetResourceComponents()
		return nil
	case project.EdgeResourceRevisions:
		m.ResetResourceRevisions()
		return nil
	case project.EdgeVariables:
		m.ResetVariables()
		return nil
	case project.EdgeTemplates:
		m.ResetTemplates()
		return nil
	case project.EdgeTemplateVersions:
		m.ResetTemplateVersions()
		return nil
	case project.EdgeCatalogs:
		m.ResetCatalogs()
		return nil
	case project.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	case project.EdgeWorkflowStages:
		m.ResetWorkflowStages()
		return nil
	case project.EdgeWorkflowSteps:
		m.ResetWorkflowSteps()
		return nil
	case project.EdgeWorkflowExecutions:
		m.ResetWorkflowExecutions()
		return nil
	case project.EdgeWorkflowStageExecutions:
		m.ResetWorkflowStageExecutions()
		return nil
	case project.EdgeWorkflowStepExecutions:
		m.ResetWorkflowStepExecutions()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *object.ID
	name                       *string
	description                *string
	labels                     *map[string]string
	annotations                *map[string]string
	create_time                *time.Time
	update_time                *time.Time
	status                     *status.Status
	_type                      *string
	attributes                 *property.Values
	change_comment             *string
	clearedFields              map[string]struct{}
	project                    *object.ID
	clearedproject             bool
	environment                *object.ID
	clearedenvironment         bool
	template                   *object.ID
	clearedtemplate            bool
	resource_definition        *object.ID
	clearedresource_definition bool
	revisions                  map[object.ID]struct{}
	removedrevisions           map[object.ID]struct{}
	clearedrevisions           bool
	components                 map[object.ID]struct{}
	removedcomponents          map[object.ID]struct{}
	clearedcomponents          bool
	dependencies               map[object.ID]struct{}
	removeddependencies        map[object.ID]struct{}
	cleareddependencies        bool
	done                       bool
	oldValue                   func(context.Context) (*Resource, error)
	predicates                 []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id object.ID) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Resource entities.
func (m *ResourceMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ResourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResourceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ResourceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResourceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResourceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resource.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResourceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resource.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResourceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resource.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ResourceMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ResourceMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ResourceMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[resource.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ResourceMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[resource.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ResourceMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, resource.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ResourceMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ResourceMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ResourceMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[resource.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ResourceMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[resource.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ResourceMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, resource.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *ResourceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ResourceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ResourceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ResourceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ResourceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ResourceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *ResourceMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ResourceMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ResourceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[resource.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ResourceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[resource.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ResourceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, resource.FieldStatus)
}

// SetProjectID sets the "project_id" field.
func (m *ResourceMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ResourceMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ResourceMutation) ResetProjectID() {
	m.project = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *ResourceMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *ResourceMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *ResourceMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetTemplateID sets the "template_id" field.
func (m *ResourceMutation) SetTemplateID(o object.ID) {
	m.template = &o
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *ResourceMutation) TemplateID() (r object.ID, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldTemplateID(ctx context.Context) (v *object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *ResourceMutation) ClearTemplateID() {
	m.template = nil
	m.clearedFields[resource.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *ResourceMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[resource.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *ResourceMutation) ResetTemplateID() {
	m.template = nil
	delete(m.clearedFields, resource.FieldTemplateID)
}

// SetType sets the "type" field.
func (m *ResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ResourceMutation) ClearType() {
	m._type = nil
	m.clearedFields[resource.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ResourceMutation) TypeCleared() bool {
	_, ok := m.clearedFields[resource.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ResourceMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, resource.FieldType)
}

// SetResourceDefinitionID sets the "resource_definition_id" field.
func (m *ResourceMutation) SetResourceDefinitionID(o object.ID) {
	m.resource_definition = &o
}

// ResourceDefinitionID returns the value of the "resource_definition_id" field in the mutation.
func (m *ResourceMutation) ResourceDefinitionID() (r object.ID, exists bool) {
	v := m.resource_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceDefinitionID returns the old "resource_definition_id" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldResourceDefinitionID(ctx context.Context) (v *object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceDefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceDefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceDefinitionID: %w", err)
	}
	return oldValue.ResourceDefinitionID, nil
}

// ClearResourceDefinitionID clears the value of the "resource_definition_id" field.
func (m *ResourceMutation) ClearResourceDefinitionID() {
	m.resource_definition = nil
	m.clearedFields[resource.FieldResourceDefinitionID] = struct{}{}
}

// ResourceDefinitionIDCleared returns if the "resource_definition_id" field was cleared in this mutation.
func (m *ResourceMutation) ResourceDefinitionIDCleared() bool {
	_, ok := m.clearedFields[resource.FieldResourceDefinitionID]
	return ok
}

// ResetResourceDefinitionID resets all changes to the "resource_definition_id" field.
func (m *ResourceMutation) ResetResourceDefinitionID() {
	m.resource_definition = nil
	delete(m.clearedFields, resource.FieldResourceDefinitionID)
}

// SetAttributes sets the "attributes" field.
func (m *ResourceMutation) SetAttributes(pr property.Values) {
	m.attributes = &pr
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ResourceMutation) Attributes() (r property.Values, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldAttributes(ctx context.Context) (v property.Values, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ResourceMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[resource.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ResourceMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[resource.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ResourceMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, resource.FieldAttributes)
}

// SetChangeComment sets the "change_comment" field.
func (m *ResourceMutation) SetChangeComment(s string) {
	m.change_comment = &s
}

// ChangeComment returns the value of the "change_comment" field in the mutation.
func (m *ResourceMutation) ChangeComment() (r string, exists bool) {
	v := m.change_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeComment returns the old "change_comment" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldChangeComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeComment: %w", err)
	}
	return oldValue.ChangeComment, nil
}

// ClearChangeComment clears the value of the "change_comment" field.
func (m *ResourceMutation) ClearChangeComment() {
	m.change_comment = nil
	m.clearedFields[resource.FieldChangeComment] = struct{}{}
}

// ChangeCommentCleared returns if the "change_comment" field was cleared in this mutation.
func (m *ResourceMutation) ChangeCommentCleared() bool {
	_, ok := m.clearedFields[resource.FieldChangeComment]
	return ok
}

// ResetChangeComment resets all changes to the "change_comment" field.
func (m *ResourceMutation) ResetChangeComment() {
	m.change_comment = nil
	delete(m.clearedFields, resource.FieldChangeComment)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ResourceMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ResourceMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ResourceMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ResourceMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *ResourceMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *ResourceMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ResourceMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *ResourceMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearTemplate clears the "template" edge to the TemplateVersion entity.
func (m *ResourceMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared reports if the "template" edge to the TemplateVersion entity was cleared.
func (m *ResourceMutation) TemplateCleared() bool {
	return m.TemplateIDCleared() || m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *ResourceMutation) TemplateIDs() (ids []object.ID) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *ResourceMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// ClearResourceDefinition clears the "resource_definition" edge to the ResourceDefinition entity.
func (m *ResourceMutation) ClearResourceDefinition() {
	m.clearedresource_definition = true
}

// ResourceDefinitionCleared reports if the "resource_definition" edge to the ResourceDefinition entity was cleared.
func (m *ResourceMutation) ResourceDefinitionCleared() bool {
	return m.ResourceDefinitionIDCleared() || m.clearedresource_definition
}

// ResourceDefinitionIDs returns the "resource_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceDefinitionID instead. It exists only for internal usage by the builders.
func (m *ResourceMutation) ResourceDefinitionIDs() (ids []object.ID) {
	if id := m.resource_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResourceDefinition resets all changes to the "resource_definition" edge.
func (m *ResourceMutation) ResetResourceDefinition() {
	m.resource_definition = nil
	m.clearedresource_definition = false
}

// AddRevisionIDs adds the "revisions" edge to the ResourceRevision entity by ids.
func (m *ResourceMutation) AddRevisionIDs(ids ...object.ID) {
	if m.revisions == nil {
		m.revisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.revisions[ids[i]] = struct{}{}
	}
}

// ClearRevisions clears the "revisions" edge to the ResourceRevision entity.
func (m *ResourceMutation) ClearRevisions() {
	m.clearedrevisions = true
}

// RevisionsCleared reports if the "revisions" edge to the ResourceRevision entity was cleared.
func (m *ResourceMutation) RevisionsCleared() bool {
	return m.clearedrevisions
}

// RemoveRevisionIDs removes the "revisions" edge to the ResourceRevision entity by IDs.
func (m *ResourceMutation) RemoveRevisionIDs(ids ...object.ID) {
	if m.removedrevisions == nil {
		m.removedrevisions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.revisions, ids[i])
		m.removedrevisions[ids[i]] = struct{}{}
	}
}

// RemovedRevisions returns the removed IDs of the "revisions" edge to the ResourceRevision entity.
func (m *ResourceMutation) RemovedRevisionsIDs() (ids []object.ID) {
	for id := range m.removedrevisions {
		ids = append(ids, id)
	}
	return
}

// RevisionsIDs returns the "revisions" edge IDs in the mutation.
func (m *ResourceMutation) RevisionsIDs() (ids []object.ID) {
	for id := range m.revisions {
		ids = append(ids, id)
	}
	return
}

// ResetRevisions resets all changes to the "revisions" edge.
func (m *ResourceMutation) ResetRevisions() {
	m.revisions = nil
	m.clearedrevisions = false
	m.removedrevisions = nil
}

// AddComponentIDs adds the "components" edge to the ResourceComponent entity by ids.
func (m *ResourceMutation) AddComponentIDs(ids ...object.ID) {
	if m.components == nil {
		m.components = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ResourceComponent entity.
func (m *ResourceMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ResourceComponent entity was cleared.
func (m *ResourceMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ResourceComponent entity by IDs.
func (m *ResourceMutation) RemoveComponentIDs(ids ...object.ID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ResourceComponent entity.
func (m *ResourceMutation) RemovedComponentsIDs() (ids []object.ID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ResourceMutation) ComponentsIDs() (ids []object.ID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ResourceMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddDependencyIDs adds the "dependencies" edge to the ResourceRelationship entity by ids.
func (m *ResourceMutation) AddDependencyIDs(ids ...object.ID) {
	if m.dependencies == nil {
		m.dependencies = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the ResourceRelationship entity.
func (m *ResourceMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the ResourceRelationship entity was cleared.
func (m *ResourceMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the ResourceRelationship entity by IDs.
func (m *ResourceMutation) RemoveDependencyIDs(ids ...object.ID) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the ResourceRelationship entity.
func (m *ResourceMutation) RemovedDependenciesIDs() (ids []object.ID) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ResourceMutation) DependenciesIDs() (ids []object.ID) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ResourceMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, resource.FieldName)
	}
	if m.description != nil {
		fields = append(fields, resource.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, resource.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, resource.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, resource.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, resource.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, resource.FieldStatus)
	}
	if m.project != nil {
		fields = append(fields, resource.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, resource.FieldEnvironmentID)
	}
	if m.template != nil {
		fields = append(fields, resource.FieldTemplateID)
	}
	if m._type != nil {
		fields = append(fields, resource.FieldType)
	}
	if m.resource_definition != nil {
		fields = append(fields, resource.FieldResourceDefinitionID)
	}
	if m.attributes != nil {
		fields = append(fields, resource.FieldAttributes)
	}
	if m.change_comment != nil {
		fields = append(fields, resource.FieldChangeComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldName:
		return m.Name()
	case resource.FieldDescription:
		return m.Description()
	case resource.FieldLabels:
		return m.Labels()
	case resource.FieldAnnotations:
		return m.Annotations()
	case resource.FieldCreateTime:
		return m.CreateTime()
	case resource.FieldUpdateTime:
		return m.UpdateTime()
	case resource.FieldStatus:
		return m.Status()
	case resource.FieldProjectID:
		return m.ProjectID()
	case resource.FieldEnvironmentID:
		return m.EnvironmentID()
	case resource.FieldTemplateID:
		return m.TemplateID()
	case resource.FieldType:
		return m.GetType()
	case resource.FieldResourceDefinitionID:
		return m.ResourceDefinitionID()
	case resource.FieldAttributes:
		return m.Attributes()
	case resource.FieldChangeComment:
		return m.ChangeComment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldName:
		return m.OldName(ctx)
	case resource.FieldDescription:
		return m.OldDescription(ctx)
	case resource.FieldLabels:
		return m.OldLabels(ctx)
	case resource.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case resource.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case resource.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case resource.FieldStatus:
		return m.OldStatus(ctx)
	case resource.FieldProjectID:
		return m.OldProjectID(ctx)
	case resource.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case resource.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case resource.FieldType:
		return m.OldType(ctx)
	case resource.FieldResourceDefinitionID:
		return m.OldResourceDefinitionID(ctx)
	case resource.FieldAttributes:
		return m.OldAttributes(ctx)
	case resource.FieldChangeComment:
		return m.OldChangeComment(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resource.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resource.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case resource.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case resource.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case resource.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case resource.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resource.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case resource.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case resource.FieldTemplateID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case resource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case resource.FieldResourceDefinitionID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceDefinitionID(v)
		return nil
	case resource.FieldAttributes:
		v, ok := value.(property.Values)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case resource.FieldChangeComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeComment(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resource.FieldDescription) {
		fields = append(fields, resource.FieldDescription)
	}
	if m.FieldCleared(resource.FieldLabels) {
		fields = append(fields, resource.FieldLabels)
	}
	if m.FieldCleared(resource.FieldAnnotations) {
		fields = append(fields, resource.FieldAnnotations)
	}
	if m.FieldCleared(resource.FieldStatus) {
		fields = append(fields, resource.FieldStatus)
	}
	if m.FieldCleared(resource.FieldTemplateID) {
		fields = append(fields, resource.FieldTemplateID)
	}
	if m.FieldCleared(resource.FieldType) {
		fields = append(fields, resource.FieldType)
	}
	if m.FieldCleared(resource.FieldResourceDefinitionID) {
		fields = append(fields, resource.FieldResourceDefinitionID)
	}
	if m.FieldCleared(resource.FieldAttributes) {
		fields = append(fields, resource.FieldAttributes)
	}
	if m.FieldCleared(resource.FieldChangeComment) {
		fields = append(fields, resource.FieldChangeComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	switch name {
	case resource.FieldDescription:
		m.ClearDescription()
		return nil
	case resource.FieldLabels:
		m.ClearLabels()
		return nil
	case resource.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case resource.FieldStatus:
		m.ClearStatus()
		return nil
	case resource.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	case resource.FieldType:
		m.ClearType()
		return nil
	case resource.FieldResourceDefinitionID:
		m.ClearResourceDefinitionID()
		return nil
	case resource.FieldAttributes:
		m.ClearAttributes()
		return nil
	case resource.FieldChangeComment:
		m.ClearChangeComment()
		return nil
	}
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldName:
		m.ResetName()
		return nil
	case resource.FieldDescription:
		m.ResetDescription()
		return nil
	case resource.FieldLabels:
		m.ResetLabels()
		return nil
	case resource.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case resource.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case resource.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case resource.FieldStatus:
		m.ResetStatus()
		return nil
	case resource.FieldProjectID:
		m.ResetProjectID()
		return nil
	case resource.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case resource.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case resource.FieldType:
		m.ResetType()
		return nil
	case resource.FieldResourceDefinitionID:
		m.ResetResourceDefinitionID()
		return nil
	case resource.FieldAttributes:
		m.ResetAttributes()
		return nil
	case resource.FieldChangeComment:
		m.ResetChangeComment()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.project != nil {
		edges = append(edges, resource.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, resource.EdgeEnvironment)
	}
	if m.template != nil {
		edges = append(edges, resource.EdgeTemplate)
	}
	if m.resource_definition != nil {
		edges = append(edges, resource.EdgeResourceDefinition)
	}
	if m.revisions != nil {
		edges = append(edges, resource.EdgeRevisions)
	}
	if m.components != nil {
		edges = append(edges, resource.EdgeComponents)
	}
	if m.dependencies != nil {
		edges = append(edges, resource.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case resource.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case resource.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case resource.EdgeResourceDefinition:
		if id := m.resource_definition; id != nil {
			return []ent.Value{*id}
		}
	case resource.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.revisions))
		for id := range m.revisions {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedrevisions != nil {
		edges = append(edges, resource.EdgeRevisions)
	}
	if m.removedcomponents != nil {
		edges = append(edges, resource.EdgeComponents)
	}
	if m.removeddependencies != nil {
		edges = append(edges, resource.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.removedrevisions))
		for id := range m.removedrevisions {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedproject {
		edges = append(edges, resource.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, resource.EdgeEnvironment)
	}
	if m.clearedtemplate {
		edges = append(edges, resource.EdgeTemplate)
	}
	if m.clearedresource_definition {
		edges = append(edges, resource.EdgeResourceDefinition)
	}
	if m.clearedrevisions {
		edges = append(edges, resource.EdgeRevisions)
	}
	if m.clearedcomponents {
		edges = append(edges, resource.EdgeComponents)
	}
	if m.cleareddependencies {
		edges = append(edges, resource.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgeProject:
		return m.clearedproject
	case resource.EdgeEnvironment:
		return m.clearedenvironment
	case resource.EdgeTemplate:
		return m.clearedtemplate
	case resource.EdgeResourceDefinition:
		return m.clearedresource_definition
	case resource.EdgeRevisions:
		return m.clearedrevisions
	case resource.EdgeComponents:
		return m.clearedcomponents
	case resource.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	case resource.EdgeProject:
		m.ClearProject()
		return nil
	case resource.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case resource.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case resource.EdgeResourceDefinition:
		m.ClearResourceDefinition()
		return nil
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgeProject:
		m.ResetProject()
		return nil
	case resource.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case resource.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case resource.EdgeResourceDefinition:
		m.ResetResourceDefinition()
		return nil
	case resource.EdgeRevisions:
		m.ResetRevisions()
		return nil
	case resource.EdgeComponents:
		m.ResetComponents()
		return nil
	case resource.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// ResourceComponentMutation represents an operation that mutates the ResourceComponent nodes in the graph.
type ResourceComponentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *object.ID
	create_time         *time.Time
	update_time         *time.Time
	mode                *string
	_type               *string
	name                *string
	deployer_type       *string
	shape               *string
	status              *types.ResourceComponentStatus
	clearedFields       map[string]struct{}
	project             *object.ID
	clearedproject      bool
	environment         *object.ID
	clearedenvironment  bool
	resource            *object.ID
	clearedresource     bool
	connector           *object.ID
	clearedconnector    bool
	composition         *object.ID
	clearedcomposition  bool
	components          map[object.ID]struct{}
	removedcomponents   map[object.ID]struct{}
	clearedcomponents   bool
	class               *object.ID
	clearedclass        bool
	instances           map[object.ID]struct{}
	removedinstances    map[object.ID]struct{}
	clearedinstances    bool
	dependencies        map[object.ID]struct{}
	removeddependencies map[object.ID]struct{}
	cleareddependencies bool
	done                bool
	oldValue            func(context.Context) (*ResourceComponent, error)
	predicates          []predicate.ResourceComponent
}

var _ ent.Mutation = (*ResourceComponentMutation)(nil)

// resourceComponentOption allows management of the mutation configuration using functional options.
type resourceComponentOption func(*ResourceComponentMutation)

// newResourceComponentMutation creates new mutation for the ResourceComponent entity.
func newResourceComponentMutation(c config, op Op, opts ...resourceComponentOption) *ResourceComponentMutation {
	m := &ResourceComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceComponentID sets the ID field of the mutation.
func withResourceComponentID(id object.ID) resourceComponentOption {
	return func(m *ResourceComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceComponent
		)
		m.oldValue = func(ctx context.Context) (*ResourceComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceComponent sets the old ResourceComponent of the mutation.
func withResourceComponent(node *ResourceComponent) resourceComponentOption {
	return func(m *ResourceComponentMutation) {
		m.oldValue = func(context.Context) (*ResourceComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceComponent entities.
func (m *ResourceComponentMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceComponentMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceComponentMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ResourceComponentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ResourceComponentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ResourceComponentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ResourceComponentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ResourceComponentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ResourceComponentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *ResourceComponentMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ResourceComponentMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ResourceComponentMutation) ResetProjectID() {
	m.project = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *ResourceComponentMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *ResourceComponentMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *ResourceComponentMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceComponentMutation) SetResourceID(o object.ID) {
	m.resource = &o
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceComponentMutation) ResourceID() (r object.ID, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldResourceID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceComponentMutation) ResetResourceID() {
	m.resource = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *ResourceComponentMutation) SetConnectorID(o object.ID) {
	m.connector = &o
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *ResourceComponentMutation) ConnectorID() (r object.ID, exists bool) {
	v := m.connector
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldConnectorID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *ResourceComponentMutation) ResetConnectorID() {
	m.connector = nil
}

// SetCompositionID sets the "composition_id" field.
func (m *ResourceComponentMutation) SetCompositionID(o object.ID) {
	m.composition = &o
}

// CompositionID returns the value of the "composition_id" field in the mutation.
func (m *ResourceComponentMutation) CompositionID() (r object.ID, exists bool) {
	v := m.composition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompositionID returns the old "composition_id" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldCompositionID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompositionID: %w", err)
	}
	return oldValue.CompositionID, nil
}

// ClearCompositionID clears the value of the "composition_id" field.
func (m *ResourceComponentMutation) ClearCompositionID() {
	m.composition = nil
	m.clearedFields[resourcecomponent.FieldCompositionID] = struct{}{}
}

// CompositionIDCleared returns if the "composition_id" field was cleared in this mutation.
func (m *ResourceComponentMutation) CompositionIDCleared() bool {
	_, ok := m.clearedFields[resourcecomponent.FieldCompositionID]
	return ok
}

// ResetCompositionID resets all changes to the "composition_id" field.
func (m *ResourceComponentMutation) ResetCompositionID() {
	m.composition = nil
	delete(m.clearedFields, resourcecomponent.FieldCompositionID)
}

// SetClassID sets the "class_id" field.
func (m *ResourceComponentMutation) SetClassID(o object.ID) {
	m.class = &o
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *ResourceComponentMutation) ClassID() (r object.ID, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldClassID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ClearClassID clears the value of the "class_id" field.
func (m *ResourceComponentMutation) ClearClassID() {
	m.class = nil
	m.clearedFields[resourcecomponent.FieldClassID] = struct{}{}
}

// ClassIDCleared returns if the "class_id" field was cleared in this mutation.
func (m *ResourceComponentMutation) ClassIDCleared() bool {
	_, ok := m.clearedFields[resourcecomponent.FieldClassID]
	return ok
}

// ResetClassID resets all changes to the "class_id" field.
func (m *ResourceComponentMutation) ResetClassID() {
	m.class = nil
	delete(m.clearedFields, resourcecomponent.FieldClassID)
}

// SetMode sets the "mode" field.
func (m *ResourceComponentMutation) SetMode(s string) {
	m.mode = &s
}

// Mode returns the value of the "mode" field in the mutation.
func (m *ResourceComponentMutation) Mode() (r string, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *ResourceComponentMutation) ResetMode() {
	m.mode = nil
}

// SetType sets the "type" field.
func (m *ResourceComponentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceComponentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceComponentMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ResourceComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResourceComponentMutation) ResetName() {
	m.name = nil
}

// SetDeployerType sets the "deployer_type" field.
func (m *ResourceComponentMutation) SetDeployerType(s string) {
	m.deployer_type = &s
}

// DeployerType returns the value of the "deployer_type" field in the mutation.
func (m *ResourceComponentMutation) DeployerType() (r string, exists bool) {
	v := m.deployer_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployerType returns the old "deployer_type" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldDeployerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployerType: %w", err)
	}
	return oldValue.DeployerType, nil
}

// ResetDeployerType resets all changes to the "deployer_type" field.
func (m *ResourceComponentMutation) ResetDeployerType() {
	m.deployer_type = nil
}

// SetShape sets the "shape" field.
func (m *ResourceComponentMutation) SetShape(s string) {
	m.shape = &s
}

// Shape returns the value of the "shape" field in the mutation.
func (m *ResourceComponentMutation) Shape() (r string, exists bool) {
	v := m.shape
	if v == nil {
		return
	}
	return *v, true
}

// OldShape returns the old "shape" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldShape(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShape is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShape requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShape: %w", err)
	}
	return oldValue.Shape, nil
}

// ResetShape resets all changes to the "shape" field.
func (m *ResourceComponentMutation) ResetShape() {
	m.shape = nil
}

// SetStatus sets the "status" field.
func (m *ResourceComponentMutation) SetStatus(tcs types.ResourceComponentStatus) {
	m.status = &tcs
}

// Status returns the value of the "status" field in the mutation.
func (m *ResourceComponentMutation) Status() (r types.ResourceComponentStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ResourceComponent entity.
// If the ResourceComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentMutation) OldStatus(ctx context.Context) (v types.ResourceComponentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ResourceComponentMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[resourcecomponent.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ResourceComponentMutation) StatusCleared() bool {
	_, ok := m.clearedFields[resourcecomponent.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ResourceComponentMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, resourcecomponent.FieldStatus)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ResourceComponentMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ResourceComponentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ResourceComponentMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ResourceComponentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *ResourceComponentMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *ResourceComponentMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ResourceComponentMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *ResourceComponentMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *ResourceComponentMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *ResourceComponentMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *ResourceComponentMutation) ResourceIDs() (ids []object.ID) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *ResourceComponentMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *ResourceComponentMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *ResourceComponentMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *ResourceComponentMutation) ConnectorIDs() (ids []object.ID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *ResourceComponentMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// ClearComposition clears the "composition" edge to the ResourceComponent entity.
func (m *ResourceComponentMutation) ClearComposition() {
	m.clearedcomposition = true
}

// CompositionCleared reports if the "composition" edge to the ResourceComponent entity was cleared.
func (m *ResourceComponentMutation) CompositionCleared() bool {
	return m.CompositionIDCleared() || m.clearedcomposition
}

// CompositionIDs returns the "composition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompositionID instead. It exists only for internal usage by the builders.
func (m *ResourceComponentMutation) CompositionIDs() (ids []object.ID) {
	if id := m.composition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComposition resets all changes to the "composition" edge.
func (m *ResourceComponentMutation) ResetComposition() {
	m.composition = nil
	m.clearedcomposition = false
}

// AddComponentIDs adds the "components" edge to the ResourceComponent entity by ids.
func (m *ResourceComponentMutation) AddComponentIDs(ids ...object.ID) {
	if m.components == nil {
		m.components = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ResourceComponent entity.
func (m *ResourceComponentMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ResourceComponent entity was cleared.
func (m *ResourceComponentMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ResourceComponent entity by IDs.
func (m *ResourceComponentMutation) RemoveComponentIDs(ids ...object.ID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ResourceComponent entity.
func (m *ResourceComponentMutation) RemovedComponentsIDs() (ids []object.ID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ResourceComponentMutation) ComponentsIDs() (ids []object.ID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ResourceComponentMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// ClearClass clears the "class" edge to the ResourceComponent entity.
func (m *ResourceComponentMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the ResourceComponent entity was cleared.
func (m *ResourceComponentMutation) ClassCleared() bool {
	return m.ClassIDCleared() || m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ResourceComponentMutation) ClassIDs() (ids []object.ID) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ResourceComponentMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// AddInstanceIDs adds the "instances" edge to the ResourceComponent entity by ids.
func (m *ResourceComponentMutation) AddInstanceIDs(ids ...object.ID) {
	if m.instances == nil {
		m.instances = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the ResourceComponent entity.
func (m *ResourceComponentMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the ResourceComponent entity was cleared.
func (m *ResourceComponentMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the ResourceComponent entity by IDs.
func (m *ResourceComponentMutation) RemoveInstanceIDs(ids ...object.ID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the ResourceComponent entity.
func (m *ResourceComponentMutation) RemovedInstancesIDs() (ids []object.ID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *ResourceComponentMutation) InstancesIDs() (ids []object.ID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *ResourceComponentMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// AddDependencyIDs adds the "dependencies" edge to the ResourceComponentRelationship entity by ids.
func (m *ResourceComponentMutation) AddDependencyIDs(ids ...object.ID) {
	if m.dependencies == nil {
		m.dependencies = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the ResourceComponentRelationship entity.
func (m *ResourceComponentMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the ResourceComponentRelationship entity was cleared.
func (m *ResourceComponentMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the ResourceComponentRelationship entity by IDs.
func (m *ResourceComponentMutation) RemoveDependencyIDs(ids ...object.ID) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the ResourceComponentRelationship entity.
func (m *ResourceComponentMutation) RemovedDependenciesIDs() (ids []object.ID) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ResourceComponentMutation) DependenciesIDs() (ids []object.ID) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ResourceComponentMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// Where appends a list predicates to the ResourceComponentMutation builder.
func (m *ResourceComponentMutation) Where(ps ...predicate.ResourceComponent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceComponent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceComponent).
func (m *ResourceComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceComponentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, resourcecomponent.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, resourcecomponent.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, resourcecomponent.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, resourcecomponent.FieldEnvironmentID)
	}
	if m.resource != nil {
		fields = append(fields, resourcecomponent.FieldResourceID)
	}
	if m.connector != nil {
		fields = append(fields, resourcecomponent.FieldConnectorID)
	}
	if m.composition != nil {
		fields = append(fields, resourcecomponent.FieldCompositionID)
	}
	if m.class != nil {
		fields = append(fields, resourcecomponent.FieldClassID)
	}
	if m.mode != nil {
		fields = append(fields, resourcecomponent.FieldMode)
	}
	if m._type != nil {
		fields = append(fields, resourcecomponent.FieldType)
	}
	if m.name != nil {
		fields = append(fields, resourcecomponent.FieldName)
	}
	if m.deployer_type != nil {
		fields = append(fields, resourcecomponent.FieldDeployerType)
	}
	if m.shape != nil {
		fields = append(fields, resourcecomponent.FieldShape)
	}
	if m.status != nil {
		fields = append(fields, resourcecomponent.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcecomponent.FieldCreateTime:
		return m.CreateTime()
	case resourcecomponent.FieldUpdateTime:
		return m.UpdateTime()
	case resourcecomponent.FieldProjectID:
		return m.ProjectID()
	case resourcecomponent.FieldEnvironmentID:
		return m.EnvironmentID()
	case resourcecomponent.FieldResourceID:
		return m.ResourceID()
	case resourcecomponent.FieldConnectorID:
		return m.ConnectorID()
	case resourcecomponent.FieldCompositionID:
		return m.CompositionID()
	case resourcecomponent.FieldClassID:
		return m.ClassID()
	case resourcecomponent.FieldMode:
		return m.Mode()
	case resourcecomponent.FieldType:
		return m.GetType()
	case resourcecomponent.FieldName:
		return m.Name()
	case resourcecomponent.FieldDeployerType:
		return m.DeployerType()
	case resourcecomponent.FieldShape:
		return m.Shape()
	case resourcecomponent.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcecomponent.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case resourcecomponent.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case resourcecomponent.FieldProjectID:
		return m.OldProjectID(ctx)
	case resourcecomponent.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case resourcecomponent.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourcecomponent.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case resourcecomponent.FieldCompositionID:
		return m.OldCompositionID(ctx)
	case resourcecomponent.FieldClassID:
		return m.OldClassID(ctx)
	case resourcecomponent.FieldMode:
		return m.OldMode(ctx)
	case resourcecomponent.FieldType:
		return m.OldType(ctx)
	case resourcecomponent.FieldName:
		return m.OldName(ctx)
	case resourcecomponent.FieldDeployerType:
		return m.OldDeployerType(ctx)
	case resourcecomponent.FieldShape:
		return m.OldShape(ctx)
	case resourcecomponent.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcecomponent.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case resourcecomponent.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case resourcecomponent.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case resourcecomponent.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case resourcecomponent.FieldResourceID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourcecomponent.FieldConnectorID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case resourcecomponent.FieldCompositionID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompositionID(v)
		return nil
	case resourcecomponent.FieldClassID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	case resourcecomponent.FieldMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case resourcecomponent.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case resourcecomponent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resourcecomponent.FieldDeployerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployerType(v)
		return nil
	case resourcecomponent.FieldShape:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShape(v)
		return nil
	case resourcecomponent.FieldStatus:
		v, ok := value.(types.ResourceComponentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourcecomponent.FieldCompositionID) {
		fields = append(fields, resourcecomponent.FieldCompositionID)
	}
	if m.FieldCleared(resourcecomponent.FieldClassID) {
		fields = append(fields, resourcecomponent.FieldClassID)
	}
	if m.FieldCleared(resourcecomponent.FieldStatus) {
		fields = append(fields, resourcecomponent.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceComponentMutation) ClearField(name string) error {
	switch name {
	case resourcecomponent.FieldCompositionID:
		m.ClearCompositionID()
		return nil
	case resourcecomponent.FieldClassID:
		m.ClearClassID()
		return nil
	case resourcecomponent.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown ResourceComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceComponentMutation) ResetField(name string) error {
	switch name {
	case resourcecomponent.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case resourcecomponent.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case resourcecomponent.FieldProjectID:
		m.ResetProjectID()
		return nil
	case resourcecomponent.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case resourcecomponent.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourcecomponent.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case resourcecomponent.FieldCompositionID:
		m.ResetCompositionID()
		return nil
	case resourcecomponent.FieldClassID:
		m.ResetClassID()
		return nil
	case resourcecomponent.FieldMode:
		m.ResetMode()
		return nil
	case resourcecomponent.FieldType:
		m.ResetType()
		return nil
	case resourcecomponent.FieldName:
		m.ResetName()
		return nil
	case resourcecomponent.FieldDeployerType:
		m.ResetDeployerType()
		return nil
	case resourcecomponent.FieldShape:
		m.ResetShape()
		return nil
	case resourcecomponent.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ResourceComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.project != nil {
		edges = append(edges, resourcecomponent.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, resourcecomponent.EdgeEnvironment)
	}
	if m.resource != nil {
		edges = append(edges, resourcecomponent.EdgeResource)
	}
	if m.connector != nil {
		edges = append(edges, resourcecomponent.EdgeConnector)
	}
	if m.composition != nil {
		edges = append(edges, resourcecomponent.EdgeComposition)
	}
	if m.components != nil {
		edges = append(edges, resourcecomponent.EdgeComponents)
	}
	if m.class != nil {
		edges = append(edges, resourcecomponent.EdgeClass)
	}
	if m.instances != nil {
		edges = append(edges, resourcecomponent.EdgeInstances)
	}
	if m.dependencies != nil {
		edges = append(edges, resourcecomponent.EdgeDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourcecomponent.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case resourcecomponent.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case resourcecomponent.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	case resourcecomponent.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	case resourcecomponent.EdgeComposition:
		if id := m.composition; id != nil {
			return []ent.Value{*id}
		}
	case resourcecomponent.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case resourcecomponent.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case resourcecomponent.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case resourcecomponent.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedcomponents != nil {
		edges = append(edges, resourcecomponent.EdgeComponents)
	}
	if m.removedinstances != nil {
		edges = append(edges, resourcecomponent.EdgeInstances)
	}
	if m.removeddependencies != nil {
		edges = append(edges, resourcecomponent.EdgeDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resourcecomponent.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case resourcecomponent.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case resourcecomponent.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedproject {
		edges = append(edges, resourcecomponent.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, resourcecomponent.EdgeEnvironment)
	}
	if m.clearedresource {
		edges = append(edges, resourcecomponent.EdgeResource)
	}
	if m.clearedconnector {
		edges = append(edges, resourcecomponent.EdgeConnector)
	}
	if m.clearedcomposition {
		edges = append(edges, resourcecomponent.EdgeComposition)
	}
	if m.clearedcomponents {
		edges = append(edges, resourcecomponent.EdgeComponents)
	}
	if m.clearedclass {
		edges = append(edges, resourcecomponent.EdgeClass)
	}
	if m.clearedinstances {
		edges = append(edges, resourcecomponent.EdgeInstances)
	}
	if m.cleareddependencies {
		edges = append(edges, resourcecomponent.EdgeDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case resourcecomponent.EdgeProject:
		return m.clearedproject
	case resourcecomponent.EdgeEnvironment:
		return m.clearedenvironment
	case resourcecomponent.EdgeResource:
		return m.clearedresource
	case resourcecomponent.EdgeConnector:
		return m.clearedconnector
	case resourcecomponent.EdgeComposition:
		return m.clearedcomposition
	case resourcecomponent.EdgeComponents:
		return m.clearedcomponents
	case resourcecomponent.EdgeClass:
		return m.clearedclass
	case resourcecomponent.EdgeInstances:
		return m.clearedinstances
	case resourcecomponent.EdgeDependencies:
		return m.cleareddependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceComponentMutation) ClearEdge(name string) error {
	switch name {
	case resourcecomponent.EdgeProject:
		m.ClearProject()
		return nil
	case resourcecomponent.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case resourcecomponent.EdgeResource:
		m.ClearResource()
		return nil
	case resourcecomponent.EdgeConnector:
		m.ClearConnector()
		return nil
	case resourcecomponent.EdgeComposition:
		m.ClearComposition()
		return nil
	case resourcecomponent.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown ResourceComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceComponentMutation) ResetEdge(name string) error {
	switch name {
	case resourcecomponent.EdgeProject:
		m.ResetProject()
		return nil
	case resourcecomponent.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case resourcecomponent.EdgeResource:
		m.ResetResource()
		return nil
	case resourcecomponent.EdgeConnector:
		m.ResetConnector()
		return nil
	case resourcecomponent.EdgeComposition:
		m.ResetComposition()
		return nil
	case resourcecomponent.EdgeComponents:
		m.ResetComponents()
		return nil
	case resourcecomponent.EdgeClass:
		m.ResetClass()
		return nil
	case resourcecomponent.EdgeInstances:
		m.ResetInstances()
		return nil
	case resourcecomponent.EdgeDependencies:
		m.ResetDependencies()
		return nil
	}
	return fmt.Errorf("unknown ResourceComponent edge %s", name)
}

// ResourceComponentRelationshipMutation represents an operation that mutates the ResourceComponentRelationship nodes in the graph.
type ResourceComponentRelationshipMutation struct {
	config
	op                        Op
	typ                       string
	id                        *object.ID
	create_time               *time.Time
	_type                     *string
	clearedFields             map[string]struct{}
	resource_component        *object.ID
	clearedresource_component bool
	dependency                *object.ID
	cleareddependency         bool
	done                      bool
	oldValue                  func(context.Context) (*ResourceComponentRelationship, error)
	predicates                []predicate.ResourceComponentRelationship
}

var _ ent.Mutation = (*ResourceComponentRelationshipMutation)(nil)

// resourceComponentRelationshipOption allows management of the mutation configuration using functional options.
type resourceComponentRelationshipOption func(*ResourceComponentRelationshipMutation)

// newResourceComponentRelationshipMutation creates new mutation for the ResourceComponentRelationship entity.
func newResourceComponentRelationshipMutation(c config, op Op, opts ...resourceComponentRelationshipOption) *ResourceComponentRelationshipMutation {
	m := &ResourceComponentRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceComponentRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceComponentRelationshipID sets the ID field of the mutation.
func withResourceComponentRelationshipID(id object.ID) resourceComponentRelationshipOption {
	return func(m *ResourceComponentRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceComponentRelationship
		)
		m.oldValue = func(ctx context.Context) (*ResourceComponentRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceComponentRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceComponentRelationship sets the old ResourceComponentRelationship of the mutation.
func withResourceComponentRelationship(node *ResourceComponentRelationship) resourceComponentRelationshipOption {
	return func(m *ResourceComponentRelationshipMutation) {
		m.oldValue = func(context.Context) (*ResourceComponentRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceComponentRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceComponentRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceComponentRelationship entities.
func (m *ResourceComponentRelationshipMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceComponentRelationshipMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceComponentRelationshipMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceComponentRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ResourceComponentRelationshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ResourceComponentRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ResourceComponentRelationship entity.
// If the ResourceComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ResourceComponentRelationshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetResourceComponentID sets the "resource_component_id" field.
func (m *ResourceComponentRelationshipMutation) SetResourceComponentID(o object.ID) {
	m.resource_component = &o
}

// ResourceComponentID returns the value of the "resource_component_id" field in the mutation.
func (m *ResourceComponentRelationshipMutation) ResourceComponentID() (r object.ID, exists bool) {
	v := m.resource_component
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceComponentID returns the old "resource_component_id" field's value of the ResourceComponentRelationship entity.
// If the ResourceComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentRelationshipMutation) OldResourceComponentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceComponentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceComponentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceComponentID: %w", err)
	}
	return oldValue.ResourceComponentID, nil
}

// ResetResourceComponentID resets all changes to the "resource_component_id" field.
func (m *ResourceComponentRelationshipMutation) ResetResourceComponentID() {
	m.resource_component = nil
}

// SetDependencyID sets the "dependency_id" field.
func (m *ResourceComponentRelationshipMutation) SetDependencyID(o object.ID) {
	m.dependency = &o
}

// DependencyID returns the value of the "dependency_id" field in the mutation.
func (m *ResourceComponentRelationshipMutation) DependencyID() (r object.ID, exists bool) {
	v := m.dependency
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyID returns the old "dependency_id" field's value of the ResourceComponentRelationship entity.
// If the ResourceComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentRelationshipMutation) OldDependencyID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyID: %w", err)
	}
	return oldValue.DependencyID, nil
}

// ResetDependencyID resets all changes to the "dependency_id" field.
func (m *ResourceComponentRelationshipMutation) ResetDependencyID() {
	m.dependency = nil
}

// SetType sets the "type" field.
func (m *ResourceComponentRelationshipMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceComponentRelationshipMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ResourceComponentRelationship entity.
// If the ResourceComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceComponentRelationshipMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceComponentRelationshipMutation) ResetType() {
	m._type = nil
}

// ClearResourceComponent clears the "resource_component" edge to the ResourceComponent entity.
func (m *ResourceComponentRelationshipMutation) ClearResourceComponent() {
	m.clearedresource_component = true
}

// ResourceComponentCleared reports if the "resource_component" edge to the ResourceComponent entity was cleared.
func (m *ResourceComponentRelationshipMutation) ResourceComponentCleared() bool {
	return m.clearedresource_component
}

// ResourceComponentIDs returns the "resource_component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceComponentID instead. It exists only for internal usage by the builders.
func (m *ResourceComponentRelationshipMutation) ResourceComponentIDs() (ids []object.ID) {
	if id := m.resource_component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResourceComponent resets all changes to the "resource_component" edge.
func (m *ResourceComponentRelationshipMutation) ResetResourceComponent() {
	m.resource_component = nil
	m.clearedresource_component = false
}

// ClearDependency clears the "dependency" edge to the ResourceComponent entity.
func (m *ResourceComponentRelationshipMutation) ClearDependency() {
	m.cleareddependency = true
}

// DependencyCleared reports if the "dependency" edge to the ResourceComponent entity was cleared.
func (m *ResourceComponentRelationshipMutation) DependencyCleared() bool {
	return m.cleareddependency
}

// DependencyIDs returns the "dependency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependencyID instead. It exists only for internal usage by the builders.
func (m *ResourceComponentRelationshipMutation) DependencyIDs() (ids []object.ID) {
	if id := m.dependency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependency resets all changes to the "dependency" edge.
func (m *ResourceComponentRelationshipMutation) ResetDependency() {
	m.dependency = nil
	m.cleareddependency = false
}

// Where appends a list predicates to the ResourceComponentRelationshipMutation builder.
func (m *ResourceComponentRelationshipMutation) Where(ps ...predicate.ResourceComponentRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceComponentRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceComponentRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceComponentRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceComponentRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceComponentRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceComponentRelationship).
func (m *ResourceComponentRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceComponentRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, resourcecomponentrelationship.FieldCreateTime)
	}
	if m.resource_component != nil {
		fields = append(fields, resourcecomponentrelationship.FieldResourceComponentID)
	}
	if m.dependency != nil {
		fields = append(fields, resourcecomponentrelationship.FieldDependencyID)
	}
	if m._type != nil {
		fields = append(fields, resourcecomponentrelationship.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceComponentRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcecomponentrelationship.FieldCreateTime:
		return m.CreateTime()
	case resourcecomponentrelationship.FieldResourceComponentID:
		return m.ResourceComponentID()
	case resourcecomponentrelationship.FieldDependencyID:
		return m.DependencyID()
	case resourcecomponentrelationship.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceComponentRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcecomponentrelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case resourcecomponentrelationship.FieldResourceComponentID:
		return m.OldResourceComponentID(ctx)
	case resourcecomponentrelationship.FieldDependencyID:
		return m.OldDependencyID(ctx)
	case resourcecomponentrelationship.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceComponentRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceComponentRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcecomponentrelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case resourcecomponentrelationship.FieldResourceComponentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceComponentID(v)
		return nil
	case resourcecomponentrelationship.FieldDependencyID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyID(v)
		return nil
	case resourcecomponentrelationship.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceComponentRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceComponentRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceComponentRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceComponentRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceComponentRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceComponentRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceComponentRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceComponentRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResourceComponentRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceComponentRelationshipMutation) ResetField(name string) error {
	switch name {
	case resourcecomponentrelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case resourcecomponentrelationship.FieldResourceComponentID:
		m.ResetResourceComponentID()
		return nil
	case resourcecomponentrelationship.FieldDependencyID:
		m.ResetDependencyID()
		return nil
	case resourcecomponentrelationship.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ResourceComponentRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceComponentRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.resource_component != nil {
		edges = append(edges, resourcecomponentrelationship.EdgeResourceComponent)
	}
	if m.dependency != nil {
		edges = append(edges, resourcecomponentrelationship.EdgeDependency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceComponentRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourcecomponentrelationship.EdgeResourceComponent:
		if id := m.resource_component; id != nil {
			return []ent.Value{*id}
		}
	case resourcecomponentrelationship.EdgeDependency:
		if id := m.dependency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceComponentRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceComponentRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceComponentRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresource_component {
		edges = append(edges, resourcecomponentrelationship.EdgeResourceComponent)
	}
	if m.cleareddependency {
		edges = append(edges, resourcecomponentrelationship.EdgeDependency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceComponentRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case resourcecomponentrelationship.EdgeResourceComponent:
		return m.clearedresource_component
	case resourcecomponentrelationship.EdgeDependency:
		return m.cleareddependency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceComponentRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case resourcecomponentrelationship.EdgeResourceComponent:
		m.ClearResourceComponent()
		return nil
	case resourcecomponentrelationship.EdgeDependency:
		m.ClearDependency()
		return nil
	}
	return fmt.Errorf("unknown ResourceComponentRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceComponentRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case resourcecomponentrelationship.EdgeResourceComponent:
		m.ResetResourceComponent()
		return nil
	case resourcecomponentrelationship.EdgeDependency:
		m.ResetDependency()
		return nil
	}
	return fmt.Errorf("unknown ResourceComponentRelationship edge %s", name)
}

// ResourceDefinitionMutation represents an operation that mutates the ResourceDefinition nodes in the graph.
type ResourceDefinitionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *object.ID
	name                  *string
	description           *string
	labels                *map[string]string
	annotations           *map[string]string
	create_time           *time.Time
	update_time           *time.Time
	_type                 *string
	schema                *types.Schema
	uiSchema              **types.UISchema
	clearedFields         map[string]struct{}
	matching_rules        map[object.ID]struct{}
	removedmatching_rules map[object.ID]struct{}
	clearedmatching_rules bool
	resources             map[object.ID]struct{}
	removedresources      map[object.ID]struct{}
	clearedresources      bool
	done                  bool
	oldValue              func(context.Context) (*ResourceDefinition, error)
	predicates            []predicate.ResourceDefinition
}

var _ ent.Mutation = (*ResourceDefinitionMutation)(nil)

// resourceDefinitionOption allows management of the mutation configuration using functional options.
type resourceDefinitionOption func(*ResourceDefinitionMutation)

// newResourceDefinitionMutation creates new mutation for the ResourceDefinition entity.
func newResourceDefinitionMutation(c config, op Op, opts ...resourceDefinitionOption) *ResourceDefinitionMutation {
	m := &ResourceDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceDefinitionID sets the ID field of the mutation.
func withResourceDefinitionID(id object.ID) resourceDefinitionOption {
	return func(m *ResourceDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceDefinition
		)
		m.oldValue = func(ctx context.Context) (*ResourceDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceDefinition sets the old ResourceDefinition of the mutation.
func withResourceDefinition(node *ResourceDefinition) resourceDefinitionOption {
	return func(m *ResourceDefinitionMutation) {
		m.oldValue = func(context.Context) (*ResourceDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceDefinition entities.
func (m *ResourceDefinitionMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceDefinitionMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceDefinitionMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ResourceDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResourceDefinitionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ResourceDefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResourceDefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResourceDefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resourcedefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResourceDefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resourcedefinition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResourceDefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resourcedefinition.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *ResourceDefinitionMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ResourceDefinitionMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ResourceDefinitionMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[resourcedefinition.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ResourceDefinitionMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[resourcedefinition.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ResourceDefinitionMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, resourcedefinition.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *ResourceDefinitionMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *ResourceDefinitionMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *ResourceDefinitionMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[resourcedefinition.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *ResourceDefinitionMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[resourcedefinition.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *ResourceDefinitionMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, resourcedefinition.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *ResourceDefinitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ResourceDefinitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ResourceDefinitionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ResourceDefinitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ResourceDefinitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ResourceDefinitionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *ResourceDefinitionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceDefinitionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceDefinitionMutation) ResetType() {
	m._type = nil
}

// SetSchema sets the "schema" field.
func (m *ResourceDefinitionMutation) SetSchema(t types.Schema) {
	m.schema = &t
}

// Schema returns the value of the "schema" field in the mutation.
func (m *ResourceDefinitionMutation) Schema() (r types.Schema, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchema returns the old "schema" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldSchema(ctx context.Context) (v types.Schema, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchema: %w", err)
	}
	return oldValue.Schema, nil
}

// ResetSchema resets all changes to the "schema" field.
func (m *ResourceDefinitionMutation) ResetSchema() {
	m.schema = nil
}

// SetUiSchema sets the "uiSchema" field.
func (m *ResourceDefinitionMutation) SetUiSchema(ts *types.UISchema) {
	m.uiSchema = &ts
}

// UiSchema returns the value of the "uiSchema" field in the mutation.
func (m *ResourceDefinitionMutation) UiSchema() (r *types.UISchema, exists bool) {
	v := m.uiSchema
	if v == nil {
		return
	}
	return *v, true
}

// OldUiSchema returns the old "uiSchema" field's value of the ResourceDefinition entity.
// If the ResourceDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMutation) OldUiSchema(ctx context.Context) (v *types.UISchema, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUiSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUiSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUiSchema: %w", err)
	}
	return oldValue.UiSchema, nil
}

// ClearUiSchema clears the value of the "uiSchema" field.
func (m *ResourceDefinitionMutation) ClearUiSchema() {
	m.uiSchema = nil
	m.clearedFields[resourcedefinition.FieldUiSchema] = struct{}{}
}

// UiSchemaCleared returns if the "uiSchema" field was cleared in this mutation.
func (m *ResourceDefinitionMutation) UiSchemaCleared() bool {
	_, ok := m.clearedFields[resourcedefinition.FieldUiSchema]
	return ok
}

// ResetUiSchema resets all changes to the "uiSchema" field.
func (m *ResourceDefinitionMutation) ResetUiSchema() {
	m.uiSchema = nil
	delete(m.clearedFields, resourcedefinition.FieldUiSchema)
}

// AddMatchingRuleIDs adds the "matching_rules" edge to the ResourceDefinitionMatchingRule entity by ids.
func (m *ResourceDefinitionMutation) AddMatchingRuleIDs(ids ...object.ID) {
	if m.matching_rules == nil {
		m.matching_rules = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.matching_rules[ids[i]] = struct{}{}
	}
}

// ClearMatchingRules clears the "matching_rules" edge to the ResourceDefinitionMatchingRule entity.
func (m *ResourceDefinitionMutation) ClearMatchingRules() {
	m.clearedmatching_rules = true
}

// MatchingRulesCleared reports if the "matching_rules" edge to the ResourceDefinitionMatchingRule entity was cleared.
func (m *ResourceDefinitionMutation) MatchingRulesCleared() bool {
	return m.clearedmatching_rules
}

// RemoveMatchingRuleIDs removes the "matching_rules" edge to the ResourceDefinitionMatchingRule entity by IDs.
func (m *ResourceDefinitionMutation) RemoveMatchingRuleIDs(ids ...object.ID) {
	if m.removedmatching_rules == nil {
		m.removedmatching_rules = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.matching_rules, ids[i])
		m.removedmatching_rules[ids[i]] = struct{}{}
	}
}

// RemovedMatchingRules returns the removed IDs of the "matching_rules" edge to the ResourceDefinitionMatchingRule entity.
func (m *ResourceDefinitionMutation) RemovedMatchingRulesIDs() (ids []object.ID) {
	for id := range m.removedmatching_rules {
		ids = append(ids, id)
	}
	return
}

// MatchingRulesIDs returns the "matching_rules" edge IDs in the mutation.
func (m *ResourceDefinitionMutation) MatchingRulesIDs() (ids []object.ID) {
	for id := range m.matching_rules {
		ids = append(ids, id)
	}
	return
}

// ResetMatchingRules resets all changes to the "matching_rules" edge.
func (m *ResourceDefinitionMutation) ResetMatchingRules() {
	m.matching_rules = nil
	m.clearedmatching_rules = false
	m.removedmatching_rules = nil
}

// AddResourceIDs adds the "resources" edge to the Resource entity by ids.
func (m *ResourceDefinitionMutation) AddResourceIDs(ids ...object.ID) {
	if m.resources == nil {
		m.resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the Resource entity.
func (m *ResourceDefinitionMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the Resource entity was cleared.
func (m *ResourceDefinitionMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the Resource entity by IDs.
func (m *ResourceDefinitionMutation) RemoveResourceIDs(ids ...object.ID) {
	if m.removedresources == nil {
		m.removedresources = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the Resource entity.
func (m *ResourceDefinitionMutation) RemovedResourcesIDs() (ids []object.ID) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *ResourceDefinitionMutation) ResourcesIDs() (ids []object.ID) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *ResourceDefinitionMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// Where appends a list predicates to the ResourceDefinitionMutation builder.
func (m *ResourceDefinitionMutation) Where(ps ...predicate.ResourceDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceDefinition).
func (m *ResourceDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, resourcedefinition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, resourcedefinition.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, resourcedefinition.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, resourcedefinition.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, resourcedefinition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, resourcedefinition.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, resourcedefinition.FieldType)
	}
	if m.schema != nil {
		fields = append(fields, resourcedefinition.FieldSchema)
	}
	if m.uiSchema != nil {
		fields = append(fields, resourcedefinition.FieldUiSchema)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcedefinition.FieldName:
		return m.Name()
	case resourcedefinition.FieldDescription:
		return m.Description()
	case resourcedefinition.FieldLabels:
		return m.Labels()
	case resourcedefinition.FieldAnnotations:
		return m.Annotations()
	case resourcedefinition.FieldCreateTime:
		return m.CreateTime()
	case resourcedefinition.FieldUpdateTime:
		return m.UpdateTime()
	case resourcedefinition.FieldType:
		return m.GetType()
	case resourcedefinition.FieldSchema:
		return m.Schema()
	case resourcedefinition.FieldUiSchema:
		return m.UiSchema()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcedefinition.FieldName:
		return m.OldName(ctx)
	case resourcedefinition.FieldDescription:
		return m.OldDescription(ctx)
	case resourcedefinition.FieldLabels:
		return m.OldLabels(ctx)
	case resourcedefinition.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case resourcedefinition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case resourcedefinition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case resourcedefinition.FieldType:
		return m.OldType(ctx)
	case resourcedefinition.FieldSchema:
		return m.OldSchema(ctx)
	case resourcedefinition.FieldUiSchema:
		return m.OldUiSchema(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcedefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resourcedefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resourcedefinition.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case resourcedefinition.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case resourcedefinition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case resourcedefinition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case resourcedefinition.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case resourcedefinition.FieldSchema:
		v, ok := value.(types.Schema)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchema(v)
		return nil
	case resourcedefinition.FieldUiSchema:
		v, ok := value.(*types.UISchema)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUiSchema(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceDefinitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourcedefinition.FieldDescription) {
		fields = append(fields, resourcedefinition.FieldDescription)
	}
	if m.FieldCleared(resourcedefinition.FieldLabels) {
		fields = append(fields, resourcedefinition.FieldLabels)
	}
	if m.FieldCleared(resourcedefinition.FieldAnnotations) {
		fields = append(fields, resourcedefinition.FieldAnnotations)
	}
	if m.FieldCleared(resourcedefinition.FieldUiSchema) {
		fields = append(fields, resourcedefinition.FieldUiSchema)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceDefinitionMutation) ClearField(name string) error {
	switch name {
	case resourcedefinition.FieldDescription:
		m.ClearDescription()
		return nil
	case resourcedefinition.FieldLabels:
		m.ClearLabels()
		return nil
	case resourcedefinition.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case resourcedefinition.FieldUiSchema:
		m.ClearUiSchema()
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceDefinitionMutation) ResetField(name string) error {
	switch name {
	case resourcedefinition.FieldName:
		m.ResetName()
		return nil
	case resourcedefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case resourcedefinition.FieldLabels:
		m.ResetLabels()
		return nil
	case resourcedefinition.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case resourcedefinition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case resourcedefinition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case resourcedefinition.FieldType:
		m.ResetType()
		return nil
	case resourcedefinition.FieldSchema:
		m.ResetSchema()
		return nil
	case resourcedefinition.FieldUiSchema:
		m.ResetUiSchema()
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.matching_rules != nil {
		edges = append(edges, resourcedefinition.EdgeMatchingRules)
	}
	if m.resources != nil {
		edges = append(edges, resourcedefinition.EdgeResources)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourcedefinition.EdgeMatchingRules:
		ids := make([]ent.Value, 0, len(m.matching_rules))
		for id := range m.matching_rules {
			ids = append(ids, id)
		}
		return ids
	case resourcedefinition.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmatching_rules != nil {
		edges = append(edges, resourcedefinition.EdgeMatchingRules)
	}
	if m.removedresources != nil {
		edges = append(edges, resourcedefinition.EdgeResources)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resourcedefinition.EdgeMatchingRules:
		ids := make([]ent.Value, 0, len(m.removedmatching_rules))
		for id := range m.removedmatching_rules {
			ids = append(ids, id)
		}
		return ids
	case resourcedefinition.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmatching_rules {
		edges = append(edges, resourcedefinition.EdgeMatchingRules)
	}
	if m.clearedresources {
		edges = append(edges, resourcedefinition.EdgeResources)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case resourcedefinition.EdgeMatchingRules:
		return m.clearedmatching_rules
	case resourcedefinition.EdgeResources:
		return m.clearedresources
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceDefinitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case resourcedefinition.EdgeMatchingRules:
		m.ResetMatchingRules()
		return nil
	case resourcedefinition.EdgeResources:
		m.ResetResources()
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinition edge %s", name)
}

// ResourceDefinitionMatchingRuleMutation represents an operation that mutates the ResourceDefinitionMatchingRule nodes in the graph.
type ResourceDefinitionMatchingRuleMutation struct {
	config
	op                         Op
	typ                        string
	id                         *object.ID
	create_time                *time.Time
	name                       *string
	selector                   *types.Selector
	attributes                 *property.Values
	_order                     *int
	add_order                  *int
	clearedFields              map[string]struct{}
	resource_definition        *object.ID
	clearedresource_definition bool
	template                   *object.ID
	clearedtemplate            bool
	done                       bool
	oldValue                   func(context.Context) (*ResourceDefinitionMatchingRule, error)
	predicates                 []predicate.ResourceDefinitionMatchingRule
}

var _ ent.Mutation = (*ResourceDefinitionMatchingRuleMutation)(nil)

// resourceDefinitionMatchingRuleOption allows management of the mutation configuration using functional options.
type resourceDefinitionMatchingRuleOption func(*ResourceDefinitionMatchingRuleMutation)

// newResourceDefinitionMatchingRuleMutation creates new mutation for the ResourceDefinitionMatchingRule entity.
func newResourceDefinitionMatchingRuleMutation(c config, op Op, opts ...resourceDefinitionMatchingRuleOption) *ResourceDefinitionMatchingRuleMutation {
	m := &ResourceDefinitionMatchingRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceDefinitionMatchingRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceDefinitionMatchingRuleID sets the ID field of the mutation.
func withResourceDefinitionMatchingRuleID(id object.ID) resourceDefinitionMatchingRuleOption {
	return func(m *ResourceDefinitionMatchingRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceDefinitionMatchingRule
		)
		m.oldValue = func(ctx context.Context) (*ResourceDefinitionMatchingRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceDefinitionMatchingRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceDefinitionMatchingRule sets the old ResourceDefinitionMatchingRule of the mutation.
func withResourceDefinitionMatchingRule(node *ResourceDefinitionMatchingRule) resourceDefinitionMatchingRuleOption {
	return func(m *ResourceDefinitionMatchingRuleMutation) {
		m.oldValue = func(context.Context) (*ResourceDefinitionMatchingRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceDefinitionMatchingRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceDefinitionMatchingRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceDefinitionMatchingRule entities.
func (m *ResourceDefinitionMatchingRuleMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceDefinitionMatchingRuleMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceDefinitionMatchingRuleMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceDefinitionMatchingRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ResourceDefinitionMatchingRuleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ResourceDefinitionMatchingRuleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ResourceDefinitionMatchingRule entity.
// If the ResourceDefinitionMatchingRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMatchingRuleMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ResourceDefinitionMatchingRuleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetResourceDefinitionID sets the "resource_definition_id" field.
func (m *ResourceDefinitionMatchingRuleMutation) SetResourceDefinitionID(o object.ID) {
	m.resource_definition = &o
}

// ResourceDefinitionID returns the value of the "resource_definition_id" field in the mutation.
func (m *ResourceDefinitionMatchingRuleMutation) ResourceDefinitionID() (r object.ID, exists bool) {
	v := m.resource_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceDefinitionID returns the old "resource_definition_id" field's value of the ResourceDefinitionMatchingRule entity.
// If the ResourceDefinitionMatchingRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMatchingRuleMutation) OldResourceDefinitionID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceDefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceDefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceDefinitionID: %w", err)
	}
	return oldValue.ResourceDefinitionID, nil
}

// ResetResourceDefinitionID resets all changes to the "resource_definition_id" field.
func (m *ResourceDefinitionMatchingRuleMutation) ResetResourceDefinitionID() {
	m.resource_definition = nil
}

// SetTemplateID sets the "template_id" field.
func (m *ResourceDefinitionMatchingRuleMutation) SetTemplateID(o object.ID) {
	m.template = &o
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *ResourceDefinitionMatchingRuleMutation) TemplateID() (r object.ID, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the ResourceDefinitionMatchingRule entity.
// If the ResourceDefinitionMatchingRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMatchingRuleMutation) OldTemplateID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *ResourceDefinitionMatchingRuleMutation) ResetTemplateID() {
	m.template = nil
}

// SetName sets the "name" field.
func (m *ResourceDefinitionMatchingRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceDefinitionMatchingRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ResourceDefinitionMatchingRule entity.
// If the ResourceDefinitionMatchingRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMatchingRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResourceDefinitionMatchingRuleMutation) ResetName() {
	m.name = nil
}

// SetSelector sets the "selector" field.
func (m *ResourceDefinitionMatchingRuleMutation) SetSelector(t types.Selector) {
	m.selector = &t
}

// Selector returns the value of the "selector" field in the mutation.
func (m *ResourceDefinitionMatchingRuleMutation) Selector() (r types.Selector, exists bool) {
	v := m.selector
	if v == nil {
		return
	}
	return *v, true
}

// OldSelector returns the old "selector" field's value of the ResourceDefinitionMatchingRule entity.
// If the ResourceDefinitionMatchingRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMatchingRuleMutation) OldSelector(ctx context.Context) (v types.Selector, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelector: %w", err)
	}
	return oldValue.Selector, nil
}

// ResetSelector resets all changes to the "selector" field.
func (m *ResourceDefinitionMatchingRuleMutation) ResetSelector() {
	m.selector = nil
}

// SetAttributes sets the "attributes" field.
func (m *ResourceDefinitionMatchingRuleMutation) SetAttributes(pr property.Values) {
	m.attributes = &pr
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ResourceDefinitionMatchingRuleMutation) Attributes() (r property.Values, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the ResourceDefinitionMatchingRule entity.
// If the ResourceDefinitionMatchingRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMatchingRuleMutation) OldAttributes(ctx context.Context) (v property.Values, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ResourceDefinitionMatchingRuleMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[resourcedefinitionmatchingrule.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[resourcedefinitionmatchingrule.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ResourceDefinitionMatchingRuleMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, resourcedefinitionmatchingrule.FieldAttributes)
}

// SetOrder sets the "order" field.
func (m *ResourceDefinitionMatchingRuleMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *ResourceDefinitionMatchingRuleMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the ResourceDefinitionMatchingRule entity.
// If the ResourceDefinitionMatchingRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceDefinitionMatchingRuleMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *ResourceDefinitionMatchingRuleMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *ResourceDefinitionMatchingRuleMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearResourceDefinition clears the "resource_definition" edge to the ResourceDefinition entity.
func (m *ResourceDefinitionMatchingRuleMutation) ClearResourceDefinition() {
	m.clearedresource_definition = true
}

// ResourceDefinitionCleared reports if the "resource_definition" edge to the ResourceDefinition entity was cleared.
func (m *ResourceDefinitionMatchingRuleMutation) ResourceDefinitionCleared() bool {
	return m.clearedresource_definition
}

// ResourceDefinitionIDs returns the "resource_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceDefinitionID instead. It exists only for internal usage by the builders.
func (m *ResourceDefinitionMatchingRuleMutation) ResourceDefinitionIDs() (ids []object.ID) {
	if id := m.resource_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResourceDefinition resets all changes to the "resource_definition" edge.
func (m *ResourceDefinitionMatchingRuleMutation) ResetResourceDefinition() {
	m.resource_definition = nil
	m.clearedresource_definition = false
}

// ClearTemplate clears the "template" edge to the TemplateVersion entity.
func (m *ResourceDefinitionMatchingRuleMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared reports if the "template" edge to the TemplateVersion entity was cleared.
func (m *ResourceDefinitionMatchingRuleMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *ResourceDefinitionMatchingRuleMutation) TemplateIDs() (ids []object.ID) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *ResourceDefinitionMatchingRuleMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// Where appends a list predicates to the ResourceDefinitionMatchingRuleMutation builder.
func (m *ResourceDefinitionMatchingRuleMutation) Where(ps ...predicate.ResourceDefinitionMatchingRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceDefinitionMatchingRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceDefinitionMatchingRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceDefinitionMatchingRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceDefinitionMatchingRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceDefinitionMatchingRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceDefinitionMatchingRule).
func (m *ResourceDefinitionMatchingRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceDefinitionMatchingRuleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, resourcedefinitionmatchingrule.FieldCreateTime)
	}
	if m.resource_definition != nil {
		fields = append(fields, resourcedefinitionmatchingrule.FieldResourceDefinitionID)
	}
	if m.template != nil {
		fields = append(fields, resourcedefinitionmatchingrule.FieldTemplateID)
	}
	if m.name != nil {
		fields = append(fields, resourcedefinitionmatchingrule.FieldName)
	}
	if m.selector != nil {
		fields = append(fields, resourcedefinitionmatchingrule.FieldSelector)
	}
	if m.attributes != nil {
		fields = append(fields, resourcedefinitionmatchingrule.FieldAttributes)
	}
	if m._order != nil {
		fields = append(fields, resourcedefinitionmatchingrule.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceDefinitionMatchingRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcedefinitionmatchingrule.FieldCreateTime:
		return m.CreateTime()
	case resourcedefinitionmatchingrule.FieldResourceDefinitionID:
		return m.ResourceDefinitionID()
	case resourcedefinitionmatchingrule.FieldTemplateID:
		return m.TemplateID()
	case resourcedefinitionmatchingrule.FieldName:
		return m.Name()
	case resourcedefinitionmatchingrule.FieldSelector:
		return m.Selector()
	case resourcedefinitionmatchingrule.FieldAttributes:
		return m.Attributes()
	case resourcedefinitionmatchingrule.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceDefinitionMatchingRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcedefinitionmatchingrule.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case resourcedefinitionmatchingrule.FieldResourceDefinitionID:
		return m.OldResourceDefinitionID(ctx)
	case resourcedefinitionmatchingrule.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case resourcedefinitionmatchingrule.FieldName:
		return m.OldName(ctx)
	case resourcedefinitionmatchingrule.FieldSelector:
		return m.OldSelector(ctx)
	case resourcedefinitionmatchingrule.FieldAttributes:
		return m.OldAttributes(ctx)
	case resourcedefinitionmatchingrule.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceDefinitionMatchingRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceDefinitionMatchingRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcedefinitionmatchingrule.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case resourcedefinitionmatchingrule.FieldResourceDefinitionID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceDefinitionID(v)
		return nil
	case resourcedefinitionmatchingrule.FieldTemplateID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case resourcedefinitionmatchingrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resourcedefinitionmatchingrule.FieldSelector:
		v, ok := value.(types.Selector)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelector(v)
		return nil
	case resourcedefinitionmatchingrule.FieldAttributes:
		v, ok := value.(property.Values)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case resourcedefinitionmatchingrule.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinitionMatchingRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, resourcedefinitionmatchingrule.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceDefinitionMatchingRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourcedefinitionmatchingrule.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceDefinitionMatchingRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourcedefinitionmatchingrule.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinitionMatchingRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceDefinitionMatchingRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourcedefinitionmatchingrule.FieldAttributes) {
		fields = append(fields, resourcedefinitionmatchingrule.FieldAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceDefinitionMatchingRuleMutation) ClearField(name string) error {
	switch name {
	case resourcedefinitionmatchingrule.FieldAttributes:
		m.ClearAttributes()
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinitionMatchingRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceDefinitionMatchingRuleMutation) ResetField(name string) error {
	switch name {
	case resourcedefinitionmatchingrule.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case resourcedefinitionmatchingrule.FieldResourceDefinitionID:
		m.ResetResourceDefinitionID()
		return nil
	case resourcedefinitionmatchingrule.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case resourcedefinitionmatchingrule.FieldName:
		m.ResetName()
		return nil
	case resourcedefinitionmatchingrule.FieldSelector:
		m.ResetSelector()
		return nil
	case resourcedefinitionmatchingrule.FieldAttributes:
		m.ResetAttributes()
		return nil
	case resourcedefinitionmatchingrule.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinitionMatchingRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.resource_definition != nil {
		edges = append(edges, resourcedefinitionmatchingrule.EdgeResourceDefinition)
	}
	if m.template != nil {
		edges = append(edges, resourcedefinitionmatchingrule.EdgeTemplate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourcedefinitionmatchingrule.EdgeResourceDefinition:
		if id := m.resource_definition; id != nil {
			return []ent.Value{*id}
		}
	case resourcedefinitionmatchingrule.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresource_definition {
		edges = append(edges, resourcedefinitionmatchingrule.EdgeResourceDefinition)
	}
	if m.clearedtemplate {
		edges = append(edges, resourcedefinitionmatchingrule.EdgeTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceDefinitionMatchingRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case resourcedefinitionmatchingrule.EdgeResourceDefinition:
		return m.clearedresource_definition
	case resourcedefinitionmatchingrule.EdgeTemplate:
		return m.clearedtemplate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceDefinitionMatchingRuleMutation) ClearEdge(name string) error {
	switch name {
	case resourcedefinitionmatchingrule.EdgeResourceDefinition:
		m.ClearResourceDefinition()
		return nil
	case resourcedefinitionmatchingrule.EdgeTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinitionMatchingRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceDefinitionMatchingRuleMutation) ResetEdge(name string) error {
	switch name {
	case resourcedefinitionmatchingrule.EdgeResourceDefinition:
		m.ResetResourceDefinition()
		return nil
	case resourcedefinitionmatchingrule.EdgeTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown ResourceDefinitionMatchingRule edge %s", name)
}

// ResourceRelationshipMutation represents an operation that mutates the ResourceRelationship nodes in the graph.
type ResourceRelationshipMutation struct {
	config
	op                Op
	typ               string
	id                *object.ID
	create_time       *time.Time
	_path             *[]object.ID
	append_path       []object.ID
	_type             *string
	clearedFields     map[string]struct{}
	resource          *object.ID
	clearedresource   bool
	dependency        *object.ID
	cleareddependency bool
	done              bool
	oldValue          func(context.Context) (*ResourceRelationship, error)
	predicates        []predicate.ResourceRelationship
}

var _ ent.Mutation = (*ResourceRelationshipMutation)(nil)

// resourceRelationshipOption allows management of the mutation configuration using functional options.
type resourceRelationshipOption func(*ResourceRelationshipMutation)

// newResourceRelationshipMutation creates new mutation for the ResourceRelationship entity.
func newResourceRelationshipMutation(c config, op Op, opts ...resourceRelationshipOption) *ResourceRelationshipMutation {
	m := &ResourceRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceRelationshipID sets the ID field of the mutation.
func withResourceRelationshipID(id object.ID) resourceRelationshipOption {
	return func(m *ResourceRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceRelationship
		)
		m.oldValue = func(ctx context.Context) (*ResourceRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceRelationship sets the old ResourceRelationship of the mutation.
func withResourceRelationship(node *ResourceRelationship) resourceRelationshipOption {
	return func(m *ResourceRelationshipMutation) {
		m.oldValue = func(context.Context) (*ResourceRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceRelationship entities.
func (m *ResourceRelationshipMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceRelationshipMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceRelationshipMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ResourceRelationshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ResourceRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ResourceRelationship entity.
// If the ResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ResourceRelationshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceRelationshipMutation) SetResourceID(o object.ID) {
	m.resource = &o
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceRelationshipMutation) ResourceID() (r object.ID, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceRelationship entity.
// If the ResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRelationshipMutation) OldResourceID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceRelationshipMutation) ResetResourceID() {
	m.resource = nil
}

// SetDependencyID sets the "dependency_id" field.
func (m *ResourceRelationshipMutation) SetDependencyID(o object.ID) {
	m.dependency = &o
}

// DependencyID returns the value of the "dependency_id" field in the mutation.
func (m *ResourceRelationshipMutation) DependencyID() (r object.ID, exists bool) {
	v := m.dependency
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyID returns the old "dependency_id" field's value of the ResourceRelationship entity.
// If the ResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRelationshipMutation) OldDependencyID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyID: %w", err)
	}
	return oldValue.DependencyID, nil
}

// ResetDependencyID resets all changes to the "dependency_id" field.
func (m *ResourceRelationshipMutation) ResetDependencyID() {
	m.dependency = nil
}

// SetPath sets the "path" field.
func (m *ResourceRelationshipMutation) SetPath(o []object.ID) {
	m._path = &o
	m.append_path = nil
}

// Path returns the value of the "path" field in the mutation.
func (m *ResourceRelationshipMutation) Path() (r []object.ID, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the ResourceRelationship entity.
// If the ResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRelationshipMutation) OldPath(ctx context.Context) (v []object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// AppendPath adds o to the "path" field.
func (m *ResourceRelationshipMutation) AppendPath(o []object.ID) {
	m.append_path = append(m.append_path, o...)
}

// AppendedPath returns the list of values that were appended to the "path" field in this mutation.
func (m *ResourceRelationshipMutation) AppendedPath() ([]object.ID, bool) {
	if len(m.append_path) == 0 {
		return nil, false
	}
	return m.append_path, true
}

// ResetPath resets all changes to the "path" field.
func (m *ResourceRelationshipMutation) ResetPath() {
	m._path = nil
	m.append_path = nil
}

// SetType sets the "type" field.
func (m *ResourceRelationshipMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceRelationshipMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ResourceRelationship entity.
// If the ResourceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRelationshipMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceRelationshipMutation) ResetType() {
	m._type = nil
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *ResourceRelationshipMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *ResourceRelationshipMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *ResourceRelationshipMutation) ResourceIDs() (ids []object.ID) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *ResourceRelationshipMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// ClearDependency clears the "dependency" edge to the Resource entity.
func (m *ResourceRelationshipMutation) ClearDependency() {
	m.cleareddependency = true
}

// DependencyCleared reports if the "dependency" edge to the Resource entity was cleared.
func (m *ResourceRelationshipMutation) DependencyCleared() bool {
	return m.cleareddependency
}

// DependencyIDs returns the "dependency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependencyID instead. It exists only for internal usage by the builders.
func (m *ResourceRelationshipMutation) DependencyIDs() (ids []object.ID) {
	if id := m.dependency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependency resets all changes to the "dependency" edge.
func (m *ResourceRelationshipMutation) ResetDependency() {
	m.dependency = nil
	m.cleareddependency = false
}

// Where appends a list predicates to the ResourceRelationshipMutation builder.
func (m *ResourceRelationshipMutation) Where(ps ...predicate.ResourceRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceRelationship).
func (m *ResourceRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, resourcerelationship.FieldCreateTime)
	}
	if m.resource != nil {
		fields = append(fields, resourcerelationship.FieldResourceID)
	}
	if m.dependency != nil {
		fields = append(fields, resourcerelationship.FieldDependencyID)
	}
	if m._path != nil {
		fields = append(fields, resourcerelationship.FieldPath)
	}
	if m._type != nil {
		fields = append(fields, resourcerelationship.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcerelationship.FieldCreateTime:
		return m.CreateTime()
	case resourcerelationship.FieldResourceID:
		return m.ResourceID()
	case resourcerelationship.FieldDependencyID:
		return m.DependencyID()
	case resourcerelationship.FieldPath:
		return m.Path()
	case resourcerelationship.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcerelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case resourcerelationship.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourcerelationship.FieldDependencyID:
		return m.OldDependencyID(ctx)
	case resourcerelationship.FieldPath:
		return m.OldPath(ctx)
	case resourcerelationship.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcerelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case resourcerelationship.FieldResourceID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourcerelationship.FieldDependencyID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyID(v)
		return nil
	case resourcerelationship.FieldPath:
		v, ok := value.([]object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case resourcerelationship.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResourceRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceRelationshipMutation) ResetField(name string) error {
	switch name {
	case resourcerelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case resourcerelationship.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourcerelationship.FieldDependencyID:
		m.ResetDependencyID()
		return nil
	case resourcerelationship.FieldPath:
		m.ResetPath()
		return nil
	case resourcerelationship.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ResourceRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.resource != nil {
		edges = append(edges, resourcerelationship.EdgeResource)
	}
	if m.dependency != nil {
		edges = append(edges, resourcerelationship.EdgeDependency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourcerelationship.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	case resourcerelationship.EdgeDependency:
		if id := m.dependency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresource {
		edges = append(edges, resourcerelationship.EdgeResource)
	}
	if m.cleareddependency {
		edges = append(edges, resourcerelationship.EdgeDependency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case resourcerelationship.EdgeResource:
		return m.clearedresource
	case resourcerelationship.EdgeDependency:
		return m.cleareddependency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case resourcerelationship.EdgeResource:
		m.ClearResource()
		return nil
	case resourcerelationship.EdgeDependency:
		m.ClearDependency()
		return nil
	}
	return fmt.Errorf("unknown ResourceRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case resourcerelationship.EdgeResource:
		m.ResetResource()
		return nil
	case resourcerelationship.EdgeDependency:
		m.ResetDependency()
		return nil
	}
	return fmt.Errorf("unknown ResourceRelationship edge %s", name)
}

// ResourceRevisionMutation represents an operation that mutates the ResourceRevision nodes in the graph.
type ResourceRevisionMutation struct {
	config
	op                                Op
	typ                               string
	id                                *object.ID
	create_time                       *time.Time
	status                            *status.Status
	template_name                     *string
	template_version                  *string
	template_id                       *object.ID
	attributes                        *property.Values
	variables                         *crypto.Map[string, string]
	input_plan                        *string
	output                            *string
	deployer_type                     *string
	duration                          *int
	addduration                       *int
	previous_required_providers       *[]types.ProviderRequirement
	appendprevious_required_providers []types.ProviderRequirement
	record                            *string
	change_comment                    *string
	created_by                        *string
	clearedFields                     map[string]struct{}
	project                           *object.ID
	clearedproject                    bool
	environment                       *object.ID
	clearedenvironment                bool
	resource                          *object.ID
	clearedresource                   bool
	done                              bool
	oldValue                          func(context.Context) (*ResourceRevision, error)
	predicates                        []predicate.ResourceRevision
}

var _ ent.Mutation = (*ResourceRevisionMutation)(nil)

// resourceRevisionOption allows management of the mutation configuration using functional options.
type resourceRevisionOption func(*ResourceRevisionMutation)

// newResourceRevisionMutation creates new mutation for the ResourceRevision entity.
func newResourceRevisionMutation(c config, op Op, opts ...resourceRevisionOption) *ResourceRevisionMutation {
	m := &ResourceRevisionMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceRevision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceRevisionID sets the ID field of the mutation.
func withResourceRevisionID(id object.ID) resourceRevisionOption {
	return func(m *ResourceRevisionMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceRevision
		)
		m.oldValue = func(ctx context.Context) (*ResourceRevision, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceRevision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceRevision sets the old ResourceRevision of the mutation.
func withResourceRevision(node *ResourceRevision) resourceRevisionOption {
	return func(m *ResourceRevisionMutation) {
		m.oldValue = func(context.Context) (*ResourceRevision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceRevisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceRevisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceRevision entities.
func (m *ResourceRevisionMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceRevisionMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceRevisionMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceRevision.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ResourceRevisionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ResourceRevisionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ResourceRevisionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetStatus sets the "status" field.
func (m *ResourceRevisionMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ResourceRevisionMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ResourceRevisionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[resourcerevision.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ResourceRevisionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[resourcerevision.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ResourceRevisionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, resourcerevision.FieldStatus)
}

// SetProjectID sets the "project_id" field.
func (m *ResourceRevisionMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ResourceRevisionMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ResourceRevisionMutation) ResetProjectID() {
	m.project = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *ResourceRevisionMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *ResourceRevisionMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *ResourceRevisionMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceRevisionMutation) SetResourceID(o object.ID) {
	m.resource = &o
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceRevisionMutation) ResourceID() (r object.ID, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldResourceID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceRevisionMutation) ResetResourceID() {
	m.resource = nil
}

// SetTemplateName sets the "template_name" field.
func (m *ResourceRevisionMutation) SetTemplateName(s string) {
	m.template_name = &s
}

// TemplateName returns the value of the "template_name" field in the mutation.
func (m *ResourceRevisionMutation) TemplateName() (r string, exists bool) {
	v := m.template_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateName returns the old "template_name" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldTemplateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateName: %w", err)
	}
	return oldValue.TemplateName, nil
}

// ResetTemplateName resets all changes to the "template_name" field.
func (m *ResourceRevisionMutation) ResetTemplateName() {
	m.template_name = nil
}

// SetTemplateVersion sets the "template_version" field.
func (m *ResourceRevisionMutation) SetTemplateVersion(s string) {
	m.template_version = &s
}

// TemplateVersion returns the value of the "template_version" field in the mutation.
func (m *ResourceRevisionMutation) TemplateVersion() (r string, exists bool) {
	v := m.template_version
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateVersion returns the old "template_version" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldTemplateVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateVersion: %w", err)
	}
	return oldValue.TemplateVersion, nil
}

// ResetTemplateVersion resets all changes to the "template_version" field.
func (m *ResourceRevisionMutation) ResetTemplateVersion() {
	m.template_version = nil
}

// SetTemplateID sets the "template_id" field.
func (m *ResourceRevisionMutation) SetTemplateID(o object.ID) {
	m.template_id = &o
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *ResourceRevisionMutation) TemplateID() (r object.ID, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldTemplateID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *ResourceRevisionMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetAttributes sets the "attributes" field.
func (m *ResourceRevisionMutation) SetAttributes(pr property.Values) {
	m.attributes = &pr
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ResourceRevisionMutation) Attributes() (r property.Values, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldAttributes(ctx context.Context) (v property.Values, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ResourceRevisionMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[resourcerevision.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ResourceRevisionMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[resourcerevision.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ResourceRevisionMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, resourcerevision.FieldAttributes)
}

// SetVariables sets the "variables" field.
func (m *ResourceRevisionMutation) SetVariables(c crypto.Map[string, string]) {
	m.variables = &c
}

// Variables returns the value of the "variables" field in the mutation.
func (m *ResourceRevisionMutation) Variables() (r crypto.Map[string, string], exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldVariables(ctx context.Context) (v crypto.Map[string, string], err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ResetVariables resets all changes to the "variables" field.
func (m *ResourceRevisionMutation) ResetVariables() {
	m.variables = nil
}

// SetInputPlan sets the "input_plan" field.
func (m *ResourceRevisionMutation) SetInputPlan(s string) {
	m.input_plan = &s
}

// InputPlan returns the value of the "input_plan" field in the mutation.
func (m *ResourceRevisionMutation) InputPlan() (r string, exists bool) {
	v := m.input_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldInputPlan returns the old "input_plan" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldInputPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputPlan: %w", err)
	}
	return oldValue.InputPlan, nil
}

// ResetInputPlan resets all changes to the "input_plan" field.
func (m *ResourceRevisionMutation) ResetInputPlan() {
	m.input_plan = nil
}

// SetOutput sets the "output" field.
func (m *ResourceRevisionMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *ResourceRevisionMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *ResourceRevisionMutation) ResetOutput() {
	m.output = nil
}

// SetDeployerType sets the "deployer_type" field.
func (m *ResourceRevisionMutation) SetDeployerType(s string) {
	m.deployer_type = &s
}

// DeployerType returns the value of the "deployer_type" field in the mutation.
func (m *ResourceRevisionMutation) DeployerType() (r string, exists bool) {
	v := m.deployer_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployerType returns the old "deployer_type" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldDeployerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployerType: %w", err)
	}
	return oldValue.DeployerType, nil
}

// ResetDeployerType resets all changes to the "deployer_type" field.
func (m *ResourceRevisionMutation) ResetDeployerType() {
	m.deployer_type = nil
}

// SetDuration sets the "duration" field.
func (m *ResourceRevisionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ResourceRevisionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ResourceRevisionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ResourceRevisionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *ResourceRevisionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetPreviousRequiredProviders sets the "previous_required_providers" field.
func (m *ResourceRevisionMutation) SetPreviousRequiredProviders(tr []types.ProviderRequirement) {
	m.previous_required_providers = &tr
	m.appendprevious_required_providers = nil
}

// PreviousRequiredProviders returns the value of the "previous_required_providers" field in the mutation.
func (m *ResourceRevisionMutation) PreviousRequiredProviders() (r []types.ProviderRequirement, exists bool) {
	v := m.previous_required_providers
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousRequiredProviders returns the old "previous_required_providers" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldPreviousRequiredProviders(ctx context.Context) (v []types.ProviderRequirement, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousRequiredProviders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousRequiredProviders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousRequiredProviders: %w", err)
	}
	return oldValue.PreviousRequiredProviders, nil
}

// AppendPreviousRequiredProviders adds tr to the "previous_required_providers" field.
func (m *ResourceRevisionMutation) AppendPreviousRequiredProviders(tr []types.ProviderRequirement) {
	m.appendprevious_required_providers = append(m.appendprevious_required_providers, tr...)
}

// AppendedPreviousRequiredProviders returns the list of values that were appended to the "previous_required_providers" field in this mutation.
func (m *ResourceRevisionMutation) AppendedPreviousRequiredProviders() ([]types.ProviderRequirement, bool) {
	if len(m.appendprevious_required_providers) == 0 {
		return nil, false
	}
	return m.appendprevious_required_providers, true
}

// ResetPreviousRequiredProviders resets all changes to the "previous_required_providers" field.
func (m *ResourceRevisionMutation) ResetPreviousRequiredProviders() {
	m.previous_required_providers = nil
	m.appendprevious_required_providers = nil
}

// SetRecord sets the "record" field.
func (m *ResourceRevisionMutation) SetRecord(s string) {
	m.record = &s
}

// Record returns the value of the "record" field in the mutation.
func (m *ResourceRevisionMutation) Record() (r string, exists bool) {
	v := m.record
	if v == nil {
		return
	}
	return *v, true
}

// OldRecord returns the old "record" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecord: %w", err)
	}
	return oldValue.Record, nil
}

// ClearRecord clears the value of the "record" field.
func (m *ResourceRevisionMutation) ClearRecord() {
	m.record = nil
	m.clearedFields[resourcerevision.FieldRecord] = struct{}{}
}

// RecordCleared returns if the "record" field was cleared in this mutation.
func (m *ResourceRevisionMutation) RecordCleared() bool {
	_, ok := m.clearedFields[resourcerevision.FieldRecord]
	return ok
}

// ResetRecord resets all changes to the "record" field.
func (m *ResourceRevisionMutation) ResetRecord() {
	m.record = nil
	delete(m.clearedFields, resourcerevision.FieldRecord)
}

// SetChangeComment sets the "change_comment" field.
func (m *ResourceRevisionMutation) SetChangeComment(s string) {
	m.change_comment = &s
}

// ChangeComment returns the value of the "change_comment" field in the mutation.
func (m *ResourceRevisionMutation) ChangeComment() (r string, exists bool) {
	v := m.change_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeComment returns the old "change_comment" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldChangeComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeComment: %w", err)
	}
	return oldValue.ChangeComment, nil
}

// ClearChangeComment clears the value of the "change_comment" field.
func (m *ResourceRevisionMutation) ClearChangeComment() {
	m.change_comment = nil
	m.clearedFields[resourcerevision.FieldChangeComment] = struct{}{}
}

// ChangeCommentCleared returns if the "change_comment" field was cleared in this mutation.
func (m *ResourceRevisionMutation) ChangeCommentCleared() bool {
	_, ok := m.clearedFields[resourcerevision.FieldChangeComment]
	return ok
}

// ResetChangeComment resets all changes to the "change_comment" field.
func (m *ResourceRevisionMutation) ResetChangeComment() {
	m.change_comment = nil
	delete(m.clearedFields, resourcerevision.FieldChangeComment)
}

// SetCreatedBy sets the "created_by" field.
func (m *ResourceRevisionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ResourceRevisionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ResourceRevision entity.
// If the ResourceRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRevisionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ResourceRevisionMutation) ResetCreatedBy() {
	m.created_by = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ResourceRevisionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ResourceRevisionMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ResourceRevisionMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ResourceRevisionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *ResourceRevisionMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *ResourceRevisionMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ResourceRevisionMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *ResourceRevisionMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *ResourceRevisionMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *ResourceRevisionMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *ResourceRevisionMutation) ResourceIDs() (ids []object.ID) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *ResourceRevisionMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the ResourceRevisionMutation builder.
func (m *ResourceRevisionMutation) Where(ps ...predicate.ResourceRevision) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceRevisionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceRevisionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceRevision, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceRevisionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceRevisionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceRevision).
func (m *ResourceRevisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceRevisionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.create_time != nil {
		fields = append(fields, resourcerevision.FieldCreateTime)
	}
	if m.status != nil {
		fields = append(fields, resourcerevision.FieldStatus)
	}
	if m.project != nil {
		fields = append(fields, resourcerevision.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, resourcerevision.FieldEnvironmentID)
	}
	if m.resource != nil {
		fields = append(fields, resourcerevision.FieldResourceID)
	}
	if m.template_name != nil {
		fields = append(fields, resourcerevision.FieldTemplateName)
	}
	if m.template_version != nil {
		fields = append(fields, resourcerevision.FieldTemplateVersion)
	}
	if m.template_id != nil {
		fields = append(fields, resourcerevision.FieldTemplateID)
	}
	if m.attributes != nil {
		fields = append(fields, resourcerevision.FieldAttributes)
	}
	if m.variables != nil {
		fields = append(fields, resourcerevision.FieldVariables)
	}
	if m.input_plan != nil {
		fields = append(fields, resourcerevision.FieldInputPlan)
	}
	if m.output != nil {
		fields = append(fields, resourcerevision.FieldOutput)
	}
	if m.deployer_type != nil {
		fields = append(fields, resourcerevision.FieldDeployerType)
	}
	if m.duration != nil {
		fields = append(fields, resourcerevision.FieldDuration)
	}
	if m.previous_required_providers != nil {
		fields = append(fields, resourcerevision.FieldPreviousRequiredProviders)
	}
	if m.record != nil {
		fields = append(fields, resourcerevision.FieldRecord)
	}
	if m.change_comment != nil {
		fields = append(fields, resourcerevision.FieldChangeComment)
	}
	if m.created_by != nil {
		fields = append(fields, resourcerevision.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceRevisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcerevision.FieldCreateTime:
		return m.CreateTime()
	case resourcerevision.FieldStatus:
		return m.Status()
	case resourcerevision.FieldProjectID:
		return m.ProjectID()
	case resourcerevision.FieldEnvironmentID:
		return m.EnvironmentID()
	case resourcerevision.FieldResourceID:
		return m.ResourceID()
	case resourcerevision.FieldTemplateName:
		return m.TemplateName()
	case resourcerevision.FieldTemplateVersion:
		return m.TemplateVersion()
	case resourcerevision.FieldTemplateID:
		return m.TemplateID()
	case resourcerevision.FieldAttributes:
		return m.Attributes()
	case resourcerevision.FieldVariables:
		return m.Variables()
	case resourcerevision.FieldInputPlan:
		return m.InputPlan()
	case resourcerevision.FieldOutput:
		return m.Output()
	case resourcerevision.FieldDeployerType:
		return m.DeployerType()
	case resourcerevision.FieldDuration:
		return m.Duration()
	case resourcerevision.FieldPreviousRequiredProviders:
		return m.PreviousRequiredProviders()
	case resourcerevision.FieldRecord:
		return m.Record()
	case resourcerevision.FieldChangeComment:
		return m.ChangeComment()
	case resourcerevision.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceRevisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcerevision.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case resourcerevision.FieldStatus:
		return m.OldStatus(ctx)
	case resourcerevision.FieldProjectID:
		return m.OldProjectID(ctx)
	case resourcerevision.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case resourcerevision.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourcerevision.FieldTemplateName:
		return m.OldTemplateName(ctx)
	case resourcerevision.FieldTemplateVersion:
		return m.OldTemplateVersion(ctx)
	case resourcerevision.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case resourcerevision.FieldAttributes:
		return m.OldAttributes(ctx)
	case resourcerevision.FieldVariables:
		return m.OldVariables(ctx)
	case resourcerevision.FieldInputPlan:
		return m.OldInputPlan(ctx)
	case resourcerevision.FieldOutput:
		return m.OldOutput(ctx)
	case resourcerevision.FieldDeployerType:
		return m.OldDeployerType(ctx)
	case resourcerevision.FieldDuration:
		return m.OldDuration(ctx)
	case resourcerevision.FieldPreviousRequiredProviders:
		return m.OldPreviousRequiredProviders(ctx)
	case resourcerevision.FieldRecord:
		return m.OldRecord(ctx)
	case resourcerevision.FieldChangeComment:
		return m.OldChangeComment(ctx)
	case resourcerevision.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceRevision field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceRevisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcerevision.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case resourcerevision.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resourcerevision.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case resourcerevision.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case resourcerevision.FieldResourceID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourcerevision.FieldTemplateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateName(v)
		return nil
	case resourcerevision.FieldTemplateVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateVersion(v)
		return nil
	case resourcerevision.FieldTemplateID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case resourcerevision.FieldAttributes:
		v, ok := value.(property.Values)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case resourcerevision.FieldVariables:
		v, ok := value.(crypto.Map[string, string])
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case resourcerevision.FieldInputPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputPlan(v)
		return nil
	case resourcerevision.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case resourcerevision.FieldDeployerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployerType(v)
		return nil
	case resourcerevision.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case resourcerevision.FieldPreviousRequiredProviders:
		v, ok := value.([]types.ProviderRequirement)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousRequiredProviders(v)
		return nil
	case resourcerevision.FieldRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecord(v)
		return nil
	case resourcerevision.FieldChangeComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeComment(v)
		return nil
	case resourcerevision.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceRevision field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceRevisionMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, resourcerevision.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceRevisionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourcerevision.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceRevisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourcerevision.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceRevision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceRevisionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourcerevision.FieldStatus) {
		fields = append(fields, resourcerevision.FieldStatus)
	}
	if m.FieldCleared(resourcerevision.FieldAttributes) {
		fields = append(fields, resourcerevision.FieldAttributes)
	}
	if m.FieldCleared(resourcerevision.FieldRecord) {
		fields = append(fields, resourcerevision.FieldRecord)
	}
	if m.FieldCleared(resourcerevision.FieldChangeComment) {
		fields = append(fields, resourcerevision.FieldChangeComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceRevisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceRevisionMutation) ClearField(name string) error {
	switch name {
	case resourcerevision.FieldStatus:
		m.ClearStatus()
		return nil
	case resourcerevision.FieldAttributes:
		m.ClearAttributes()
		return nil
	case resourcerevision.FieldRecord:
		m.ClearRecord()
		return nil
	case resourcerevision.FieldChangeComment:
		m.ClearChangeComment()
		return nil
	}
	return fmt.Errorf("unknown ResourceRevision nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceRevisionMutation) ResetField(name string) error {
	switch name {
	case resourcerevision.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case resourcerevision.FieldStatus:
		m.ResetStatus()
		return nil
	case resourcerevision.FieldProjectID:
		m.ResetProjectID()
		return nil
	case resourcerevision.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case resourcerevision.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourcerevision.FieldTemplateName:
		m.ResetTemplateName()
		return nil
	case resourcerevision.FieldTemplateVersion:
		m.ResetTemplateVersion()
		return nil
	case resourcerevision.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case resourcerevision.FieldAttributes:
		m.ResetAttributes()
		return nil
	case resourcerevision.FieldVariables:
		m.ResetVariables()
		return nil
	case resourcerevision.FieldInputPlan:
		m.ResetInputPlan()
		return nil
	case resourcerevision.FieldOutput:
		m.ResetOutput()
		return nil
	case resourcerevision.FieldDeployerType:
		m.ResetDeployerType()
		return nil
	case resourcerevision.FieldDuration:
		m.ResetDuration()
		return nil
	case resourcerevision.FieldPreviousRequiredProviders:
		m.ResetPreviousRequiredProviders()
		return nil
	case resourcerevision.FieldRecord:
		m.ResetRecord()
		return nil
	case resourcerevision.FieldChangeComment:
		m.ResetChangeComment()
		return nil
	case resourcerevision.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ResourceRevision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceRevisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, resourcerevision.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, resourcerevision.EdgeEnvironment)
	}
	if m.resource != nil {
		edges = append(edges, resourcerevision.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceRevisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourcerevision.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case resourcerevision.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case resourcerevision.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceRevisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceRevisionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceRevisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, resourcerevision.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, resourcerevision.EdgeEnvironment)
	}
	if m.clearedresource {
		edges = append(edges, resourcerevision.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceRevisionMutation) EdgeCleared(name string) bool {
	switch name {
	case resourcerevision.EdgeProject:
		return m.clearedproject
	case resourcerevision.EdgeEnvironment:
		return m.clearedenvironment
	case resourcerevision.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceRevisionMutation) ClearEdge(name string) error {
	switch name {
	case resourcerevision.EdgeProject:
		m.ClearProject()
		return nil
	case resourcerevision.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case resourcerevision.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown ResourceRevision unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceRevisionMutation) ResetEdge(name string) error {
	switch name {
	case resourcerevision.EdgeProject:
		m.ResetProject()
		return nil
	case resourcerevision.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case resourcerevision.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown ResourceRevision edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *string
	create_time                        *time.Time
	update_time                        *time.Time
	kind                               *string
	description                        *string
	policies                           *types.RolePolicies
	appendpolicies                     types.RolePolicies
	applicable_environment_types       *[]string
	appendapplicable_environment_types []string
	session                            *bool
	builtin                            *bool
	clearedFields                      map[string]struct{}
	subjects                           map[object.ID]struct{}
	removedsubjects                    map[object.ID]struct{}
	clearedsubjects                    bool
	done                               bool
	oldValue                           func(context.Context) (*Role, error)
	predicates                         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id string) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetKind sets the "kind" field.
func (m *RoleMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *RoleMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *RoleMutation) ResetKind() {
	m.kind = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetPolicies sets the "policies" field.
func (m *RoleMutation) SetPolicies(tp types.RolePolicies) {
	m.policies = &tp
	m.appendpolicies = nil
}

// Policies returns the value of the "policies" field in the mutation.
func (m *RoleMutation) Policies() (r types.RolePolicies, exists bool) {
	v := m.policies
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicies returns the old "policies" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPolicies(ctx context.Context) (v types.RolePolicies, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicies: %w", err)
	}
	return oldValue.Policies, nil
}

// AppendPolicies adds tp to the "policies" field.
func (m *RoleMutation) AppendPolicies(tp types.RolePolicies) {
	m.appendpolicies = append(m.appendpolicies, tp...)
}

// AppendedPolicies returns the list of values that were appended to the "policies" field in this mutation.
func (m *RoleMutation) AppendedPolicies() (types.RolePolicies, bool) {
	if len(m.appendpolicies) == 0 {
		return nil, false
	}
	return m.appendpolicies, true
}

// ResetPolicies resets all changes to the "policies" field.
func (m *RoleMutation) ResetPolicies() {
	m.policies = nil
	m.appendpolicies = nil
}

// SetApplicableEnvironmentTypes sets the "applicable_environment_types" field.
func (m *RoleMutation) SetApplicableEnvironmentTypes(s []string) {
	m.applicable_environment_types = &s
	m.appendapplicable_environment_types = nil
}

// ApplicableEnvironmentTypes returns the value of the "applicable_environment_types" field in the mutation.
func (m *RoleMutation) ApplicableEnvironmentTypes() (r []string, exists bool) {
	v := m.applicable_environment_types
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicableEnvironmentTypes returns the old "applicable_environment_types" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApplicableEnvironmentTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicableEnvironmentTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicableEnvironmentTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicableEnvironmentTypes: %w", err)
	}
	return oldValue.ApplicableEnvironmentTypes, nil
}

// AppendApplicableEnvironmentTypes adds s to the "applicable_environment_types" field.
func (m *RoleMutation) AppendApplicableEnvironmentTypes(s []string) {
	m.appendapplicable_environment_types = append(m.appendapplicable_environment_types, s...)
}

// AppendedApplicableEnvironmentTypes returns the list of values that were appended to the "applicable_environment_types" field in this mutation.
func (m *RoleMutation) AppendedApplicableEnvironmentTypes() ([]string, bool) {
	if len(m.appendapplicable_environment_types) == 0 {
		return nil, false
	}
	return m.appendapplicable_environment_types, true
}

// ClearApplicableEnvironmentTypes clears the value of the "applicable_environment_types" field.
func (m *RoleMutation) ClearApplicableEnvironmentTypes() {
	m.applicable_environment_types = nil
	m.appendapplicable_environment_types = nil
	m.clearedFields[role.FieldApplicableEnvironmentTypes] = struct{}{}
}

// ApplicableEnvironmentTypesCleared returns if the "applicable_environment_types" field was cleared in this mutation.
func (m *RoleMutation) ApplicableEnvironmentTypesCleared() bool {
	_, ok := m.clearedFields[role.FieldApplicableEnvironmentTypes]
	return ok
}

// ResetApplicableEnvironmentTypes resets all changes to the "applicable_environment_types" field.
func (m *RoleMutation) ResetApplicableEnvironmentTypes() {
	m.applicable_environment_types = nil
	m.appendapplicable_environment_types = nil
	delete(m.clearedFields, role.FieldApplicableEnvironmentTypes)
}

// SetSession sets the "session" field.
func (m *RoleMutation) SetSession(b bool) {
	m.session = &b
}

// Session returns the value of the "session" field in the mutation.
func (m *RoleMutation) Session() (r bool, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSession returns the old "session" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSession(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSession is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSession requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSession: %w", err)
	}
	return oldValue.Session, nil
}

// ResetSession resets all changes to the "session" field.
func (m *RoleMutation) ResetSession() {
	m.session = nil
}

// SetBuiltin sets the "builtin" field.
func (m *RoleMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *RoleMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *RoleMutation) ResetBuiltin() {
	m.builtin = nil
}

// AddSubjectIDs adds the "subjects" edge to the SubjectRoleRelationship entity by ids.
func (m *RoleMutation) AddSubjectIDs(ids ...object.ID) {
	if m.subjects == nil {
		m.subjects = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the SubjectRoleRelationship entity.
func (m *RoleMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the SubjectRoleRelationship entity was cleared.
func (m *RoleMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the SubjectRoleRelationship entity by IDs.
func (m *RoleMutation) RemoveSubjectIDs(ids ...object.ID) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the SubjectRoleRelationship entity.
func (m *RoleMutation) RemovedSubjectsIDs() (ids []object.ID) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *RoleMutation) SubjectsIDs() (ids []object.ID) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *RoleMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, role.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, role.FieldUpdateTime)
	}
	if m.kind != nil {
		fields = append(fields, role.FieldKind)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.policies != nil {
		fields = append(fields, role.FieldPolicies)
	}
	if m.applicable_environment_types != nil {
		fields = append(fields, role.FieldApplicableEnvironmentTypes)
	}
	if m.session != nil {
		fields = append(fields, role.FieldSession)
	}
	if m.builtin != nil {
		fields = append(fields, role.FieldBuiltin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreateTime:
		return m.CreateTime()
	case role.FieldUpdateTime:
		return m.UpdateTime()
	case role.FieldKind:
		return m.Kind()
	case role.FieldDescription:
		return m.Description()
	case role.FieldPolicies:
		return m.Policies()
	case role.FieldApplicableEnvironmentTypes:
		return m.ApplicableEnvironmentTypes()
	case role.FieldSession:
		return m.Session()
	case role.FieldBuiltin:
		return m.Builtin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case role.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case role.FieldKind:
		return m.OldKind(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldPolicies:
		return m.OldPolicies(ctx)
	case role.FieldApplicableEnvironmentTypes:
		return m.OldApplicableEnvironmentTypes(ctx)
	case role.FieldSession:
		return m.OldSession(ctx)
	case role.FieldBuiltin:
		return m.OldBuiltin(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case role.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case role.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldPolicies:
		v, ok := value.(types.RolePolicies)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicies(v)
		return nil
	case role.FieldApplicableEnvironmentTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicableEnvironmentTypes(v)
		return nil
	case role.FieldSession:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSession(v)
		return nil
	case role.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldApplicableEnvironmentTypes) {
		fields = append(fields, role.FieldApplicableEnvironmentTypes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldApplicableEnvironmentTypes:
		m.ClearApplicableEnvironmentTypes()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case role.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case role.FieldKind:
		m.ResetKind()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldPolicies:
		m.ResetPolicies()
		return nil
	case role.FieldApplicableEnvironmentTypes:
		m.ResetApplicableEnvironmentTypes()
		return nil
	case role.FieldSession:
		m.ResetSession()
		return nil
	case role.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subjects != nil {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubjects != nil {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubjects {
		edges = append(edges, role.EdgeSubjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeSubjects:
		return m.clearedsubjects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeSubjects:
		m.ResetSubjects()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *object.ID
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	value         *crypto.String
	hidden        *bool
	editable      *bool
	sensitive     *bool
	private       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id object.ID) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SettingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SettingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SettingMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SettingMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SettingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SettingMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(c crypto.String) {
	m.value = &c
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r crypto.String, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v crypto.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetHidden sets the "hidden" field.
func (m *SettingMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *SettingMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldHidden(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *SettingMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[setting.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *SettingMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[setting.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *SettingMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, setting.FieldHidden)
}

// SetEditable sets the "editable" field.
func (m *SettingMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *SettingMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldEditable(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ClearEditable clears the value of the "editable" field.
func (m *SettingMutation) ClearEditable() {
	m.editable = nil
	m.clearedFields[setting.FieldEditable] = struct{}{}
}

// EditableCleared returns if the "editable" field was cleared in this mutation.
func (m *SettingMutation) EditableCleared() bool {
	_, ok := m.clearedFields[setting.FieldEditable]
	return ok
}

// ResetEditable resets all changes to the "editable" field.
func (m *SettingMutation) ResetEditable() {
	m.editable = nil
	delete(m.clearedFields, setting.FieldEditable)
}

// SetSensitive sets the "sensitive" field.
func (m *SettingMutation) SetSensitive(b bool) {
	m.sensitive = &b
}

// Sensitive returns the value of the "sensitive" field in the mutation.
func (m *SettingMutation) Sensitive() (r bool, exists bool) {
	v := m.sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitive returns the old "sensitive" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSensitive(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitive: %w", err)
	}
	return oldValue.Sensitive, nil
}

// ClearSensitive clears the value of the "sensitive" field.
func (m *SettingMutation) ClearSensitive() {
	m.sensitive = nil
	m.clearedFields[setting.FieldSensitive] = struct{}{}
}

// SensitiveCleared returns if the "sensitive" field was cleared in this mutation.
func (m *SettingMutation) SensitiveCleared() bool {
	_, ok := m.clearedFields[setting.FieldSensitive]
	return ok
}

// ResetSensitive resets all changes to the "sensitive" field.
func (m *SettingMutation) ResetSensitive() {
	m.sensitive = nil
	delete(m.clearedFields, setting.FieldSensitive)
}

// SetPrivate sets the "private" field.
func (m *SettingMutation) SetPrivate(b bool) {
	m.private = &b
}

// Private returns the value of the "private" field in the mutation.
func (m *SettingMutation) Private() (r bool, exists bool) {
	v := m.private
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivate returns the old "private" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldPrivate(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivate: %w", err)
	}
	return oldValue.Private, nil
}

// ClearPrivate clears the value of the "private" field.
func (m *SettingMutation) ClearPrivate() {
	m.private = nil
	m.clearedFields[setting.FieldPrivate] = struct{}{}
}

// PrivateCleared returns if the "private" field was cleared in this mutation.
func (m *SettingMutation) PrivateCleared() bool {
	_, ok := m.clearedFields[setting.FieldPrivate]
	return ok
}

// ResetPrivate resets all changes to the "private" field.
func (m *SettingMutation) ResetPrivate() {
	m.private = nil
	delete(m.clearedFields, setting.FieldPrivate)
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, setting.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, setting.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.hidden != nil {
		fields = append(fields, setting.FieldHidden)
	}
	if m.editable != nil {
		fields = append(fields, setting.FieldEditable)
	}
	if m.sensitive != nil {
		fields = append(fields, setting.FieldSensitive)
	}
	if m.private != nil {
		fields = append(fields, setting.FieldPrivate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreateTime:
		return m.CreateTime()
	case setting.FieldUpdateTime:
		return m.UpdateTime()
	case setting.FieldName:
		return m.Name()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldHidden:
		return m.Hidden()
	case setting.FieldEditable:
		return m.Editable()
	case setting.FieldSensitive:
		return m.Sensitive()
	case setting.FieldPrivate:
		return m.Private()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case setting.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldHidden:
		return m.OldHidden(ctx)
	case setting.FieldEditable:
		return m.OldEditable(ctx)
	case setting.FieldSensitive:
		return m.OldSensitive(ctx)
	case setting.FieldPrivate:
		return m.OldPrivate(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case setting.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(crypto.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case setting.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	case setting.FieldSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitive(v)
		return nil
	case setting.FieldPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivate(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldHidden) {
		fields = append(fields, setting.FieldHidden)
	}
	if m.FieldCleared(setting.FieldEditable) {
		fields = append(fields, setting.FieldEditable)
	}
	if m.FieldCleared(setting.FieldSensitive) {
		fields = append(fields, setting.FieldSensitive)
	}
	if m.FieldCleared(setting.FieldPrivate) {
		fields = append(fields, setting.FieldPrivate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldHidden:
		m.ClearHidden()
		return nil
	case setting.FieldEditable:
		m.ClearEditable()
		return nil
	case setting.FieldSensitive:
		m.ClearSensitive()
		return nil
	case setting.FieldPrivate:
		m.ClearPrivate()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case setting.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldHidden:
		m.ResetHidden()
		return nil
	case setting.FieldEditable:
		m.ResetEditable()
		return nil
	case setting.FieldSensitive:
		m.ResetSensitive()
		return nil
	case setting.FieldPrivate:
		m.ResetPrivate()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SubjectMutation represents an operation that mutates the Subject nodes in the graph.
type SubjectMutation struct {
	config
	op            Op
	typ           string
	id            *object.ID
	create_time   *time.Time
	update_time   *time.Time
	kind          *string
	domain        *string
	name          *string
	description   *string
	builtin       *bool
	clearedFields map[string]struct{}
	tokens        map[object.ID]struct{}
	removedtokens map[object.ID]struct{}
	clearedtokens bool
	roles         map[object.ID]struct{}
	removedroles  map[object.ID]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Subject, error)
	predicates    []predicate.Subject
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows management of the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for the Subject entity.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the ID field of the mutation.
func withSubjectID(id object.ID) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subject entities.
func (m *SubjectMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SubjectMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubjectMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SubjectMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SubjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SubjectMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetKind sets the "kind" field.
func (m *SubjectMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *SubjectMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *SubjectMutation) ResetKind() {
	m.kind = nil
}

// SetDomain sets the "domain" field.
func (m *SubjectMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *SubjectMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *SubjectMutation) ResetDomain() {
	m.domain = nil
}

// SetName sets the "name" field.
func (m *SubjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subject.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subject.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subject.FieldDescription)
}

// SetBuiltin sets the "builtin" field.
func (m *SubjectMutation) SetBuiltin(b bool) {
	m.builtin = &b
}

// Builtin returns the value of the "builtin" field in the mutation.
func (m *SubjectMutation) Builtin() (r bool, exists bool) {
	v := m.builtin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltin returns the old "builtin" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldBuiltin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltin: %w", err)
	}
	return oldValue.Builtin, nil
}

// ResetBuiltin resets all changes to the "builtin" field.
func (m *SubjectMutation) ResetBuiltin() {
	m.builtin = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *SubjectMutation) AddTokenIDs(ids ...object.ID) {
	if m.tokens == nil {
		m.tokens = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *SubjectMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *SubjectMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *SubjectMutation) RemoveTokenIDs(ids ...object.ID) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *SubjectMutation) RemovedTokensIDs() (ids []object.ID) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *SubjectMutation) TokensIDs() (ids []object.ID) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *SubjectMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddRoleIDs adds the "roles" edge to the SubjectRoleRelationship entity by ids.
func (m *SubjectMutation) AddRoleIDs(ids ...object.ID) {
	if m.roles == nil {
		m.roles = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the SubjectRoleRelationship entity.
func (m *SubjectMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the SubjectRoleRelationship entity was cleared.
func (m *SubjectMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the SubjectRoleRelationship entity by IDs.
func (m *SubjectMutation) RemoveRoleIDs(ids ...object.ID) {
	if m.removedroles == nil {
		m.removedroles = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the SubjectRoleRelationship entity.
func (m *SubjectMutation) RemovedRolesIDs() (ids []object.ID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *SubjectMutation) RolesIDs() (ids []object.ID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *SubjectMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the SubjectMutation builder.
func (m *SubjectMutation) Where(ps ...predicate.Subject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, subject.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, subject.FieldUpdateTime)
	}
	if m.kind != nil {
		fields = append(fields, subject.FieldKind)
	}
	if m.domain != nil {
		fields = append(fields, subject.FieldDomain)
	}
	if m.name != nil {
		fields = append(fields, subject.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subject.FieldDescription)
	}
	if m.builtin != nil {
		fields = append(fields, subject.FieldBuiltin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCreateTime:
		return m.CreateTime()
	case subject.FieldUpdateTime:
		return m.UpdateTime()
	case subject.FieldKind:
		return m.Kind()
	case subject.FieldDomain:
		return m.Domain()
	case subject.FieldName:
		return m.Name()
	case subject.FieldDescription:
		return m.Description()
	case subject.FieldBuiltin:
		return m.Builtin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subject.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case subject.FieldKind:
		return m.OldKind(ctx)
	case subject.FieldDomain:
		return m.OldDomain(ctx)
	case subject.FieldName:
		return m.OldName(ctx)
	case subject.FieldDescription:
		return m.OldDescription(ctx)
	case subject.FieldBuiltin:
		return m.OldBuiltin(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subject.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case subject.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case subject.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case subject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subject.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subject.FieldBuiltin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltin(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subject.FieldDescription) {
		fields = append(fields, subject.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	switch name {
	case subject.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subject.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case subject.FieldKind:
		m.ResetKind()
		return nil
	case subject.FieldDomain:
		m.ResetDomain()
		return nil
	case subject.FieldName:
		m.ResetName()
		return nil
	case subject.FieldDescription:
		m.ResetDescription()
		return nil
	case subject.FieldBuiltin:
		m.ResetBuiltin()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tokens != nil {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.roles != nil {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtokens != nil {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.removedroles != nil {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtokens {
		edges = append(edges, subject.EdgeTokens)
	}
	if m.clearedroles {
		edges = append(edges, subject.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case subject.EdgeTokens:
		return m.clearedtokens
	case subject.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeTokens:
		m.ResetTokens()
		return nil
	case subject.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// SubjectRoleRelationshipMutation represents an operation that mutates the SubjectRoleRelationship nodes in the graph.
type SubjectRoleRelationshipMutation struct {
	config
	op             Op
	typ            string
	id             *object.ID
	create_time    *time.Time
	clearedFields  map[string]struct{}
	project        *object.ID
	clearedproject bool
	subject        *object.ID
	clearedsubject bool
	role           *string
	clearedrole    bool
	done           bool
	oldValue       func(context.Context) (*SubjectRoleRelationship, error)
	predicates     []predicate.SubjectRoleRelationship
}

var _ ent.Mutation = (*SubjectRoleRelationshipMutation)(nil)

// subjectRoleRelationshipOption allows management of the mutation configuration using functional options.
type subjectRoleRelationshipOption func(*SubjectRoleRelationshipMutation)

// newSubjectRoleRelationshipMutation creates new mutation for the SubjectRoleRelationship entity.
func newSubjectRoleRelationshipMutation(c config, op Op, opts ...subjectRoleRelationshipOption) *SubjectRoleRelationshipMutation {
	m := &SubjectRoleRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeSubjectRoleRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectRoleRelationshipID sets the ID field of the mutation.
func withSubjectRoleRelationshipID(id object.ID) subjectRoleRelationshipOption {
	return func(m *SubjectRoleRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *SubjectRoleRelationship
		)
		m.oldValue = func(ctx context.Context) (*SubjectRoleRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubjectRoleRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubjectRoleRelationship sets the old SubjectRoleRelationship of the mutation.
func withSubjectRoleRelationship(node *SubjectRoleRelationship) subjectRoleRelationshipOption {
	return func(m *SubjectRoleRelationshipMutation) {
		m.oldValue = func(context.Context) (*SubjectRoleRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectRoleRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectRoleRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubjectRoleRelationship entities.
func (m *SubjectRoleRelationshipMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectRoleRelationshipMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectRoleRelationshipMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubjectRoleRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SubjectRoleRelationshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubjectRoleRelationshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubjectRoleRelationshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *SubjectRoleRelationshipMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *SubjectRoleRelationshipMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *SubjectRoleRelationshipMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[subjectrolerelationship.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[subjectrolerelationship.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *SubjectRoleRelationshipMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, subjectrolerelationship.FieldProjectID)
}

// SetSubjectID sets the "subject_id" field.
func (m *SubjectRoleRelationshipMutation) SetSubjectID(o object.ID) {
	m.subject = &o
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *SubjectRoleRelationshipMutation) SubjectID() (r object.ID, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldSubjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *SubjectRoleRelationshipMutation) ResetSubjectID() {
	m.subject = nil
}

// SetRoleID sets the "role_id" field.
func (m *SubjectRoleRelationshipMutation) SetRoleID(s string) {
	m.role = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *SubjectRoleRelationshipMutation) RoleID() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the SubjectRoleRelationship entity.
// If the SubjectRoleRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectRoleRelationshipMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *SubjectRoleRelationshipMutation) ResetRoleID() {
	m.role = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *SubjectRoleRelationshipMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *SubjectRoleRelationshipMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *SubjectRoleRelationshipMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *SubjectRoleRelationshipMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *SubjectRoleRelationshipMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) SubjectIDs() (ids []object.ID) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *SubjectRoleRelationshipMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *SubjectRoleRelationshipMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *SubjectRoleRelationshipMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *SubjectRoleRelationshipMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *SubjectRoleRelationshipMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the SubjectRoleRelationshipMutation builder.
func (m *SubjectRoleRelationshipMutation) Where(ps ...predicate.SubjectRoleRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubjectRoleRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubjectRoleRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubjectRoleRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubjectRoleRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubjectRoleRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubjectRoleRelationship).
func (m *SubjectRoleRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectRoleRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, subjectrolerelationship.FieldCreateTime)
	}
	if m.project != nil {
		fields = append(fields, subjectrolerelationship.FieldProjectID)
	}
	if m.subject != nil {
		fields = append(fields, subjectrolerelationship.FieldSubjectID)
	}
	if m.role != nil {
		fields = append(fields, subjectrolerelationship.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectRoleRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		return m.CreateTime()
	case subjectrolerelationship.FieldProjectID:
		return m.ProjectID()
	case subjectrolerelationship.FieldSubjectID:
		return m.SubjectID()
	case subjectrolerelationship.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectRoleRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subjectrolerelationship.FieldProjectID:
		return m.OldProjectID(ctx)
	case subjectrolerelationship.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case subjectrolerelationship.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectRoleRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subjectrolerelationship.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case subjectrolerelationship.FieldSubjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case subjectrolerelationship.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectRoleRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectRoleRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectRoleRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubjectRoleRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectRoleRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subjectrolerelationship.FieldProjectID) {
		fields = append(fields, subjectrolerelationship.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ClearField(name string) error {
	switch name {
	case subjectrolerelationship.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ResetField(name string) error {
	switch name {
	case subjectrolerelationship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subjectrolerelationship.FieldProjectID:
		m.ResetProjectID()
		return nil
	case subjectrolerelationship.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case subjectrolerelationship.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectRoleRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, subjectrolerelationship.EdgeProject)
	}
	if m.subject != nil {
		edges = append(edges, subjectrolerelationship.EdgeSubject)
	}
	if m.role != nil {
		edges = append(edges, subjectrolerelationship.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectRoleRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subjectrolerelationship.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case subjectrolerelationship.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	case subjectrolerelationship.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectRoleRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectRoleRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, subjectrolerelationship.EdgeProject)
	}
	if m.clearedsubject {
		edges = append(edges, subjectrolerelationship.EdgeSubject)
	}
	if m.clearedrole {
		edges = append(edges, subjectrolerelationship.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectRoleRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case subjectrolerelationship.EdgeProject:
		return m.clearedproject
	case subjectrolerelationship.EdgeSubject:
		return m.clearedsubject
	case subjectrolerelationship.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case subjectrolerelationship.EdgeProject:
		m.ClearProject()
		return nil
	case subjectrolerelationship.EdgeSubject:
		m.ClearSubject()
		return nil
	case subjectrolerelationship.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectRoleRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case subjectrolerelationship.EdgeProject:
		m.ResetProject()
		return nil
	case subjectrolerelationship.EdgeSubject:
		m.ResetSubject()
		return nil
	case subjectrolerelationship.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown SubjectRoleRelationship edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op              Op
	typ             string
	id              *object.ID
	name            *string
	description     *string
	labels          *map[string]string
	create_time     *time.Time
	update_time     *time.Time
	status          *status.Status
	icon            *string
	source          *string
	clearedFields   map[string]struct{}
	versions        map[object.ID]struct{}
	removedversions map[object.ID]struct{}
	clearedversions bool
	catalog         *object.ID
	clearedcatalog  bool
	project         *object.ID
	clearedproject  bool
	done            bool
	oldValue        func(context.Context) (*Template, error)
	predicates      []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id object.ID) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Template entities.
func (m *TemplateMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[template.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[template.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, template.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *TemplateMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *TemplateMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *TemplateMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[template.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *TemplateMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[template.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *TemplateMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, template.FieldLabels)
}

// SetCreateTime sets the "create_time" field.
func (m *TemplateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TemplateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TemplateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TemplateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TemplateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TemplateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *TemplateMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TemplateMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TemplateMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[template.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TemplateMutation) StatusCleared() bool {
	_, ok := m.clearedFields[template.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TemplateMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, template.FieldStatus)
}

// SetIcon sets the "icon" field.
func (m *TemplateMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *TemplateMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *TemplateMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[template.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *TemplateMutation) IconCleared() bool {
	_, ok := m.clearedFields[template.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *TemplateMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, template.FieldIcon)
}

// SetSource sets the "source" field.
func (m *TemplateMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TemplateMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TemplateMutation) ResetSource() {
	m.source = nil
}

// SetCatalogID sets the "catalog_id" field.
func (m *TemplateMutation) SetCatalogID(o object.ID) {
	m.catalog = &o
}

// CatalogID returns the value of the "catalog_id" field in the mutation.
func (m *TemplateMutation) CatalogID() (r object.ID, exists bool) {
	v := m.catalog
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogID returns the old "catalog_id" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCatalogID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogID: %w", err)
	}
	return oldValue.CatalogID, nil
}

// ClearCatalogID clears the value of the "catalog_id" field.
func (m *TemplateMutation) ClearCatalogID() {
	m.catalog = nil
	m.clearedFields[template.FieldCatalogID] = struct{}{}
}

// CatalogIDCleared returns if the "catalog_id" field was cleared in this mutation.
func (m *TemplateMutation) CatalogIDCleared() bool {
	_, ok := m.clearedFields[template.FieldCatalogID]
	return ok
}

// ResetCatalogID resets all changes to the "catalog_id" field.
func (m *TemplateMutation) ResetCatalogID() {
	m.catalog = nil
	delete(m.clearedFields, template.FieldCatalogID)
}

// SetProjectID sets the "project_id" field.
func (m *TemplateMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TemplateMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *TemplateMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[template.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *TemplateMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[template.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TemplateMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, template.FieldProjectID)
}

// AddVersionIDs adds the "versions" edge to the TemplateVersion entity by ids.
func (m *TemplateMutation) AddVersionIDs(ids ...object.ID) {
	if m.versions == nil {
		m.versions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the TemplateVersion entity.
func (m *TemplateMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the TemplateVersion entity was cleared.
func (m *TemplateMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the TemplateVersion entity by IDs.
func (m *TemplateMutation) RemoveVersionIDs(ids ...object.ID) {
	if m.removedversions == nil {
		m.removedversions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the TemplateVersion entity.
func (m *TemplateMutation) RemovedVersionsIDs() (ids []object.ID) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *TemplateMutation) VersionsIDs() (ids []object.ID) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *TemplateMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// ClearCatalog clears the "catalog" edge to the Catalog entity.
func (m *TemplateMutation) ClearCatalog() {
	m.clearedcatalog = true
}

// CatalogCleared reports if the "catalog" edge to the Catalog entity was cleared.
func (m *TemplateMutation) CatalogCleared() bool {
	return m.CatalogIDCleared() || m.clearedcatalog
}

// CatalogIDs returns the "catalog" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CatalogID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) CatalogIDs() (ids []object.ID) {
	if id := m.catalog; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCatalog resets all changes to the "catalog" edge.
func (m *TemplateMutation) ResetCatalog() {
	m.catalog = nil
	m.clearedcatalog = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TemplateMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TemplateMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TemplateMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.description != nil {
		fields = append(fields, template.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, template.FieldLabels)
	}
	if m.create_time != nil {
		fields = append(fields, template.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, template.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, template.FieldStatus)
	}
	if m.icon != nil {
		fields = append(fields, template.FieldIcon)
	}
	if m.source != nil {
		fields = append(fields, template.FieldSource)
	}
	if m.catalog != nil {
		fields = append(fields, template.FieldCatalogID)
	}
	if m.project != nil {
		fields = append(fields, template.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldName:
		return m.Name()
	case template.FieldDescription:
		return m.Description()
	case template.FieldLabels:
		return m.Labels()
	case template.FieldCreateTime:
		return m.CreateTime()
	case template.FieldUpdateTime:
		return m.UpdateTime()
	case template.FieldStatus:
		return m.Status()
	case template.FieldIcon:
		return m.Icon()
	case template.FieldSource:
		return m.Source()
	case template.FieldCatalogID:
		return m.CatalogID()
	case template.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldDescription:
		return m.OldDescription(ctx)
	case template.FieldLabels:
		return m.OldLabels(ctx)
	case template.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case template.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case template.FieldStatus:
		return m.OldStatus(ctx)
	case template.FieldIcon:
		return m.OldIcon(ctx)
	case template.FieldSource:
		return m.OldSource(ctx)
	case template.FieldCatalogID:
		return m.OldCatalogID(ctx)
	case template.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case template.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case template.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case template.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case template.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case template.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case template.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case template.FieldCatalogID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogID(v)
		return nil
	case template.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldDescription) {
		fields = append(fields, template.FieldDescription)
	}
	if m.FieldCleared(template.FieldLabels) {
		fields = append(fields, template.FieldLabels)
	}
	if m.FieldCleared(template.FieldStatus) {
		fields = append(fields, template.FieldStatus)
	}
	if m.FieldCleared(template.FieldIcon) {
		fields = append(fields, template.FieldIcon)
	}
	if m.FieldCleared(template.FieldCatalogID) {
		fields = append(fields, template.FieldCatalogID)
	}
	if m.FieldCleared(template.FieldProjectID) {
		fields = append(fields, template.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldDescription:
		m.ClearDescription()
		return nil
	case template.FieldLabels:
		m.ClearLabels()
		return nil
	case template.FieldStatus:
		m.ClearStatus()
		return nil
	case template.FieldIcon:
		m.ClearIcon()
		return nil
	case template.FieldCatalogID:
		m.ClearCatalogID()
		return nil
	case template.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldDescription:
		m.ResetDescription()
		return nil
	case template.FieldLabels:
		m.ResetLabels()
		return nil
	case template.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case template.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case template.FieldStatus:
		m.ResetStatus()
		return nil
	case template.FieldIcon:
		m.ResetIcon()
		return nil
	case template.FieldSource:
		m.ResetSource()
		return nil
	case template.FieldCatalogID:
		m.ResetCatalogID()
		return nil
	case template.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.versions != nil {
		edges = append(edges, template.EdgeVersions)
	}
	if m.catalog != nil {
		edges = append(edges, template.EdgeCatalog)
	}
	if m.project != nil {
		edges = append(edges, template.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case template.EdgeCatalog:
		if id := m.catalog; id != nil {
			return []ent.Value{*id}
		}
	case template.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedversions != nil {
		edges = append(edges, template.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedversions {
		edges = append(edges, template.EdgeVersions)
	}
	if m.clearedcatalog {
		edges = append(edges, template.EdgeCatalog)
	}
	if m.clearedproject {
		edges = append(edges, template.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case template.EdgeVersions:
		return m.clearedversions
	case template.EdgeCatalog:
		return m.clearedcatalog
	case template.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	switch name {
	case template.EdgeCatalog:
		m.ClearCatalog()
		return nil
	case template.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	switch name {
	case template.EdgeVersions:
		m.ResetVersions()
		return nil
	case template.EdgeCatalog:
		m.ResetCatalog()
		return nil
	case template.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Template edge %s", name)
}

// TemplateVersionMutation represents an operation that mutates the TemplateVersion nodes in the graph.
type TemplateVersionMutation struct {
	config
	op                          Op
	typ                         string
	id                          *object.ID
	create_time                 *time.Time
	update_time                 *time.Time
	name                        *string
	version                     *string
	source                      *string
	schema                      *types.TemplateVersionSchema
	uiSchema                    *types.UISchema
	clearedFields               map[string]struct{}
	template                    *object.ID
	clearedtemplate             bool
	resources                   map[object.ID]struct{}
	removedresources            map[object.ID]struct{}
	clearedresources            bool
	resource_definitions        map[object.ID]struct{}
	removedresource_definitions map[object.ID]struct{}
	clearedresource_definitions bool
	project                     *object.ID
	clearedproject              bool
	done                        bool
	oldValue                    func(context.Context) (*TemplateVersion, error)
	predicates                  []predicate.TemplateVersion
}

var _ ent.Mutation = (*TemplateVersionMutation)(nil)

// templateVersionOption allows management of the mutation configuration using functional options.
type templateVersionOption func(*TemplateVersionMutation)

// newTemplateVersionMutation creates new mutation for the TemplateVersion entity.
func newTemplateVersionMutation(c config, op Op, opts ...templateVersionOption) *TemplateVersionMutation {
	m := &TemplateVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplateVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateVersionID sets the ID field of the mutation.
func withTemplateVersionID(id object.ID) templateVersionOption {
	return func(m *TemplateVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *TemplateVersion
		)
		m.oldValue = func(ctx context.Context) (*TemplateVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemplateVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplateVersion sets the old TemplateVersion of the mutation.
func withTemplateVersion(node *TemplateVersion) templateVersionOption {
	return func(m *TemplateVersionMutation) {
		m.oldValue = func(context.Context) (*TemplateVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemplateVersion entities.
func (m *TemplateVersionMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateVersionMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateVersionMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemplateVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TemplateVersionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TemplateVersionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TemplateVersionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TemplateVersionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TemplateVersionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TemplateVersionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTemplateID sets the "template_id" field.
func (m *TemplateVersionMutation) SetTemplateID(o object.ID) {
	m.template = &o
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *TemplateVersionMutation) TemplateID() (r object.ID, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldTemplateID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *TemplateVersionMutation) ResetTemplateID() {
	m.template = nil
}

// SetName sets the "name" field.
func (m *TemplateVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateVersionMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *TemplateVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *TemplateVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *TemplateVersionMutation) ResetVersion() {
	m.version = nil
}

// SetSource sets the "source" field.
func (m *TemplateVersionMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TemplateVersionMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TemplateVersionMutation) ResetSource() {
	m.source = nil
}

// SetSchema sets the "schema" field.
func (m *TemplateVersionMutation) SetSchema(tvs types.TemplateVersionSchema) {
	m.schema = &tvs
}

// Schema returns the value of the "schema" field in the mutation.
func (m *TemplateVersionMutation) Schema() (r types.TemplateVersionSchema, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchema returns the old "schema" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldSchema(ctx context.Context) (v types.TemplateVersionSchema, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchema: %w", err)
	}
	return oldValue.Schema, nil
}

// ResetSchema resets all changes to the "schema" field.
func (m *TemplateVersionMutation) ResetSchema() {
	m.schema = nil
}

// SetUiSchema sets the "uiSchema" field.
func (m *TemplateVersionMutation) SetUiSchema(ts types.UISchema) {
	m.uiSchema = &ts
}

// UiSchema returns the value of the "uiSchema" field in the mutation.
func (m *TemplateVersionMutation) UiSchema() (r types.UISchema, exists bool) {
	v := m.uiSchema
	if v == nil {
		return
	}
	return *v, true
}

// OldUiSchema returns the old "uiSchema" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldUiSchema(ctx context.Context) (v types.UISchema, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUiSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUiSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUiSchema: %w", err)
	}
	return oldValue.UiSchema, nil
}

// ResetUiSchema resets all changes to the "uiSchema" field.
func (m *TemplateVersionMutation) ResetUiSchema() {
	m.uiSchema = nil
}

// SetProjectID sets the "project_id" field.
func (m *TemplateVersionMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TemplateVersionMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the TemplateVersion entity.
// If the TemplateVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateVersionMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *TemplateVersionMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[templateversion.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *TemplateVersionMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[templateversion.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TemplateVersionMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, templateversion.FieldProjectID)
}

// ClearTemplate clears the "template" edge to the Template entity.
func (m *TemplateVersionMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared reports if the "template" edge to the Template entity was cleared.
func (m *TemplateVersionMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *TemplateVersionMutation) TemplateIDs() (ids []object.ID) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *TemplateVersionMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// AddResourceIDs adds the "resources" edge to the Resource entity by ids.
func (m *TemplateVersionMutation) AddResourceIDs(ids ...object.ID) {
	if m.resources == nil {
		m.resources = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the Resource entity.
func (m *TemplateVersionMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the Resource entity was cleared.
func (m *TemplateVersionMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the Resource entity by IDs.
func (m *TemplateVersionMutation) RemoveResourceIDs(ids ...object.ID) {
	if m.removedresources == nil {
		m.removedresources = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the Resource entity.
func (m *TemplateVersionMutation) RemovedResourcesIDs() (ids []object.ID) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *TemplateVersionMutation) ResourcesIDs() (ids []object.ID) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *TemplateVersionMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddResourceDefinitionIDs adds the "resource_definitions" edge to the ResourceDefinitionMatchingRule entity by ids.
func (m *TemplateVersionMutation) AddResourceDefinitionIDs(ids ...object.ID) {
	if m.resource_definitions == nil {
		m.resource_definitions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.resource_definitions[ids[i]] = struct{}{}
	}
}

// ClearResourceDefinitions clears the "resource_definitions" edge to the ResourceDefinitionMatchingRule entity.
func (m *TemplateVersionMutation) ClearResourceDefinitions() {
	m.clearedresource_definitions = true
}

// ResourceDefinitionsCleared reports if the "resource_definitions" edge to the ResourceDefinitionMatchingRule entity was cleared.
func (m *TemplateVersionMutation) ResourceDefinitionsCleared() bool {
	return m.clearedresource_definitions
}

// RemoveResourceDefinitionIDs removes the "resource_definitions" edge to the ResourceDefinitionMatchingRule entity by IDs.
func (m *TemplateVersionMutation) RemoveResourceDefinitionIDs(ids ...object.ID) {
	if m.removedresource_definitions == nil {
		m.removedresource_definitions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.resource_definitions, ids[i])
		m.removedresource_definitions[ids[i]] = struct{}{}
	}
}

// RemovedResourceDefinitions returns the removed IDs of the "resource_definitions" edge to the ResourceDefinitionMatchingRule entity.
func (m *TemplateVersionMutation) RemovedResourceDefinitionsIDs() (ids []object.ID) {
	for id := range m.removedresource_definitions {
		ids = append(ids, id)
	}
	return
}

// ResourceDefinitionsIDs returns the "resource_definitions" edge IDs in the mutation.
func (m *TemplateVersionMutation) ResourceDefinitionsIDs() (ids []object.ID) {
	for id := range m.resource_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetResourceDefinitions resets all changes to the "resource_definitions" edge.
func (m *TemplateVersionMutation) ResetResourceDefinitions() {
	m.resource_definitions = nil
	m.clearedresource_definitions = false
	m.removedresource_definitions = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TemplateVersionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TemplateVersionMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TemplateVersionMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TemplateVersionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the TemplateVersionMutation builder.
func (m *TemplateVersionMutation) Where(ps ...predicate.TemplateVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemplateVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemplateVersion).
func (m *TemplateVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, templateversion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, templateversion.FieldUpdateTime)
	}
	if m.template != nil {
		fields = append(fields, templateversion.FieldTemplateID)
	}
	if m.name != nil {
		fields = append(fields, templateversion.FieldName)
	}
	if m.version != nil {
		fields = append(fields, templateversion.FieldVersion)
	}
	if m.source != nil {
		fields = append(fields, templateversion.FieldSource)
	}
	if m.schema != nil {
		fields = append(fields, templateversion.FieldSchema)
	}
	if m.uiSchema != nil {
		fields = append(fields, templateversion.FieldUiSchema)
	}
	if m.project != nil {
		fields = append(fields, templateversion.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case templateversion.FieldCreateTime:
		return m.CreateTime()
	case templateversion.FieldUpdateTime:
		return m.UpdateTime()
	case templateversion.FieldTemplateID:
		return m.TemplateID()
	case templateversion.FieldName:
		return m.Name()
	case templateversion.FieldVersion:
		return m.Version()
	case templateversion.FieldSource:
		return m.Source()
	case templateversion.FieldSchema:
		return m.Schema()
	case templateversion.FieldUiSchema:
		return m.UiSchema()
	case templateversion.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case templateversion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case templateversion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case templateversion.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case templateversion.FieldName:
		return m.OldName(ctx)
	case templateversion.FieldVersion:
		return m.OldVersion(ctx)
	case templateversion.FieldSource:
		return m.OldSource(ctx)
	case templateversion.FieldSchema:
		return m.OldSchema(ctx)
	case templateversion.FieldUiSchema:
		return m.OldUiSchema(ctx)
	case templateversion.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown TemplateVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case templateversion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case templateversion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case templateversion.FieldTemplateID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case templateversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case templateversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case templateversion.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case templateversion.FieldSchema:
		v, ok := value.(types.TemplateVersionSchema)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchema(v)
		return nil
	case templateversion.FieldUiSchema:
		v, ok := value.(types.UISchema)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUiSchema(v)
		return nil
	case templateversion.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TemplateVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(templateversion.FieldProjectID) {
		fields = append(fields, templateversion.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateVersionMutation) ClearField(name string) error {
	switch name {
	case templateversion.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateVersionMutation) ResetField(name string) error {
	switch name {
	case templateversion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case templateversion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case templateversion.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case templateversion.FieldName:
		m.ResetName()
		return nil
	case templateversion.FieldVersion:
		m.ResetVersion()
		return nil
	case templateversion.FieldSource:
		m.ResetSource()
		return nil
	case templateversion.FieldSchema:
		m.ResetSchema()
		return nil
	case templateversion.FieldUiSchema:
		m.ResetUiSchema()
		return nil
	case templateversion.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.template != nil {
		edges = append(edges, templateversion.EdgeTemplate)
	}
	if m.resources != nil {
		edges = append(edges, templateversion.EdgeResources)
	}
	if m.resource_definitions != nil {
		edges = append(edges, templateversion.EdgeResourceDefinitions)
	}
	if m.project != nil {
		edges = append(edges, templateversion.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case templateversion.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case templateversion.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case templateversion.EdgeResourceDefinitions:
		ids := make([]ent.Value, 0, len(m.resource_definitions))
		for id := range m.resource_definitions {
			ids = append(ids, id)
		}
		return ids
	case templateversion.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedresources != nil {
		edges = append(edges, templateversion.EdgeResources)
	}
	if m.removedresource_definitions != nil {
		edges = append(edges, templateversion.EdgeResourceDefinitions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case templateversion.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case templateversion.EdgeResourceDefinitions:
		ids := make([]ent.Value, 0, len(m.removedresource_definitions))
		for id := range m.removedresource_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtemplate {
		edges = append(edges, templateversion.EdgeTemplate)
	}
	if m.clearedresources {
		edges = append(edges, templateversion.EdgeResources)
	}
	if m.clearedresource_definitions {
		edges = append(edges, templateversion.EdgeResourceDefinitions)
	}
	if m.clearedproject {
		edges = append(edges, templateversion.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case templateversion.EdgeTemplate:
		return m.clearedtemplate
	case templateversion.EdgeResources:
		return m.clearedresources
	case templateversion.EdgeResourceDefinitions:
		return m.clearedresource_definitions
	case templateversion.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateVersionMutation) ClearEdge(name string) error {
	switch name {
	case templateversion.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case templateversion.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateVersionMutation) ResetEdge(name string) error {
	switch name {
	case templateversion.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case templateversion.EdgeResources:
		m.ResetResources()
		return nil
	case templateversion.EdgeResourceDefinitions:
		m.ResetResourceDefinitions()
		return nil
	case templateversion.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown TemplateVersion edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op             Op
	typ            string
	id             *object.ID
	create_time    *time.Time
	kind           *string
	name           *string
	expiration     *time.Time
	value          *crypto.String
	clearedFields  map[string]struct{}
	subject        *object.ID
	clearedsubject bool
	done           bool
	oldValue       func(context.Context) (*Token, error)
	predicates     []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id object.ID) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *TokenMutation) SetSubjectID(o object.ID) {
	m.subject = &o
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *TokenMutation) SubjectID() (r object.ID, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSubjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *TokenMutation) ResetSubjectID() {
	m.subject = nil
}

// SetKind sets the "kind" field.
func (m *TokenMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *TokenMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *TokenMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *TokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TokenMutation) ResetName() {
	m.name = nil
}

// SetExpiration sets the "expiration" field.
func (m *TokenMutation) SetExpiration(t time.Time) {
	m.expiration = &t
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *TokenMutation) Expiration() (r time.Time, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiration(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ClearExpiration clears the value of the "expiration" field.
func (m *TokenMutation) ClearExpiration() {
	m.expiration = nil
	m.clearedFields[token.FieldExpiration] = struct{}{}
}

// ExpirationCleared returns if the "expiration" field was cleared in this mutation.
func (m *TokenMutation) ExpirationCleared() bool {
	_, ok := m.clearedFields[token.FieldExpiration]
	return ok
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *TokenMutation) ResetExpiration() {
	m.expiration = nil
	delete(m.clearedFields, token.FieldExpiration)
}

// SetValue sets the "value" field.
func (m *TokenMutation) SetValue(c crypto.String) {
	m.value = &c
}

// Value returns the value of the "value" field in the mutation.
func (m *TokenMutation) Value() (r crypto.String, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldValue(ctx context.Context) (v crypto.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *TokenMutation) ResetValue() {
	m.value = nil
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *TokenMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *TokenMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) SubjectIDs() (ids []object.ID) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *TokenMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, token.FieldCreateTime)
	}
	if m.subject != nil {
		fields = append(fields, token.FieldSubjectID)
	}
	if m.kind != nil {
		fields = append(fields, token.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, token.FieldName)
	}
	if m.expiration != nil {
		fields = append(fields, token.FieldExpiration)
	}
	if m.value != nil {
		fields = append(fields, token.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreateTime:
		return m.CreateTime()
	case token.FieldSubjectID:
		return m.SubjectID()
	case token.FieldKind:
		return m.Kind()
	case token.FieldName:
		return m.Name()
	case token.FieldExpiration:
		return m.Expiration()
	case token.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case token.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case token.FieldKind:
		return m.OldKind(ctx)
	case token.FieldName:
		return m.OldName(ctx)
	case token.FieldExpiration:
		return m.OldExpiration(ctx)
	case token.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case token.FieldSubjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case token.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case token.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case token.FieldExpiration:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case token.FieldValue:
		v, ok := value.(crypto.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldExpiration) {
		fields = append(fields, token.FieldExpiration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldExpiration:
		m.ClearExpiration()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case token.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case token.FieldKind:
		m.ResetKind()
		return nil
	case token.FieldName:
		m.ResetName()
		return nil
	case token.FieldExpiration:
		m.ResetExpiration()
		return nil
	case token.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subject != nil {
		edges = append(edges, token.EdgeSubject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubject {
		edges = append(edges, token.EdgeSubject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeSubject:
		return m.clearedsubject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// VariableMutation represents an operation that mutates the Variable nodes in the graph.
type VariableMutation struct {
	config
	op                 Op
	typ                string
	id                 *object.ID
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	value              *crypto.String
	sensitive          *bool
	description        *string
	clearedFields      map[string]struct{}
	project            *object.ID
	clearedproject     bool
	environment        *object.ID
	clearedenvironment bool
	done               bool
	oldValue           func(context.Context) (*Variable, error)
	predicates         []predicate.Variable
}

var _ ent.Mutation = (*VariableMutation)(nil)

// variableOption allows management of the mutation configuration using functional options.
type variableOption func(*VariableMutation)

// newVariableMutation creates new mutation for the Variable entity.
func newVariableMutation(c config, op Op, opts ...variableOption) *VariableMutation {
	m := &VariableMutation{
		config:        c,
		op:            op,
		typ:           TypeVariable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVariableID sets the ID field of the mutation.
func withVariableID(id object.ID) variableOption {
	return func(m *VariableMutation) {
		var (
			err   error
			once  sync.Once
			value *Variable
		)
		m.oldValue = func(ctx context.Context) (*Variable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Variable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVariable sets the old Variable of the mutation.
func withVariable(node *Variable) variableOption {
	return func(m *VariableMutation) {
		m.oldValue = func(context.Context) (*Variable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VariableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VariableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Variable entities.
func (m *VariableMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VariableMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VariableMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Variable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *VariableMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VariableMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VariableMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *VariableMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VariableMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VariableMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *VariableMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *VariableMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *VariableMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[variable.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *VariableMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[variable.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *VariableMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, variable.FieldProjectID)
}

// SetEnvironmentID sets the "environment_id" field.
func (m *VariableMutation) SetEnvironmentID(o object.ID) {
	m.environment = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *VariableMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ClearEnvironmentID clears the value of the "environment_id" field.
func (m *VariableMutation) ClearEnvironmentID() {
	m.environment = nil
	m.clearedFields[variable.FieldEnvironmentID] = struct{}{}
}

// EnvironmentIDCleared returns if the "environment_id" field was cleared in this mutation.
func (m *VariableMutation) EnvironmentIDCleared() bool {
	_, ok := m.clearedFields[variable.FieldEnvironmentID]
	return ok
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *VariableMutation) ResetEnvironmentID() {
	m.environment = nil
	delete(m.clearedFields, variable.FieldEnvironmentID)
}

// SetName sets the "name" field.
func (m *VariableMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VariableMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VariableMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *VariableMutation) SetValue(c crypto.String) {
	m.value = &c
}

// Value returns the value of the "value" field in the mutation.
func (m *VariableMutation) Value() (r crypto.String, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldValue(ctx context.Context) (v crypto.String, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *VariableMutation) ResetValue() {
	m.value = nil
}

// SetSensitive sets the "sensitive" field.
func (m *VariableMutation) SetSensitive(b bool) {
	m.sensitive = &b
}

// Sensitive returns the value of the "sensitive" field in the mutation.
func (m *VariableMutation) Sensitive() (r bool, exists bool) {
	v := m.sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitive returns the old "sensitive" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitive: %w", err)
	}
	return oldValue.Sensitive, nil
}

// ResetSensitive resets all changes to the "sensitive" field.
func (m *VariableMutation) ResetSensitive() {
	m.sensitive = nil
}

// SetDescription sets the "description" field.
func (m *VariableMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VariableMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Variable entity.
// If the Variable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariableMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VariableMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[variable.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VariableMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[variable.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VariableMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, variable.FieldDescription)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *VariableMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *VariableMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *VariableMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *VariableMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *VariableMutation) ClearEnvironment() {
	m.clearedenvironment = true
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *VariableMutation) EnvironmentCleared() bool {
	return m.EnvironmentIDCleared() || m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *VariableMutation) EnvironmentIDs() (ids []object.ID) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *VariableMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// Where appends a list predicates to the VariableMutation builder.
func (m *VariableMutation) Where(ps ...predicate.Variable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VariableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VariableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Variable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VariableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VariableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Variable).
func (m *VariableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VariableMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, variable.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, variable.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, variable.FieldProjectID)
	}
	if m.environment != nil {
		fields = append(fields, variable.FieldEnvironmentID)
	}
	if m.name != nil {
		fields = append(fields, variable.FieldName)
	}
	if m.value != nil {
		fields = append(fields, variable.FieldValue)
	}
	if m.sensitive != nil {
		fields = append(fields, variable.FieldSensitive)
	}
	if m.description != nil {
		fields = append(fields, variable.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VariableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case variable.FieldCreateTime:
		return m.CreateTime()
	case variable.FieldUpdateTime:
		return m.UpdateTime()
	case variable.FieldProjectID:
		return m.ProjectID()
	case variable.FieldEnvironmentID:
		return m.EnvironmentID()
	case variable.FieldName:
		return m.Name()
	case variable.FieldValue:
		return m.Value()
	case variable.FieldSensitive:
		return m.Sensitive()
	case variable.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VariableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case variable.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case variable.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case variable.FieldProjectID:
		return m.OldProjectID(ctx)
	case variable.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case variable.FieldName:
		return m.OldName(ctx)
	case variable.FieldValue:
		return m.OldValue(ctx)
	case variable.FieldSensitive:
		return m.OldSensitive(ctx)
	case variable.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Variable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case variable.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case variable.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case variable.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case variable.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case variable.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case variable.FieldValue:
		v, ok := value.(crypto.String)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case variable.FieldSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitive(v)
		return nil
	case variable.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Variable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VariableMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VariableMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariableMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Variable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VariableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(variable.FieldProjectID) {
		fields = append(fields, variable.FieldProjectID)
	}
	if m.FieldCleared(variable.FieldEnvironmentID) {
		fields = append(fields, variable.FieldEnvironmentID)
	}
	if m.FieldCleared(variable.FieldDescription) {
		fields = append(fields, variable.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VariableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VariableMutation) ClearField(name string) error {
	switch name {
	case variable.FieldProjectID:
		m.ClearProjectID()
		return nil
	case variable.FieldEnvironmentID:
		m.ClearEnvironmentID()
		return nil
	case variable.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Variable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VariableMutation) ResetField(name string) error {
	switch name {
	case variable.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case variable.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case variable.FieldProjectID:
		m.ResetProjectID()
		return nil
	case variable.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case variable.FieldName:
		m.ResetName()
		return nil
	case variable.FieldValue:
		m.ResetValue()
		return nil
	case variable.FieldSensitive:
		m.ResetSensitive()
		return nil
	case variable.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Variable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VariableMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, variable.EdgeProject)
	}
	if m.environment != nil {
		edges = append(edges, variable.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VariableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case variable.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case variable.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VariableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VariableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VariableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, variable.EdgeProject)
	}
	if m.clearedenvironment {
		edges = append(edges, variable.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VariableMutation) EdgeCleared(name string) bool {
	switch name {
	case variable.EdgeProject:
		return m.clearedproject
	case variable.EdgeEnvironment:
		return m.clearedenvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VariableMutation) ClearEdge(name string) error {
	switch name {
	case variable.EdgeProject:
		m.ClearProject()
		return nil
	case variable.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Variable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VariableMutation) ResetEdge(name string) error {
	switch name {
	case variable.EdgeProject:
		m.ResetProject()
		return nil
	case variable.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Variable edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op                Op
	typ               string
	id                *object.ID
	name              *string
	description       *string
	labels            *map[string]string
	annotations       *map[string]string
	create_time       *time.Time
	update_time       *time.Time
	environment_id    *object.ID
	_type             *string
	parallelism       *int
	addparallelism    *int
	timeout           *int
	addtimeout        *int
	version           *int
	addversion        *int
	variables         *types.WorkflowVariables
	appendvariables   types.WorkflowVariables
	clearedFields     map[string]struct{}
	project           *object.ID
	clearedproject    bool
	stages            map[object.ID]struct{}
	removedstages     map[object.ID]struct{}
	clearedstages     bool
	executions        map[object.ID]struct{}
	removedexecutions map[object.ID]struct{}
	clearedexecutions bool
	done              bool
	oldValue          func(context.Context) (*Workflow, error)
	predicates        []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id object.ID) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflow.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflow.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *WorkflowMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *WorkflowMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *WorkflowMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[workflow.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *WorkflowMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[workflow.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *WorkflowMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, workflow.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *WorkflowMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *WorkflowMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *WorkflowMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[workflow.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *WorkflowMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[workflow.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *WorkflowMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, workflow.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *WorkflowMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkflowMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkflowMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkflowMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkflowMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkflowMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *WorkflowMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *WorkflowMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *WorkflowMutation) ResetProjectID() {
	m.project = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *WorkflowMutation) SetEnvironmentID(o object.ID) {
	m.environment_id = &o
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *WorkflowMutation) EnvironmentID() (r object.ID, exists bool) {
	v := m.environment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldEnvironmentID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ClearEnvironmentID clears the value of the "environment_id" field.
func (m *WorkflowMutation) ClearEnvironmentID() {
	m.environment_id = nil
	m.clearedFields[workflow.FieldEnvironmentID] = struct{}{}
}

// EnvironmentIDCleared returns if the "environment_id" field was cleared in this mutation.
func (m *WorkflowMutation) EnvironmentIDCleared() bool {
	_, ok := m.clearedFields[workflow.FieldEnvironmentID]
	return ok
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *WorkflowMutation) ResetEnvironmentID() {
	m.environment_id = nil
	delete(m.clearedFields, workflow.FieldEnvironmentID)
}

// SetType sets the "type" field.
func (m *WorkflowMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkflowMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WorkflowMutation) ResetType() {
	m._type = nil
}

// SetParallelism sets the "parallelism" field.
func (m *WorkflowMutation) SetParallelism(i int) {
	m.parallelism = &i
	m.addparallelism = nil
}

// Parallelism returns the value of the "parallelism" field in the mutation.
func (m *WorkflowMutation) Parallelism() (r int, exists bool) {
	v := m.parallelism
	if v == nil {
		return
	}
	return *v, true
}

// OldParallelism returns the old "parallelism" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldParallelism(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParallelism is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParallelism requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParallelism: %w", err)
	}
	return oldValue.Parallelism, nil
}

// AddParallelism adds i to the "parallelism" field.
func (m *WorkflowMutation) AddParallelism(i int) {
	if m.addparallelism != nil {
		*m.addparallelism += i
	} else {
		m.addparallelism = &i
	}
}

// AddedParallelism returns the value that was added to the "parallelism" field in this mutation.
func (m *WorkflowMutation) AddedParallelism() (r int, exists bool) {
	v := m.addparallelism
	if v == nil {
		return
	}
	return *v, true
}

// ResetParallelism resets all changes to the "parallelism" field.
func (m *WorkflowMutation) ResetParallelism() {
	m.parallelism = nil
	m.addparallelism = nil
}

// SetTimeout sets the "timeout" field.
func (m *WorkflowMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *WorkflowMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *WorkflowMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *WorkflowMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *WorkflowMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetVersion sets the "version" field.
func (m *WorkflowMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WorkflowMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WorkflowMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WorkflowMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *WorkflowMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetVariables sets the "variables" field.
func (m *WorkflowMutation) SetVariables(tv types.WorkflowVariables) {
	m.variables = &tv
	m.appendvariables = nil
}

// Variables returns the value of the "variables" field in the mutation.
func (m *WorkflowMutation) Variables() (r types.WorkflowVariables, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldVariables(ctx context.Context) (v types.WorkflowVariables, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// AppendVariables adds tv to the "variables" field.
func (m *WorkflowMutation) AppendVariables(tv types.WorkflowVariables) {
	m.appendvariables = append(m.appendvariables, tv...)
}

// AppendedVariables returns the list of values that were appended to the "variables" field in this mutation.
func (m *WorkflowMutation) AppendedVariables() (types.WorkflowVariables, bool) {
	if len(m.appendvariables) == 0 {
		return nil, false
	}
	return m.appendvariables, true
}

// ClearVariables clears the value of the "variables" field.
func (m *WorkflowMutation) ClearVariables() {
	m.variables = nil
	m.appendvariables = nil
	m.clearedFields[workflow.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *WorkflowMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[workflow.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *WorkflowMutation) ResetVariables() {
	m.variables = nil
	m.appendvariables = nil
	delete(m.clearedFields, workflow.FieldVariables)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *WorkflowMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *WorkflowMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *WorkflowMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddStageIDs adds the "stages" edge to the WorkflowStage entity by ids.
func (m *WorkflowMutation) AddStageIDs(ids ...object.ID) {
	if m.stages == nil {
		m.stages = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.stages[ids[i]] = struct{}{}
	}
}

// ClearStages clears the "stages" edge to the WorkflowStage entity.
func (m *WorkflowMutation) ClearStages() {
	m.clearedstages = true
}

// StagesCleared reports if the "stages" edge to the WorkflowStage entity was cleared.
func (m *WorkflowMutation) StagesCleared() bool {
	return m.clearedstages
}

// RemoveStageIDs removes the "stages" edge to the WorkflowStage entity by IDs.
func (m *WorkflowMutation) RemoveStageIDs(ids ...object.ID) {
	if m.removedstages == nil {
		m.removedstages = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.stages, ids[i])
		m.removedstages[ids[i]] = struct{}{}
	}
}

// RemovedStages returns the removed IDs of the "stages" edge to the WorkflowStage entity.
func (m *WorkflowMutation) RemovedStagesIDs() (ids []object.ID) {
	for id := range m.removedstages {
		ids = append(ids, id)
	}
	return
}

// StagesIDs returns the "stages" edge IDs in the mutation.
func (m *WorkflowMutation) StagesIDs() (ids []object.ID) {
	for id := range m.stages {
		ids = append(ids, id)
	}
	return
}

// ResetStages resets all changes to the "stages" edge.
func (m *WorkflowMutation) ResetStages() {
	m.stages = nil
	m.clearedstages = false
	m.removedstages = nil
}

// AddExecutionIDs adds the "executions" edge to the WorkflowExecution entity by ids.
func (m *WorkflowMutation) AddExecutionIDs(ids ...object.ID) {
	if m.executions == nil {
		m.executions = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the WorkflowExecution entity.
func (m *WorkflowMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the WorkflowExecution entity was cleared.
func (m *WorkflowMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the WorkflowExecution entity by IDs.
func (m *WorkflowMutation) RemoveExecutionIDs(ids ...object.ID) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the WorkflowExecution entity.
func (m *WorkflowMutation) RemovedExecutionsIDs() (ids []object.ID) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *WorkflowMutation) ExecutionsIDs() (ids []object.ID) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *WorkflowMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, workflow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflow.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, workflow.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, workflow.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, workflow.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workflow.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, workflow.FieldProjectID)
	}
	if m.environment_id != nil {
		fields = append(fields, workflow.FieldEnvironmentID)
	}
	if m._type != nil {
		fields = append(fields, workflow.FieldType)
	}
	if m.parallelism != nil {
		fields = append(fields, workflow.FieldParallelism)
	}
	if m.timeout != nil {
		fields = append(fields, workflow.FieldTimeout)
	}
	if m.version != nil {
		fields = append(fields, workflow.FieldVersion)
	}
	if m.variables != nil {
		fields = append(fields, workflow.FieldVariables)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldName:
		return m.Name()
	case workflow.FieldDescription:
		return m.Description()
	case workflow.FieldLabels:
		return m.Labels()
	case workflow.FieldAnnotations:
		return m.Annotations()
	case workflow.FieldCreateTime:
		return m.CreateTime()
	case workflow.FieldUpdateTime:
		return m.UpdateTime()
	case workflow.FieldProjectID:
		return m.ProjectID()
	case workflow.FieldEnvironmentID:
		return m.EnvironmentID()
	case workflow.FieldType:
		return m.GetType()
	case workflow.FieldParallelism:
		return m.Parallelism()
	case workflow.FieldTimeout:
		return m.Timeout()
	case workflow.FieldVersion:
		return m.Version()
	case workflow.FieldVariables:
		return m.Variables()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldName:
		return m.OldName(ctx)
	case workflow.FieldDescription:
		return m.OldDescription(ctx)
	case workflow.FieldLabels:
		return m.OldLabels(ctx)
	case workflow.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case workflow.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workflow.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workflow.FieldProjectID:
		return m.OldProjectID(ctx)
	case workflow.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case workflow.FieldType:
		return m.OldType(ctx)
	case workflow.FieldParallelism:
		return m.OldParallelism(ctx)
	case workflow.FieldTimeout:
		return m.OldTimeout(ctx)
	case workflow.FieldVersion:
		return m.OldVersion(ctx)
	case workflow.FieldVariables:
		return m.OldVariables(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflow.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case workflow.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case workflow.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workflow.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workflow.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case workflow.FieldEnvironmentID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case workflow.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case workflow.FieldParallelism:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParallelism(v)
		return nil
	case workflow.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case workflow.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case workflow.FieldVariables:
		v, ok := value.(types.WorkflowVariables)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	var fields []string
	if m.addparallelism != nil {
		fields = append(fields, workflow.FieldParallelism)
	}
	if m.addtimeout != nil {
		fields = append(fields, workflow.FieldTimeout)
	}
	if m.addversion != nil {
		fields = append(fields, workflow.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldParallelism:
		return m.AddedParallelism()
	case workflow.FieldTimeout:
		return m.AddedTimeout()
	case workflow.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldParallelism:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParallelism(v)
		return nil
	case workflow.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	case workflow.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldDescription) {
		fields = append(fields, workflow.FieldDescription)
	}
	if m.FieldCleared(workflow.FieldLabels) {
		fields = append(fields, workflow.FieldLabels)
	}
	if m.FieldCleared(workflow.FieldAnnotations) {
		fields = append(fields, workflow.FieldAnnotations)
	}
	if m.FieldCleared(workflow.FieldEnvironmentID) {
		fields = append(fields, workflow.FieldEnvironmentID)
	}
	if m.FieldCleared(workflow.FieldVariables) {
		fields = append(fields, workflow.FieldVariables)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldDescription:
		m.ClearDescription()
		return nil
	case workflow.FieldLabels:
		m.ClearLabels()
		return nil
	case workflow.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case workflow.FieldEnvironmentID:
		m.ClearEnvironmentID()
		return nil
	case workflow.FieldVariables:
		m.ClearVariables()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldName:
		m.ResetName()
		return nil
	case workflow.FieldDescription:
		m.ResetDescription()
		return nil
	case workflow.FieldLabels:
		m.ResetLabels()
		return nil
	case workflow.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case workflow.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workflow.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workflow.FieldProjectID:
		m.ResetProjectID()
		return nil
	case workflow.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case workflow.FieldType:
		m.ResetType()
		return nil
	case workflow.FieldParallelism:
		m.ResetParallelism()
		return nil
	case workflow.FieldTimeout:
		m.ResetTimeout()
		return nil
	case workflow.FieldVersion:
		m.ResetVersion()
		return nil
	case workflow.FieldVariables:
		m.ResetVariables()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, workflow.EdgeProject)
	}
	if m.stages != nil {
		edges = append(edges, workflow.EdgeStages)
	}
	if m.executions != nil {
		edges = append(edges, workflow.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeStages:
		ids := make([]ent.Value, 0, len(m.stages))
		for id := range m.stages {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstages != nil {
		edges = append(edges, workflow.EdgeStages)
	}
	if m.removedexecutions != nil {
		edges = append(edges, workflow.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeStages:
		ids := make([]ent.Value, 0, len(m.removedstages))
		for id := range m.removedstages {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, workflow.EdgeProject)
	}
	if m.clearedstages {
		edges = append(edges, workflow.EdgeStages)
	}
	if m.clearedexecutions {
		edges = append(edges, workflow.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeProject:
		return m.clearedproject
	case workflow.EdgeStages:
		return m.clearedstages
	case workflow.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	case workflow.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeProject:
		m.ResetProject()
		return nil
	case workflow.EdgeStages:
		m.ResetStages()
		return nil
	case workflow.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}

// WorkflowExecutionMutation represents an operation that mutates the WorkflowExecution nodes in the graph.
type WorkflowExecutionMutation struct {
	config
	op              Op
	typ             string
	id              *object.ID
	name            *string
	description     *string
	labels          *map[string]string
	annotations     *map[string]string
	create_time     *time.Time
	update_time     *time.Time
	status          *status.Status
	version         *int
	addversion      *int
	_type           *string
	subject_id      *object.ID
	execute_time    *time.Time
	times           *int
	addtimes        *int
	duration        *int
	addduration     *int
	parallelism     *int
	addparallelism  *int
	timeout         *int
	addtimeout      *int
	trigger         *types.WorkflowExecutionTrigger
	clearedFields   map[string]struct{}
	project         *object.ID
	clearedproject  bool
	stages          map[object.ID]struct{}
	removedstages   map[object.ID]struct{}
	clearedstages   bool
	workflow        *object.ID
	clearedworkflow bool
	done            bool
	oldValue        func(context.Context) (*WorkflowExecution, error)
	predicates      []predicate.WorkflowExecution
}

var _ ent.Mutation = (*WorkflowExecutionMutation)(nil)

// workflowExecutionOption allows management of the mutation configuration using functional options.
type workflowExecutionOption func(*WorkflowExecutionMutation)

// newWorkflowExecutionMutation creates new mutation for the WorkflowExecution entity.
func newWorkflowExecutionMutation(c config, op Op, opts ...workflowExecutionOption) *WorkflowExecutionMutation {
	m := &WorkflowExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowExecutionID sets the ID field of the mutation.
func withWorkflowExecutionID(id object.ID) workflowExecutionOption {
	return func(m *WorkflowExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowExecution
		)
		m.oldValue = func(ctx context.Context) (*WorkflowExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowExecution sets the old WorkflowExecution of the mutation.
func withWorkflowExecution(node *WorkflowExecution) workflowExecutionOption {
	return func(m *WorkflowExecutionMutation) {
		m.oldValue = func(context.Context) (*WorkflowExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowExecution entities.
func (m *WorkflowExecutionMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowExecutionMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowExecutionMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowExecutionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowExecutionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowExecutionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowExecutionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowExecutionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowExecutionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflowexecution.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowExecutionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflowexecution.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *WorkflowExecutionMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *WorkflowExecutionMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *WorkflowExecutionMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[workflowexecution.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *WorkflowExecutionMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, workflowexecution.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *WorkflowExecutionMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *WorkflowExecutionMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *WorkflowExecutionMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[workflowexecution.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *WorkflowExecutionMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, workflowexecution.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *WorkflowExecutionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkflowExecutionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkflowExecutionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkflowExecutionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkflowExecutionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkflowExecutionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowExecutionMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowExecutionMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *WorkflowExecutionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[workflowexecution.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowExecutionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, workflowexecution.FieldStatus)
}

// SetProjectID sets the "project_id" field.
func (m *WorkflowExecutionMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *WorkflowExecutionMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *WorkflowExecutionMutation) ResetProjectID() {
	m.project = nil
}

// SetVersion sets the "version" field.
func (m *WorkflowExecutionMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WorkflowExecutionMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WorkflowExecutionMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WorkflowExecutionMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *WorkflowExecutionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetType sets the "type" field.
func (m *WorkflowExecutionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkflowExecutionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WorkflowExecutionMutation) ResetType() {
	m._type = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowExecutionMutation) SetWorkflowID(o object.ID) {
	m.workflow = &o
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowExecutionMutation) WorkflowID() (r object.ID, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldWorkflowID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowExecutionMutation) ResetWorkflowID() {
	m.workflow = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *WorkflowExecutionMutation) SetSubjectID(o object.ID) {
	m.subject_id = &o
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *WorkflowExecutionMutation) SubjectID() (r object.ID, exists bool) {
	v := m.subject_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldSubjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *WorkflowExecutionMutation) ResetSubjectID() {
	m.subject_id = nil
}

// SetExecuteTime sets the "execute_time" field.
func (m *WorkflowExecutionMutation) SetExecuteTime(t time.Time) {
	m.execute_time = &t
}

// ExecuteTime returns the value of the "execute_time" field in the mutation.
func (m *WorkflowExecutionMutation) ExecuteTime() (r time.Time, exists bool) {
	v := m.execute_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExecuteTime returns the old "execute_time" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldExecuteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecuteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecuteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecuteTime: %w", err)
	}
	return oldValue.ExecuteTime, nil
}

// ClearExecuteTime clears the value of the "execute_time" field.
func (m *WorkflowExecutionMutation) ClearExecuteTime() {
	m.execute_time = nil
	m.clearedFields[workflowexecution.FieldExecuteTime] = struct{}{}
}

// ExecuteTimeCleared returns if the "execute_time" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) ExecuteTimeCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldExecuteTime]
	return ok
}

// ResetExecuteTime resets all changes to the "execute_time" field.
func (m *WorkflowExecutionMutation) ResetExecuteTime() {
	m.execute_time = nil
	delete(m.clearedFields, workflowexecution.FieldExecuteTime)
}

// SetTimes sets the "times" field.
func (m *WorkflowExecutionMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the value of the "times" field in the mutation.
func (m *WorkflowExecutionMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old "times" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to the "times" field.
func (m *WorkflowExecutionMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the "times" field in this mutation.
func (m *WorkflowExecutionMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes resets all changes to the "times" field.
func (m *WorkflowExecutionMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetDuration sets the "duration" field.
func (m *WorkflowExecutionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *WorkflowExecutionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *WorkflowExecutionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *WorkflowExecutionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *WorkflowExecutionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetParallelism sets the "parallelism" field.
func (m *WorkflowExecutionMutation) SetParallelism(i int) {
	m.parallelism = &i
	m.addparallelism = nil
}

// Parallelism returns the value of the "parallelism" field in the mutation.
func (m *WorkflowExecutionMutation) Parallelism() (r int, exists bool) {
	v := m.parallelism
	if v == nil {
		return
	}
	return *v, true
}

// OldParallelism returns the old "parallelism" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldParallelism(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParallelism is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParallelism requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParallelism: %w", err)
	}
	return oldValue.Parallelism, nil
}

// AddParallelism adds i to the "parallelism" field.
func (m *WorkflowExecutionMutation) AddParallelism(i int) {
	if m.addparallelism != nil {
		*m.addparallelism += i
	} else {
		m.addparallelism = &i
	}
}

// AddedParallelism returns the value that was added to the "parallelism" field in this mutation.
func (m *WorkflowExecutionMutation) AddedParallelism() (r int, exists bool) {
	v := m.addparallelism
	if v == nil {
		return
	}
	return *v, true
}

// ResetParallelism resets all changes to the "parallelism" field.
func (m *WorkflowExecutionMutation) ResetParallelism() {
	m.parallelism = nil
	m.addparallelism = nil
}

// SetTimeout sets the "timeout" field.
func (m *WorkflowExecutionMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *WorkflowExecutionMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *WorkflowExecutionMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *WorkflowExecutionMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *WorkflowExecutionMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetTrigger sets the "trigger" field.
func (m *WorkflowExecutionMutation) SetTrigger(tet types.WorkflowExecutionTrigger) {
	m.trigger = &tet
}

// Trigger returns the value of the "trigger" field in the mutation.
func (m *WorkflowExecutionMutation) Trigger() (r types.WorkflowExecutionTrigger, exists bool) {
	v := m.trigger
	if v == nil {
		return
	}
	return *v, true
}

// OldTrigger returns the old "trigger" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldTrigger(ctx context.Context) (v types.WorkflowExecutionTrigger, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrigger is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrigger requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrigger: %w", err)
	}
	return oldValue.Trigger, nil
}

// ResetTrigger resets all changes to the "trigger" field.
func (m *WorkflowExecutionMutation) ResetTrigger() {
	m.trigger = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *WorkflowExecutionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *WorkflowExecutionMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *WorkflowExecutionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddStageIDs adds the "stages" edge to the WorkflowStageExecution entity by ids.
func (m *WorkflowExecutionMutation) AddStageIDs(ids ...object.ID) {
	if m.stages == nil {
		m.stages = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.stages[ids[i]] = struct{}{}
	}
}

// ClearStages clears the "stages" edge to the WorkflowStageExecution entity.
func (m *WorkflowExecutionMutation) ClearStages() {
	m.clearedstages = true
}

// StagesCleared reports if the "stages" edge to the WorkflowStageExecution entity was cleared.
func (m *WorkflowExecutionMutation) StagesCleared() bool {
	return m.clearedstages
}

// RemoveStageIDs removes the "stages" edge to the WorkflowStageExecution entity by IDs.
func (m *WorkflowExecutionMutation) RemoveStageIDs(ids ...object.ID) {
	if m.removedstages == nil {
		m.removedstages = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.stages, ids[i])
		m.removedstages[ids[i]] = struct{}{}
	}
}

// RemovedStages returns the removed IDs of the "stages" edge to the WorkflowStageExecution entity.
func (m *WorkflowExecutionMutation) RemovedStagesIDs() (ids []object.ID) {
	for id := range m.removedstages {
		ids = append(ids, id)
	}
	return
}

// StagesIDs returns the "stages" edge IDs in the mutation.
func (m *WorkflowExecutionMutation) StagesIDs() (ids []object.ID) {
	for id := range m.stages {
		ids = append(ids, id)
	}
	return
}

// ResetStages resets all changes to the "stages" edge.
func (m *WorkflowExecutionMutation) ResetStages() {
	m.stages = nil
	m.clearedstages = false
	m.removedstages = nil
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowExecutionMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowExecutionMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowExecutionMutation) WorkflowIDs() (ids []object.ID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowExecutionMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the WorkflowExecutionMutation builder.
func (m *WorkflowExecutionMutation) Where(ps ...predicate.WorkflowExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowExecution).
func (m *WorkflowExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowExecutionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, workflowexecution.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflowexecution.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, workflowexecution.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, workflowexecution.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, workflowexecution.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workflowexecution.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, workflowexecution.FieldStatus)
	}
	if m.project != nil {
		fields = append(fields, workflowexecution.FieldProjectID)
	}
	if m.version != nil {
		fields = append(fields, workflowexecution.FieldVersion)
	}
	if m._type != nil {
		fields = append(fields, workflowexecution.FieldType)
	}
	if m.workflow != nil {
		fields = append(fields, workflowexecution.FieldWorkflowID)
	}
	if m.subject_id != nil {
		fields = append(fields, workflowexecution.FieldSubjectID)
	}
	if m.execute_time != nil {
		fields = append(fields, workflowexecution.FieldExecuteTime)
	}
	if m.times != nil {
		fields = append(fields, workflowexecution.FieldTimes)
	}
	if m.duration != nil {
		fields = append(fields, workflowexecution.FieldDuration)
	}
	if m.parallelism != nil {
		fields = append(fields, workflowexecution.FieldParallelism)
	}
	if m.timeout != nil {
		fields = append(fields, workflowexecution.FieldTimeout)
	}
	if m.trigger != nil {
		fields = append(fields, workflowexecution.FieldTrigger)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowexecution.FieldName:
		return m.Name()
	case workflowexecution.FieldDescription:
		return m.Description()
	case workflowexecution.FieldLabels:
		return m.Labels()
	case workflowexecution.FieldAnnotations:
		return m.Annotations()
	case workflowexecution.FieldCreateTime:
		return m.CreateTime()
	case workflowexecution.FieldUpdateTime:
		return m.UpdateTime()
	case workflowexecution.FieldStatus:
		return m.Status()
	case workflowexecution.FieldProjectID:
		return m.ProjectID()
	case workflowexecution.FieldVersion:
		return m.Version()
	case workflowexecution.FieldType:
		return m.GetType()
	case workflowexecution.FieldWorkflowID:
		return m.WorkflowID()
	case workflowexecution.FieldSubjectID:
		return m.SubjectID()
	case workflowexecution.FieldExecuteTime:
		return m.ExecuteTime()
	case workflowexecution.FieldTimes:
		return m.Times()
	case workflowexecution.FieldDuration:
		return m.Duration()
	case workflowexecution.FieldParallelism:
		return m.Parallelism()
	case workflowexecution.FieldTimeout:
		return m.Timeout()
	case workflowexecution.FieldTrigger:
		return m.Trigger()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowexecution.FieldName:
		return m.OldName(ctx)
	case workflowexecution.FieldDescription:
		return m.OldDescription(ctx)
	case workflowexecution.FieldLabels:
		return m.OldLabels(ctx)
	case workflowexecution.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case workflowexecution.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workflowexecution.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workflowexecution.FieldStatus:
		return m.OldStatus(ctx)
	case workflowexecution.FieldProjectID:
		return m.OldProjectID(ctx)
	case workflowexecution.FieldVersion:
		return m.OldVersion(ctx)
	case workflowexecution.FieldType:
		return m.OldType(ctx)
	case workflowexecution.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflowexecution.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case workflowexecution.FieldExecuteTime:
		return m.OldExecuteTime(ctx)
	case workflowexecution.FieldTimes:
		return m.OldTimes(ctx)
	case workflowexecution.FieldDuration:
		return m.OldDuration(ctx)
	case workflowexecution.FieldParallelism:
		return m.OldParallelism(ctx)
	case workflowexecution.FieldTimeout:
		return m.OldTimeout(ctx)
	case workflowexecution.FieldTrigger:
		return m.OldTrigger(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowexecution.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflowexecution.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflowexecution.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case workflowexecution.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case workflowexecution.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workflowexecution.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workflowexecution.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowexecution.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case workflowexecution.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case workflowexecution.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case workflowexecution.FieldWorkflowID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflowexecution.FieldSubjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case workflowexecution.FieldExecuteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecuteTime(v)
		return nil
	case workflowexecution.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case workflowexecution.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case workflowexecution.FieldParallelism:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParallelism(v)
		return nil
	case workflowexecution.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case workflowexecution.FieldTrigger:
		v, ok := value.(types.WorkflowExecutionTrigger)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrigger(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, workflowexecution.FieldVersion)
	}
	if m.addtimes != nil {
		fields = append(fields, workflowexecution.FieldTimes)
	}
	if m.addduration != nil {
		fields = append(fields, workflowexecution.FieldDuration)
	}
	if m.addparallelism != nil {
		fields = append(fields, workflowexecution.FieldParallelism)
	}
	if m.addtimeout != nil {
		fields = append(fields, workflowexecution.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowexecution.FieldVersion:
		return m.AddedVersion()
	case workflowexecution.FieldTimes:
		return m.AddedTimes()
	case workflowexecution.FieldDuration:
		return m.AddedDuration()
	case workflowexecution.FieldParallelism:
		return m.AddedParallelism()
	case workflowexecution.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowexecution.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case workflowexecution.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case workflowexecution.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case workflowexecution.FieldParallelism:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParallelism(v)
		return nil
	case workflowexecution.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowexecution.FieldDescription) {
		fields = append(fields, workflowexecution.FieldDescription)
	}
	if m.FieldCleared(workflowexecution.FieldLabels) {
		fields = append(fields, workflowexecution.FieldLabels)
	}
	if m.FieldCleared(workflowexecution.FieldAnnotations) {
		fields = append(fields, workflowexecution.FieldAnnotations)
	}
	if m.FieldCleared(workflowexecution.FieldStatus) {
		fields = append(fields, workflowexecution.FieldStatus)
	}
	if m.FieldCleared(workflowexecution.FieldExecuteTime) {
		fields = append(fields, workflowexecution.FieldExecuteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearField(name string) error {
	switch name {
	case workflowexecution.FieldDescription:
		m.ClearDescription()
		return nil
	case workflowexecution.FieldLabels:
		m.ClearLabels()
		return nil
	case workflowexecution.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case workflowexecution.FieldStatus:
		m.ClearStatus()
		return nil
	case workflowexecution.FieldExecuteTime:
		m.ClearExecuteTime()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetField(name string) error {
	switch name {
	case workflowexecution.FieldName:
		m.ResetName()
		return nil
	case workflowexecution.FieldDescription:
		m.ResetDescription()
		return nil
	case workflowexecution.FieldLabels:
		m.ResetLabels()
		return nil
	case workflowexecution.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case workflowexecution.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workflowexecution.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workflowexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowexecution.FieldProjectID:
		m.ResetProjectID()
		return nil
	case workflowexecution.FieldVersion:
		m.ResetVersion()
		return nil
	case workflowexecution.FieldType:
		m.ResetType()
		return nil
	case workflowexecution.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflowexecution.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case workflowexecution.FieldExecuteTime:
		m.ResetExecuteTime()
		return nil
	case workflowexecution.FieldTimes:
		m.ResetTimes()
		return nil
	case workflowexecution.FieldDuration:
		m.ResetDuration()
		return nil
	case workflowexecution.FieldParallelism:
		m.ResetParallelism()
		return nil
	case workflowexecution.FieldTimeout:
		m.ResetTimeout()
		return nil
	case workflowexecution.FieldTrigger:
		m.ResetTrigger()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, workflowexecution.EdgeProject)
	}
	if m.stages != nil {
		edges = append(edges, workflowexecution.EdgeStages)
	}
	if m.workflow != nil {
		edges = append(edges, workflowexecution.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowexecution.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case workflowexecution.EdgeStages:
		ids := make([]ent.Value, 0, len(m.stages))
		for id := range m.stages {
			ids = append(ids, id)
		}
		return ids
	case workflowexecution.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstages != nil {
		edges = append(edges, workflowexecution.EdgeStages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowExecutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowexecution.EdgeStages:
		ids := make([]ent.Value, 0, len(m.removedstages))
		for id := range m.removedstages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, workflowexecution.EdgeProject)
	}
	if m.clearedstages {
		edges = append(edges, workflowexecution.EdgeStages)
	}
	if m.clearedworkflow {
		edges = append(edges, workflowexecution.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowexecution.EdgeProject:
		return m.clearedproject
	case workflowexecution.EdgeStages:
		return m.clearedstages
	case workflowexecution.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearEdge(name string) error {
	switch name {
	case workflowexecution.EdgeProject:
		m.ClearProject()
		return nil
	case workflowexecution.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetEdge(name string) error {
	switch name {
	case workflowexecution.EdgeProject:
		m.ResetProject()
		return nil
	case workflowexecution.EdgeStages:
		m.ResetStages()
		return nil
	case workflowexecution.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution edge %s", name)
}

// WorkflowStageMutation represents an operation that mutates the WorkflowStage nodes in the graph.
type WorkflowStageMutation struct {
	config
	op                 Op
	typ                string
	id                 *object.ID
	name               *string
	description        *string
	labels             *map[string]string
	annotations        *map[string]string
	create_time        *time.Time
	update_time        *time.Time
	dependencies       *[]object.ID
	appenddependencies []object.ID
	_order             *int
	add_order          *int
	clearedFields      map[string]struct{}
	project            *object.ID
	clearedproject     bool
	steps              map[object.ID]struct{}
	removedsteps       map[object.ID]struct{}
	clearedsteps       bool
	workflow           *object.ID
	clearedworkflow    bool
	done               bool
	oldValue           func(context.Context) (*WorkflowStage, error)
	predicates         []predicate.WorkflowStage
}

var _ ent.Mutation = (*WorkflowStageMutation)(nil)

// workflowStageOption allows management of the mutation configuration using functional options.
type workflowStageOption func(*WorkflowStageMutation)

// newWorkflowStageMutation creates new mutation for the WorkflowStage entity.
func newWorkflowStageMutation(c config, op Op, opts ...workflowStageOption) *WorkflowStageMutation {
	m := &WorkflowStageMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowStage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowStageID sets the ID field of the mutation.
func withWorkflowStageID(id object.ID) workflowStageOption {
	return func(m *WorkflowStageMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowStage
		)
		m.oldValue = func(ctx context.Context) (*WorkflowStage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowStage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowStage sets the old WorkflowStage of the mutation.
func withWorkflowStage(node *WorkflowStage) workflowStageOption {
	return func(m *WorkflowStageMutation) {
		m.oldValue = func(context.Context) (*WorkflowStage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowStageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowStageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowStage entities.
func (m *WorkflowStageMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowStageMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowStageMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowStage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowStageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowStageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowStageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowStageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowStageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowStageMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflowstage.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowStageMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflowstage.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowStageMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflowstage.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *WorkflowStageMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *WorkflowStageMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *WorkflowStageMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[workflowstage.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *WorkflowStageMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[workflowstage.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *WorkflowStageMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, workflowstage.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *WorkflowStageMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *WorkflowStageMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *WorkflowStageMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[workflowstage.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *WorkflowStageMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[workflowstage.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *WorkflowStageMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, workflowstage.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *WorkflowStageMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkflowStageMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkflowStageMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkflowStageMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkflowStageMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkflowStageMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetProjectID sets the "project_id" field.
func (m *WorkflowStageMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *WorkflowStageMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *WorkflowStageMutation) ResetProjectID() {
	m.project = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowStageMutation) SetWorkflowID(o object.ID) {
	m.workflow = &o
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowStageMutation) WorkflowID() (r object.ID, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldWorkflowID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowStageMutation) ResetWorkflowID() {
	m.workflow = nil
}

// SetDependencies sets the "dependencies" field.
func (m *WorkflowStageMutation) SetDependencies(o []object.ID) {
	m.dependencies = &o
	m.appenddependencies = nil
}

// Dependencies returns the value of the "dependencies" field in the mutation.
func (m *WorkflowStageMutation) Dependencies() (r []object.ID, exists bool) {
	v := m.dependencies
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencies returns the old "dependencies" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldDependencies(ctx context.Context) (v []object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencies: %w", err)
	}
	return oldValue.Dependencies, nil
}

// AppendDependencies adds o to the "dependencies" field.
func (m *WorkflowStageMutation) AppendDependencies(o []object.ID) {
	m.appenddependencies = append(m.appenddependencies, o...)
}

// AppendedDependencies returns the list of values that were appended to the "dependencies" field in this mutation.
func (m *WorkflowStageMutation) AppendedDependencies() ([]object.ID, bool) {
	if len(m.appenddependencies) == 0 {
		return nil, false
	}
	return m.appenddependencies, true
}

// ResetDependencies resets all changes to the "dependencies" field.
func (m *WorkflowStageMutation) ResetDependencies() {
	m.dependencies = nil
	m.appenddependencies = nil
}

// SetOrder sets the "order" field.
func (m *WorkflowStageMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *WorkflowStageMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the WorkflowStage entity.
// If the WorkflowStage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *WorkflowStageMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *WorkflowStageMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *WorkflowStageMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *WorkflowStageMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *WorkflowStageMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WorkflowStageMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *WorkflowStageMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddStepIDs adds the "steps" edge to the WorkflowStep entity by ids.
func (m *WorkflowStageMutation) AddStepIDs(ids ...object.ID) {
	if m.steps == nil {
		m.steps = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the "steps" edge to the WorkflowStep entity.
func (m *WorkflowStageMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared reports if the "steps" edge to the WorkflowStep entity was cleared.
func (m *WorkflowStageMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the "steps" edge to the WorkflowStep entity by IDs.
func (m *WorkflowStageMutation) RemoveStepIDs(ids ...object.ID) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.steps, ids[i])
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed IDs of the "steps" edge to the WorkflowStep entity.
func (m *WorkflowStageMutation) RemovedStepsIDs() (ids []object.ID) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the "steps" edge IDs in the mutation.
func (m *WorkflowStageMutation) StepsIDs() (ids []object.ID) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps resets all changes to the "steps" edge.
func (m *WorkflowStageMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowStageMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowStageMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowStageMutation) WorkflowIDs() (ids []object.ID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowStageMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the WorkflowStageMutation builder.
func (m *WorkflowStageMutation) Where(ps ...predicate.WorkflowStage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowStageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowStageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowStage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowStageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowStageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowStage).
func (m *WorkflowStageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowStageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, workflowstage.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflowstage.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, workflowstage.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, workflowstage.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, workflowstage.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workflowstage.FieldUpdateTime)
	}
	if m.project != nil {
		fields = append(fields, workflowstage.FieldProjectID)
	}
	if m.workflow != nil {
		fields = append(fields, workflowstage.FieldWorkflowID)
	}
	if m.dependencies != nil {
		fields = append(fields, workflowstage.FieldDependencies)
	}
	if m._order != nil {
		fields = append(fields, workflowstage.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowStageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowstage.FieldName:
		return m.Name()
	case workflowstage.FieldDescription:
		return m.Description()
	case workflowstage.FieldLabels:
		return m.Labels()
	case workflowstage.FieldAnnotations:
		return m.Annotations()
	case workflowstage.FieldCreateTime:
		return m.CreateTime()
	case workflowstage.FieldUpdateTime:
		return m.UpdateTime()
	case workflowstage.FieldProjectID:
		return m.ProjectID()
	case workflowstage.FieldWorkflowID:
		return m.WorkflowID()
	case workflowstage.FieldDependencies:
		return m.Dependencies()
	case workflowstage.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowStageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowstage.FieldName:
		return m.OldName(ctx)
	case workflowstage.FieldDescription:
		return m.OldDescription(ctx)
	case workflowstage.FieldLabels:
		return m.OldLabels(ctx)
	case workflowstage.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case workflowstage.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workflowstage.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workflowstage.FieldProjectID:
		return m.OldProjectID(ctx)
	case workflowstage.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflowstage.FieldDependencies:
		return m.OldDependencies(ctx)
	case workflowstage.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowStage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowStageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowstage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflowstage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflowstage.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case workflowstage.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case workflowstage.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workflowstage.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workflowstage.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case workflowstage.FieldWorkflowID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflowstage.FieldDependencies:
		v, ok := value.([]object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencies(v)
		return nil
	case workflowstage.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowStage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowStageMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, workflowstage.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowStageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowstage.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowStageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowstage.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowStage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowStageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowstage.FieldDescription) {
		fields = append(fields, workflowstage.FieldDescription)
	}
	if m.FieldCleared(workflowstage.FieldLabels) {
		fields = append(fields, workflowstage.FieldLabels)
	}
	if m.FieldCleared(workflowstage.FieldAnnotations) {
		fields = append(fields, workflowstage.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowStageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowStageMutation) ClearField(name string) error {
	switch name {
	case workflowstage.FieldDescription:
		m.ClearDescription()
		return nil
	case workflowstage.FieldLabels:
		m.ClearLabels()
		return nil
	case workflowstage.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowStageMutation) ResetField(name string) error {
	switch name {
	case workflowstage.FieldName:
		m.ResetName()
		return nil
	case workflowstage.FieldDescription:
		m.ResetDescription()
		return nil
	case workflowstage.FieldLabels:
		m.ResetLabels()
		return nil
	case workflowstage.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case workflowstage.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workflowstage.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workflowstage.FieldProjectID:
		m.ResetProjectID()
		return nil
	case workflowstage.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflowstage.FieldDependencies:
		m.ResetDependencies()
		return nil
	case workflowstage.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowStageMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, workflowstage.EdgeProject)
	}
	if m.steps != nil {
		edges = append(edges, workflowstage.EdgeSteps)
	}
	if m.workflow != nil {
		edges = append(edges, workflowstage.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowStageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowstage.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case workflowstage.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	case workflowstage.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowStageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsteps != nil {
		edges = append(edges, workflowstage.EdgeSteps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowStageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowstage.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowStageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, workflowstage.EdgeProject)
	}
	if m.clearedsteps {
		edges = append(edges, workflowstage.EdgeSteps)
	}
	if m.clearedworkflow {
		edges = append(edges, workflowstage.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowStageMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowstage.EdgeProject:
		return m.clearedproject
	case workflowstage.EdgeSteps:
		return m.clearedsteps
	case workflowstage.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowStageMutation) ClearEdge(name string) error {
	switch name {
	case workflowstage.EdgeProject:
		m.ClearProject()
		return nil
	case workflowstage.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowStageMutation) ResetEdge(name string) error {
	switch name {
	case workflowstage.EdgeProject:
		m.ResetProject()
		return nil
	case workflowstage.EdgeSteps:
		m.ResetSteps()
		return nil
	case workflowstage.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStage edge %s", name)
}

// WorkflowStageExecutionMutation represents an operation that mutates the WorkflowStageExecution nodes in the graph.
type WorkflowStageExecutionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *object.ID
	name                      *string
	description               *string
	labels                    *map[string]string
	annotations               *map[string]string
	create_time               *time.Time
	update_time               *time.Time
	status                    *status.Status
	workflow_id               *object.ID
	workflow_stage_id         *object.ID
	execute_time              *time.Time
	duration                  *int
	addduration               *int
	_order                    *int
	add_order                 *int
	clearedFields             map[string]struct{}
	project                   *object.ID
	clearedproject            bool
	steps                     map[object.ID]struct{}
	removedsteps              map[object.ID]struct{}
	clearedsteps              bool
	workflow_execution        *object.ID
	clearedworkflow_execution bool
	done                      bool
	oldValue                  func(context.Context) (*WorkflowStageExecution, error)
	predicates                []predicate.WorkflowStageExecution
}

var _ ent.Mutation = (*WorkflowStageExecutionMutation)(nil)

// workflowStageExecutionOption allows management of the mutation configuration using functional options.
type workflowStageExecutionOption func(*WorkflowStageExecutionMutation)

// newWorkflowStageExecutionMutation creates new mutation for the WorkflowStageExecution entity.
func newWorkflowStageExecutionMutation(c config, op Op, opts ...workflowStageExecutionOption) *WorkflowStageExecutionMutation {
	m := &WorkflowStageExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowStageExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowStageExecutionID sets the ID field of the mutation.
func withWorkflowStageExecutionID(id object.ID) workflowStageExecutionOption {
	return func(m *WorkflowStageExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowStageExecution
		)
		m.oldValue = func(ctx context.Context) (*WorkflowStageExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowStageExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowStageExecution sets the old WorkflowStageExecution of the mutation.
func withWorkflowStageExecution(node *WorkflowStageExecution) workflowStageExecutionOption {
	return func(m *WorkflowStageExecutionMutation) {
		m.oldValue = func(context.Context) (*WorkflowStageExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowStageExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowStageExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowStageExecution entities.
func (m *WorkflowStageExecutionMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowStageExecutionMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowStageExecutionMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowStageExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowStageExecutionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowStageExecutionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowStageExecutionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowStageExecutionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowStageExecutionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowStageExecutionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflowstageexecution.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowStageExecutionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflowstageexecution.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowStageExecutionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflowstageexecution.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *WorkflowStageExecutionMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *WorkflowStageExecutionMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *WorkflowStageExecutionMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[workflowstageexecution.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *WorkflowStageExecutionMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[workflowstageexecution.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *WorkflowStageExecutionMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, workflowstageexecution.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *WorkflowStageExecutionMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *WorkflowStageExecutionMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *WorkflowStageExecutionMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[workflowstageexecution.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *WorkflowStageExecutionMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[workflowstageexecution.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *WorkflowStageExecutionMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, workflowstageexecution.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *WorkflowStageExecutionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkflowStageExecutionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkflowStageExecutionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkflowStageExecutionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkflowStageExecutionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkflowStageExecutionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowStageExecutionMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowStageExecutionMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *WorkflowStageExecutionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[workflowstageexecution.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *WorkflowStageExecutionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[workflowstageexecution.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowStageExecutionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, workflowstageexecution.FieldStatus)
}

// SetProjectID sets the "project_id" field.
func (m *WorkflowStageExecutionMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *WorkflowStageExecutionMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *WorkflowStageExecutionMutation) ResetProjectID() {
	m.project = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowStageExecutionMutation) SetWorkflowID(o object.ID) {
	m.workflow_id = &o
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowStageExecutionMutation) WorkflowID() (r object.ID, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldWorkflowID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowStageExecutionMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetWorkflowStageID sets the "workflow_stage_id" field.
func (m *WorkflowStageExecutionMutation) SetWorkflowStageID(o object.ID) {
	m.workflow_stage_id = &o
}

// WorkflowStageID returns the value of the "workflow_stage_id" field in the mutation.
func (m *WorkflowStageExecutionMutation) WorkflowStageID() (r object.ID, exists bool) {
	v := m.workflow_stage_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowStageID returns the old "workflow_stage_id" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldWorkflowStageID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowStageID: %w", err)
	}
	return oldValue.WorkflowStageID, nil
}

// ResetWorkflowStageID resets all changes to the "workflow_stage_id" field.
func (m *WorkflowStageExecutionMutation) ResetWorkflowStageID() {
	m.workflow_stage_id = nil
}

// SetWorkflowExecutionID sets the "workflow_execution_id" field.
func (m *WorkflowStageExecutionMutation) SetWorkflowExecutionID(o object.ID) {
	m.workflow_execution = &o
}

// WorkflowExecutionID returns the value of the "workflow_execution_id" field in the mutation.
func (m *WorkflowStageExecutionMutation) WorkflowExecutionID() (r object.ID, exists bool) {
	v := m.workflow_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowExecutionID returns the old "workflow_execution_id" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldWorkflowExecutionID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowExecutionID: %w", err)
	}
	return oldValue.WorkflowExecutionID, nil
}

// ResetWorkflowExecutionID resets all changes to the "workflow_execution_id" field.
func (m *WorkflowStageExecutionMutation) ResetWorkflowExecutionID() {
	m.workflow_execution = nil
}

// SetExecuteTime sets the "execute_time" field.
func (m *WorkflowStageExecutionMutation) SetExecuteTime(t time.Time) {
	m.execute_time = &t
}

// ExecuteTime returns the value of the "execute_time" field in the mutation.
func (m *WorkflowStageExecutionMutation) ExecuteTime() (r time.Time, exists bool) {
	v := m.execute_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExecuteTime returns the old "execute_time" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldExecuteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecuteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecuteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecuteTime: %w", err)
	}
	return oldValue.ExecuteTime, nil
}

// ClearExecuteTime clears the value of the "execute_time" field.
func (m *WorkflowStageExecutionMutation) ClearExecuteTime() {
	m.execute_time = nil
	m.clearedFields[workflowstageexecution.FieldExecuteTime] = struct{}{}
}

// ExecuteTimeCleared returns if the "execute_time" field was cleared in this mutation.
func (m *WorkflowStageExecutionMutation) ExecuteTimeCleared() bool {
	_, ok := m.clearedFields[workflowstageexecution.FieldExecuteTime]
	return ok
}

// ResetExecuteTime resets all changes to the "execute_time" field.
func (m *WorkflowStageExecutionMutation) ResetExecuteTime() {
	m.execute_time = nil
	delete(m.clearedFields, workflowstageexecution.FieldExecuteTime)
}

// SetDuration sets the "duration" field.
func (m *WorkflowStageExecutionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *WorkflowStageExecutionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *WorkflowStageExecutionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *WorkflowStageExecutionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *WorkflowStageExecutionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetOrder sets the "order" field.
func (m *WorkflowStageExecutionMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *WorkflowStageExecutionMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the WorkflowStageExecution entity.
// If the WorkflowStageExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStageExecutionMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *WorkflowStageExecutionMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *WorkflowStageExecutionMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *WorkflowStageExecutionMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *WorkflowStageExecutionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *WorkflowStageExecutionMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WorkflowStageExecutionMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *WorkflowStageExecutionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddStepIDs adds the "steps" edge to the WorkflowStepExecution entity by ids.
func (m *WorkflowStageExecutionMutation) AddStepIDs(ids ...object.ID) {
	if m.steps == nil {
		m.steps = make(map[object.ID]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the "steps" edge to the WorkflowStepExecution entity.
func (m *WorkflowStageExecutionMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared reports if the "steps" edge to the WorkflowStepExecution entity was cleared.
func (m *WorkflowStageExecutionMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the "steps" edge to the WorkflowStepExecution entity by IDs.
func (m *WorkflowStageExecutionMutation) RemoveStepIDs(ids ...object.ID) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[object.ID]struct{})
	}
	for i := range ids {
		delete(m.steps, ids[i])
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed IDs of the "steps" edge to the WorkflowStepExecution entity.
func (m *WorkflowStageExecutionMutation) RemovedStepsIDs() (ids []object.ID) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the "steps" edge IDs in the mutation.
func (m *WorkflowStageExecutionMutation) StepsIDs() (ids []object.ID) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps resets all changes to the "steps" edge.
func (m *WorkflowStageExecutionMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// ClearWorkflowExecution clears the "workflow_execution" edge to the WorkflowExecution entity.
func (m *WorkflowStageExecutionMutation) ClearWorkflowExecution() {
	m.clearedworkflow_execution = true
}

// WorkflowExecutionCleared reports if the "workflow_execution" edge to the WorkflowExecution entity was cleared.
func (m *WorkflowStageExecutionMutation) WorkflowExecutionCleared() bool {
	return m.clearedworkflow_execution
}

// WorkflowExecutionIDs returns the "workflow_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowExecutionID instead. It exists only for internal usage by the builders.
func (m *WorkflowStageExecutionMutation) WorkflowExecutionIDs() (ids []object.ID) {
	if id := m.workflow_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowExecution resets all changes to the "workflow_execution" edge.
func (m *WorkflowStageExecutionMutation) ResetWorkflowExecution() {
	m.workflow_execution = nil
	m.clearedworkflow_execution = false
}

// Where appends a list predicates to the WorkflowStageExecutionMutation builder.
func (m *WorkflowStageExecutionMutation) Where(ps ...predicate.WorkflowStageExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowStageExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowStageExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowStageExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowStageExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowStageExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowStageExecution).
func (m *WorkflowStageExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowStageExecutionMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, workflowstageexecution.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflowstageexecution.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, workflowstageexecution.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, workflowstageexecution.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, workflowstageexecution.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workflowstageexecution.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, workflowstageexecution.FieldStatus)
	}
	if m.project != nil {
		fields = append(fields, workflowstageexecution.FieldProjectID)
	}
	if m.workflow_id != nil {
		fields = append(fields, workflowstageexecution.FieldWorkflowID)
	}
	if m.workflow_stage_id != nil {
		fields = append(fields, workflowstageexecution.FieldWorkflowStageID)
	}
	if m.workflow_execution != nil {
		fields = append(fields, workflowstageexecution.FieldWorkflowExecutionID)
	}
	if m.execute_time != nil {
		fields = append(fields, workflowstageexecution.FieldExecuteTime)
	}
	if m.duration != nil {
		fields = append(fields, workflowstageexecution.FieldDuration)
	}
	if m._order != nil {
		fields = append(fields, workflowstageexecution.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowStageExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowstageexecution.FieldName:
		return m.Name()
	case workflowstageexecution.FieldDescription:
		return m.Description()
	case workflowstageexecution.FieldLabels:
		return m.Labels()
	case workflowstageexecution.FieldAnnotations:
		return m.Annotations()
	case workflowstageexecution.FieldCreateTime:
		return m.CreateTime()
	case workflowstageexecution.FieldUpdateTime:
		return m.UpdateTime()
	case workflowstageexecution.FieldStatus:
		return m.Status()
	case workflowstageexecution.FieldProjectID:
		return m.ProjectID()
	case workflowstageexecution.FieldWorkflowID:
		return m.WorkflowID()
	case workflowstageexecution.FieldWorkflowStageID:
		return m.WorkflowStageID()
	case workflowstageexecution.FieldWorkflowExecutionID:
		return m.WorkflowExecutionID()
	case workflowstageexecution.FieldExecuteTime:
		return m.ExecuteTime()
	case workflowstageexecution.FieldDuration:
		return m.Duration()
	case workflowstageexecution.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowStageExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowstageexecution.FieldName:
		return m.OldName(ctx)
	case workflowstageexecution.FieldDescription:
		return m.OldDescription(ctx)
	case workflowstageexecution.FieldLabels:
		return m.OldLabels(ctx)
	case workflowstageexecution.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case workflowstageexecution.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workflowstageexecution.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workflowstageexecution.FieldStatus:
		return m.OldStatus(ctx)
	case workflowstageexecution.FieldProjectID:
		return m.OldProjectID(ctx)
	case workflowstageexecution.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflowstageexecution.FieldWorkflowStageID:
		return m.OldWorkflowStageID(ctx)
	case workflowstageexecution.FieldWorkflowExecutionID:
		return m.OldWorkflowExecutionID(ctx)
	case workflowstageexecution.FieldExecuteTime:
		return m.OldExecuteTime(ctx)
	case workflowstageexecution.FieldDuration:
		return m.OldDuration(ctx)
	case workflowstageexecution.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowStageExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowStageExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowstageexecution.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflowstageexecution.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflowstageexecution.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case workflowstageexecution.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case workflowstageexecution.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workflowstageexecution.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workflowstageexecution.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowstageexecution.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case workflowstageexecution.FieldWorkflowID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflowstageexecution.FieldWorkflowStageID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowStageID(v)
		return nil
	case workflowstageexecution.FieldWorkflowExecutionID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowExecutionID(v)
		return nil
	case workflowstageexecution.FieldExecuteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecuteTime(v)
		return nil
	case workflowstageexecution.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case workflowstageexecution.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowStageExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowStageExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, workflowstageexecution.FieldDuration)
	}
	if m.add_order != nil {
		fields = append(fields, workflowstageexecution.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowStageExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowstageexecution.FieldDuration:
		return m.AddedDuration()
	case workflowstageexecution.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowStageExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowstageexecution.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case workflowstageexecution.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowStageExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowStageExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowstageexecution.FieldDescription) {
		fields = append(fields, workflowstageexecution.FieldDescription)
	}
	if m.FieldCleared(workflowstageexecution.FieldLabels) {
		fields = append(fields, workflowstageexecution.FieldLabels)
	}
	if m.FieldCleared(workflowstageexecution.FieldAnnotations) {
		fields = append(fields, workflowstageexecution.FieldAnnotations)
	}
	if m.FieldCleared(workflowstageexecution.FieldStatus) {
		fields = append(fields, workflowstageexecution.FieldStatus)
	}
	if m.FieldCleared(workflowstageexecution.FieldExecuteTime) {
		fields = append(fields, workflowstageexecution.FieldExecuteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowStageExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowStageExecutionMutation) ClearField(name string) error {
	switch name {
	case workflowstageexecution.FieldDescription:
		m.ClearDescription()
		return nil
	case workflowstageexecution.FieldLabels:
		m.ClearLabels()
		return nil
	case workflowstageexecution.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case workflowstageexecution.FieldStatus:
		m.ClearStatus()
		return nil
	case workflowstageexecution.FieldExecuteTime:
		m.ClearExecuteTime()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStageExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowStageExecutionMutation) ResetField(name string) error {
	switch name {
	case workflowstageexecution.FieldName:
		m.ResetName()
		return nil
	case workflowstageexecution.FieldDescription:
		m.ResetDescription()
		return nil
	case workflowstageexecution.FieldLabels:
		m.ResetLabels()
		return nil
	case workflowstageexecution.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case workflowstageexecution.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workflowstageexecution.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workflowstageexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowstageexecution.FieldProjectID:
		m.ResetProjectID()
		return nil
	case workflowstageexecution.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflowstageexecution.FieldWorkflowStageID:
		m.ResetWorkflowStageID()
		return nil
	case workflowstageexecution.FieldWorkflowExecutionID:
		m.ResetWorkflowExecutionID()
		return nil
	case workflowstageexecution.FieldExecuteTime:
		m.ResetExecuteTime()
		return nil
	case workflowstageexecution.FieldDuration:
		m.ResetDuration()
		return nil
	case workflowstageexecution.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStageExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowStageExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, workflowstageexecution.EdgeProject)
	}
	if m.steps != nil {
		edges = append(edges, workflowstageexecution.EdgeSteps)
	}
	if m.workflow_execution != nil {
		edges = append(edges, workflowstageexecution.EdgeWorkflowExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowStageExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowstageexecution.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case workflowstageexecution.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	case workflowstageexecution.EdgeWorkflowExecution:
		if id := m.workflow_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowStageExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsteps != nil {
		edges = append(edges, workflowstageexecution.EdgeSteps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowStageExecutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowstageexecution.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowStageExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, workflowstageexecution.EdgeProject)
	}
	if m.clearedsteps {
		edges = append(edges, workflowstageexecution.EdgeSteps)
	}
	if m.clearedworkflow_execution {
		edges = append(edges, workflowstageexecution.EdgeWorkflowExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowStageExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowstageexecution.EdgeProject:
		return m.clearedproject
	case workflowstageexecution.EdgeSteps:
		return m.clearedsteps
	case workflowstageexecution.EdgeWorkflowExecution:
		return m.clearedworkflow_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowStageExecutionMutation) ClearEdge(name string) error {
	switch name {
	case workflowstageexecution.EdgeProject:
		m.ClearProject()
		return nil
	case workflowstageexecution.EdgeWorkflowExecution:
		m.ClearWorkflowExecution()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStageExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowStageExecutionMutation) ResetEdge(name string) error {
	switch name {
	case workflowstageexecution.EdgeProject:
		m.ResetProject()
		return nil
	case workflowstageexecution.EdgeSteps:
		m.ResetSteps()
		return nil
	case workflowstageexecution.EdgeWorkflowExecution:
		m.ResetWorkflowExecution()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStageExecution edge %s", name)
}

// WorkflowStepMutation represents an operation that mutates the WorkflowStep nodes in the graph.
type WorkflowStepMutation struct {
	config
	op                 Op
	typ                string
	id                 *object.ID
	name               *string
	description        *string
	labels             *map[string]string
	annotations        *map[string]string
	create_time        *time.Time
	update_time        *time.Time
	_type              *string
	workflow_id        *object.ID
	attributes         *map[string]any
	inputs             *map[string]any
	outputs            *map[string]any
	_order             *int
	add_order          *int
	dependencies       *[]object.ID
	appenddependencies []object.ID
	retryStrategy      **types.RetryStrategy
	timeout            *int
	addtimeout         *int
	clearedFields      map[string]struct{}
	project            *object.ID
	clearedproject     bool
	stage              *object.ID
	clearedstage       bool
	done               bool
	oldValue           func(context.Context) (*WorkflowStep, error)
	predicates         []predicate.WorkflowStep
}

var _ ent.Mutation = (*WorkflowStepMutation)(nil)

// workflowStepOption allows management of the mutation configuration using functional options.
type workflowStepOption func(*WorkflowStepMutation)

// newWorkflowStepMutation creates new mutation for the WorkflowStep entity.
func newWorkflowStepMutation(c config, op Op, opts ...workflowStepOption) *WorkflowStepMutation {
	m := &WorkflowStepMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowStepID sets the ID field of the mutation.
func withWorkflowStepID(id object.ID) workflowStepOption {
	return func(m *WorkflowStepMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowStep
		)
		m.oldValue = func(ctx context.Context) (*WorkflowStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowStep sets the old WorkflowStep of the mutation.
func withWorkflowStep(node *WorkflowStep) workflowStepOption {
	return func(m *WorkflowStepMutation) {
		m.oldValue = func(context.Context) (*WorkflowStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowStep entities.
func (m *WorkflowStepMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowStepMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowStepMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowStepMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowStepMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowStepMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowStepMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowStepMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowStepMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflowstep.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowStepMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflowstep.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowStepMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflowstep.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *WorkflowStepMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *WorkflowStepMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *WorkflowStepMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[workflowstep.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *WorkflowStepMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[workflowstep.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *WorkflowStepMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, workflowstep.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *WorkflowStepMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *WorkflowStepMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *WorkflowStepMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[workflowstep.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *WorkflowStepMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[workflowstep.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *WorkflowStepMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, workflowstep.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *WorkflowStepMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkflowStepMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkflowStepMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkflowStepMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkflowStepMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkflowStepMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *WorkflowStepMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkflowStepMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WorkflowStepMutation) ResetType() {
	m._type = nil
}

// SetProjectID sets the "project_id" field.
func (m *WorkflowStepMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *WorkflowStepMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *WorkflowStepMutation) ResetProjectID() {
	m.project = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowStepMutation) SetWorkflowID(o object.ID) {
	m.workflow_id = &o
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowStepMutation) WorkflowID() (r object.ID, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldWorkflowID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowStepMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetWorkflowStageID sets the "workflow_stage_id" field.
func (m *WorkflowStepMutation) SetWorkflowStageID(o object.ID) {
	m.stage = &o
}

// WorkflowStageID returns the value of the "workflow_stage_id" field in the mutation.
func (m *WorkflowStepMutation) WorkflowStageID() (r object.ID, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowStageID returns the old "workflow_stage_id" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldWorkflowStageID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowStageID: %w", err)
	}
	return oldValue.WorkflowStageID, nil
}

// ResetWorkflowStageID resets all changes to the "workflow_stage_id" field.
func (m *WorkflowStepMutation) ResetWorkflowStageID() {
	m.stage = nil
}

// SetAttributes sets the "attributes" field.
func (m *WorkflowStepMutation) SetAttributes(value map[string]any) {
	m.attributes = &value
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *WorkflowStepMutation) Attributes() (r map[string]any, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldAttributes(ctx context.Context) (v map[string]any, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *WorkflowStepMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[workflowstep.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *WorkflowStepMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[workflowstep.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *WorkflowStepMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, workflowstep.FieldAttributes)
}

// SetInputs sets the "inputs" field.
func (m *WorkflowStepMutation) SetInputs(value map[string]any) {
	m.inputs = &value
}

// Inputs returns the value of the "inputs" field in the mutation.
func (m *WorkflowStepMutation) Inputs() (r map[string]any, exists bool) {
	v := m.inputs
	if v == nil {
		return
	}
	return *v, true
}

// OldInputs returns the old "inputs" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldInputs(ctx context.Context) (v map[string]any, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputs: %w", err)
	}
	return oldValue.Inputs, nil
}

// ClearInputs clears the value of the "inputs" field.
func (m *WorkflowStepMutation) ClearInputs() {
	m.inputs = nil
	m.clearedFields[workflowstep.FieldInputs] = struct{}{}
}

// InputsCleared returns if the "inputs" field was cleared in this mutation.
func (m *WorkflowStepMutation) InputsCleared() bool {
	_, ok := m.clearedFields[workflowstep.FieldInputs]
	return ok
}

// ResetInputs resets all changes to the "inputs" field.
func (m *WorkflowStepMutation) ResetInputs() {
	m.inputs = nil
	delete(m.clearedFields, workflowstep.FieldInputs)
}

// SetOutputs sets the "outputs" field.
func (m *WorkflowStepMutation) SetOutputs(value map[string]any) {
	m.outputs = &value
}

// Outputs returns the value of the "outputs" field in the mutation.
func (m *WorkflowStepMutation) Outputs() (r map[string]any, exists bool) {
	v := m.outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputs returns the old "outputs" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldOutputs(ctx context.Context) (v map[string]any, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputs: %w", err)
	}
	return oldValue.Outputs, nil
}

// ClearOutputs clears the value of the "outputs" field.
func (m *WorkflowStepMutation) ClearOutputs() {
	m.outputs = nil
	m.clearedFields[workflowstep.FieldOutputs] = struct{}{}
}

// OutputsCleared returns if the "outputs" field was cleared in this mutation.
func (m *WorkflowStepMutation) OutputsCleared() bool {
	_, ok := m.clearedFields[workflowstep.FieldOutputs]
	return ok
}

// ResetOutputs resets all changes to the "outputs" field.
func (m *WorkflowStepMutation) ResetOutputs() {
	m.outputs = nil
	delete(m.clearedFields, workflowstep.FieldOutputs)
}

// SetOrder sets the "order" field.
func (m *WorkflowStepMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *WorkflowStepMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *WorkflowStepMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *WorkflowStepMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *WorkflowStepMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetDependencies sets the "dependencies" field.
func (m *WorkflowStepMutation) SetDependencies(o []object.ID) {
	m.dependencies = &o
	m.appenddependencies = nil
}

// Dependencies returns the value of the "dependencies" field in the mutation.
func (m *WorkflowStepMutation) Dependencies() (r []object.ID, exists bool) {
	v := m.dependencies
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencies returns the old "dependencies" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldDependencies(ctx context.Context) (v []object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencies: %w", err)
	}
	return oldValue.Dependencies, nil
}

// AppendDependencies adds o to the "dependencies" field.
func (m *WorkflowStepMutation) AppendDependencies(o []object.ID) {
	m.appenddependencies = append(m.appenddependencies, o...)
}

// AppendedDependencies returns the list of values that were appended to the "dependencies" field in this mutation.
func (m *WorkflowStepMutation) AppendedDependencies() ([]object.ID, bool) {
	if len(m.appenddependencies) == 0 {
		return nil, false
	}
	return m.appenddependencies, true
}

// ResetDependencies resets all changes to the "dependencies" field.
func (m *WorkflowStepMutation) ResetDependencies() {
	m.dependencies = nil
	m.appenddependencies = nil
}

// SetRetryStrategy sets the "retryStrategy" field.
func (m *WorkflowStepMutation) SetRetryStrategy(ts *types.RetryStrategy) {
	m.retryStrategy = &ts
}

// RetryStrategy returns the value of the "retryStrategy" field in the mutation.
func (m *WorkflowStepMutation) RetryStrategy() (r *types.RetryStrategy, exists bool) {
	v := m.retryStrategy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryStrategy returns the old "retryStrategy" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldRetryStrategy(ctx context.Context) (v *types.RetryStrategy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryStrategy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryStrategy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryStrategy: %w", err)
	}
	return oldValue.RetryStrategy, nil
}

// ClearRetryStrategy clears the value of the "retryStrategy" field.
func (m *WorkflowStepMutation) ClearRetryStrategy() {
	m.retryStrategy = nil
	m.clearedFields[workflowstep.FieldRetryStrategy] = struct{}{}
}

// RetryStrategyCleared returns if the "retryStrategy" field was cleared in this mutation.
func (m *WorkflowStepMutation) RetryStrategyCleared() bool {
	_, ok := m.clearedFields[workflowstep.FieldRetryStrategy]
	return ok
}

// ResetRetryStrategy resets all changes to the "retryStrategy" field.
func (m *WorkflowStepMutation) ResetRetryStrategy() {
	m.retryStrategy = nil
	delete(m.clearedFields, workflowstep.FieldRetryStrategy)
}

// SetTimeout sets the "timeout" field.
func (m *WorkflowStepMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *WorkflowStepMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the WorkflowStep entity.
// If the WorkflowStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *WorkflowStepMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *WorkflowStepMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *WorkflowStepMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *WorkflowStepMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *WorkflowStepMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WorkflowStepMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *WorkflowStepMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetStageID sets the "stage" edge to the WorkflowStage entity by id.
func (m *WorkflowStepMutation) SetStageID(id object.ID) {
	m.stage = &id
}

// ClearStage clears the "stage" edge to the WorkflowStage entity.
func (m *WorkflowStepMutation) ClearStage() {
	m.clearedstage = true
}

// StageCleared reports if the "stage" edge to the WorkflowStage entity was cleared.
func (m *WorkflowStepMutation) StageCleared() bool {
	return m.clearedstage
}

// StageID returns the "stage" edge ID in the mutation.
func (m *WorkflowStepMutation) StageID() (id object.ID, exists bool) {
	if m.stage != nil {
		return *m.stage, true
	}
	return
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *WorkflowStepMutation) StageIDs() (ids []object.ID) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *WorkflowStepMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// Where appends a list predicates to the WorkflowStepMutation builder.
func (m *WorkflowStepMutation) Where(ps ...predicate.WorkflowStep) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowStepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowStepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowStep, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowStepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowStepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowStep).
func (m *WorkflowStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowStepMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, workflowstep.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflowstep.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, workflowstep.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, workflowstep.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, workflowstep.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workflowstep.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, workflowstep.FieldType)
	}
	if m.project != nil {
		fields = append(fields, workflowstep.FieldProjectID)
	}
	if m.workflow_id != nil {
		fields = append(fields, workflowstep.FieldWorkflowID)
	}
	if m.stage != nil {
		fields = append(fields, workflowstep.FieldWorkflowStageID)
	}
	if m.attributes != nil {
		fields = append(fields, workflowstep.FieldAttributes)
	}
	if m.inputs != nil {
		fields = append(fields, workflowstep.FieldInputs)
	}
	if m.outputs != nil {
		fields = append(fields, workflowstep.FieldOutputs)
	}
	if m._order != nil {
		fields = append(fields, workflowstep.FieldOrder)
	}
	if m.dependencies != nil {
		fields = append(fields, workflowstep.FieldDependencies)
	}
	if m.retryStrategy != nil {
		fields = append(fields, workflowstep.FieldRetryStrategy)
	}
	if m.timeout != nil {
		fields = append(fields, workflowstep.FieldTimeout)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowstep.FieldName:
		return m.Name()
	case workflowstep.FieldDescription:
		return m.Description()
	case workflowstep.FieldLabels:
		return m.Labels()
	case workflowstep.FieldAnnotations:
		return m.Annotations()
	case workflowstep.FieldCreateTime:
		return m.CreateTime()
	case workflowstep.FieldUpdateTime:
		return m.UpdateTime()
	case workflowstep.FieldType:
		return m.GetType()
	case workflowstep.FieldProjectID:
		return m.ProjectID()
	case workflowstep.FieldWorkflowID:
		return m.WorkflowID()
	case workflowstep.FieldWorkflowStageID:
		return m.WorkflowStageID()
	case workflowstep.FieldAttributes:
		return m.Attributes()
	case workflowstep.FieldInputs:
		return m.Inputs()
	case workflowstep.FieldOutputs:
		return m.Outputs()
	case workflowstep.FieldOrder:
		return m.Order()
	case workflowstep.FieldDependencies:
		return m.Dependencies()
	case workflowstep.FieldRetryStrategy:
		return m.RetryStrategy()
	case workflowstep.FieldTimeout:
		return m.Timeout()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowstep.FieldName:
		return m.OldName(ctx)
	case workflowstep.FieldDescription:
		return m.OldDescription(ctx)
	case workflowstep.FieldLabels:
		return m.OldLabels(ctx)
	case workflowstep.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case workflowstep.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workflowstep.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workflowstep.FieldType:
		return m.OldType(ctx)
	case workflowstep.FieldProjectID:
		return m.OldProjectID(ctx)
	case workflowstep.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflowstep.FieldWorkflowStageID:
		return m.OldWorkflowStageID(ctx)
	case workflowstep.FieldAttributes:
		return m.OldAttributes(ctx)
	case workflowstep.FieldInputs:
		return m.OldInputs(ctx)
	case workflowstep.FieldOutputs:
		return m.OldOutputs(ctx)
	case workflowstep.FieldOrder:
		return m.OldOrder(ctx)
	case workflowstep.FieldDependencies:
		return m.OldDependencies(ctx)
	case workflowstep.FieldRetryStrategy:
		return m.OldRetryStrategy(ctx)
	case workflowstep.FieldTimeout:
		return m.OldTimeout(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowstep.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflowstep.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflowstep.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case workflowstep.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case workflowstep.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workflowstep.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workflowstep.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case workflowstep.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case workflowstep.FieldWorkflowID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflowstep.FieldWorkflowStageID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowStageID(v)
		return nil
	case workflowstep.FieldAttributes:
		v, ok := value.(map[string]any)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case workflowstep.FieldInputs:
		v, ok := value.(map[string]any)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputs(v)
		return nil
	case workflowstep.FieldOutputs:
		v, ok := value.(map[string]any)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputs(v)
		return nil
	case workflowstep.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case workflowstep.FieldDependencies:
		v, ok := value.([]object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencies(v)
		return nil
	case workflowstep.FieldRetryStrategy:
		v, ok := value.(*types.RetryStrategy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryStrategy(v)
		return nil
	case workflowstep.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowStepMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, workflowstep.FieldOrder)
	}
	if m.addtimeout != nil {
		fields = append(fields, workflowstep.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowstep.FieldOrder:
		return m.AddedOrder()
	case workflowstep.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowstep.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case workflowstep.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowStepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowstep.FieldDescription) {
		fields = append(fields, workflowstep.FieldDescription)
	}
	if m.FieldCleared(workflowstep.FieldLabels) {
		fields = append(fields, workflowstep.FieldLabels)
	}
	if m.FieldCleared(workflowstep.FieldAnnotations) {
		fields = append(fields, workflowstep.FieldAnnotations)
	}
	if m.FieldCleared(workflowstep.FieldAttributes) {
		fields = append(fields, workflowstep.FieldAttributes)
	}
	if m.FieldCleared(workflowstep.FieldInputs) {
		fields = append(fields, workflowstep.FieldInputs)
	}
	if m.FieldCleared(workflowstep.FieldOutputs) {
		fields = append(fields, workflowstep.FieldOutputs)
	}
	if m.FieldCleared(workflowstep.FieldRetryStrategy) {
		fields = append(fields, workflowstep.FieldRetryStrategy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowStepMutation) ClearField(name string) error {
	switch name {
	case workflowstep.FieldDescription:
		m.ClearDescription()
		return nil
	case workflowstep.FieldLabels:
		m.ClearLabels()
		return nil
	case workflowstep.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case workflowstep.FieldAttributes:
		m.ClearAttributes()
		return nil
	case workflowstep.FieldInputs:
		m.ClearInputs()
		return nil
	case workflowstep.FieldOutputs:
		m.ClearOutputs()
		return nil
	case workflowstep.FieldRetryStrategy:
		m.ClearRetryStrategy()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowStepMutation) ResetField(name string) error {
	switch name {
	case workflowstep.FieldName:
		m.ResetName()
		return nil
	case workflowstep.FieldDescription:
		m.ResetDescription()
		return nil
	case workflowstep.FieldLabels:
		m.ResetLabels()
		return nil
	case workflowstep.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case workflowstep.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workflowstep.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workflowstep.FieldType:
		m.ResetType()
		return nil
	case workflowstep.FieldProjectID:
		m.ResetProjectID()
		return nil
	case workflowstep.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflowstep.FieldWorkflowStageID:
		m.ResetWorkflowStageID()
		return nil
	case workflowstep.FieldAttributes:
		m.ResetAttributes()
		return nil
	case workflowstep.FieldInputs:
		m.ResetInputs()
		return nil
	case workflowstep.FieldOutputs:
		m.ResetOutputs()
		return nil
	case workflowstep.FieldOrder:
		m.ResetOrder()
		return nil
	case workflowstep.FieldDependencies:
		m.ResetDependencies()
		return nil
	case workflowstep.FieldRetryStrategy:
		m.ResetRetryStrategy()
		return nil
	case workflowstep.FieldTimeout:
		m.ResetTimeout()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, workflowstep.EdgeProject)
	}
	if m.stage != nil {
		edges = append(edges, workflowstep.EdgeStage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowstep.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case workflowstep.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowStepMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, workflowstep.EdgeProject)
	}
	if m.clearedstage {
		edges = append(edges, workflowstep.EdgeStage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowStepMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowstep.EdgeProject:
		return m.clearedproject
	case workflowstep.EdgeStage:
		return m.clearedstage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowStepMutation) ClearEdge(name string) error {
	switch name {
	case workflowstep.EdgeProject:
		m.ClearProject()
		return nil
	case workflowstep.EdgeStage:
		m.ClearStage()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowStepMutation) ResetEdge(name string) error {
	switch name {
	case workflowstep.EdgeProject:
		m.ResetProject()
		return nil
	case workflowstep.EdgeStage:
		m.ResetStage()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStep edge %s", name)
}

// WorkflowStepExecutionMutation represents an operation that mutates the WorkflowStepExecution nodes in the graph.
type WorkflowStepExecutionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *object.ID
	name                   *string
	description            *string
	labels                 *map[string]string
	annotations            *map[string]string
	create_time            *time.Time
	update_time            *time.Time
	status                 *status.Status
	workflow_step_id       *object.ID
	workflow_execution_id  *object.ID
	workflow_id            *object.ID
	_type                  *string
	attributes             *map[string]any
	times                  *int
	addtimes               *int
	execute_time           *time.Time
	duration               *int
	addduration            *int
	retryStrategy          **types.RetryStrategy
	timeout                *int
	addtimeout             *int
	_order                 *int
	add_order              *int
	record                 *string
	clearedFields          map[string]struct{}
	project                *object.ID
	clearedproject         bool
	stage_execution        *object.ID
	clearedstage_execution bool
	done                   bool
	oldValue               func(context.Context) (*WorkflowStepExecution, error)
	predicates             []predicate.WorkflowStepExecution
}

var _ ent.Mutation = (*WorkflowStepExecutionMutation)(nil)

// workflowStepExecutionOption allows management of the mutation configuration using functional options.
type workflowStepExecutionOption func(*WorkflowStepExecutionMutation)

// newWorkflowStepExecutionMutation creates new mutation for the WorkflowStepExecution entity.
func newWorkflowStepExecutionMutation(c config, op Op, opts ...workflowStepExecutionOption) *WorkflowStepExecutionMutation {
	m := &WorkflowStepExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowStepExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowStepExecutionID sets the ID field of the mutation.
func withWorkflowStepExecutionID(id object.ID) workflowStepExecutionOption {
	return func(m *WorkflowStepExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowStepExecution
		)
		m.oldValue = func(ctx context.Context) (*WorkflowStepExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowStepExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowStepExecution sets the old WorkflowStepExecution of the mutation.
func withWorkflowStepExecution(node *WorkflowStepExecution) workflowStepExecutionOption {
	return func(m *WorkflowStepExecutionMutation) {
		m.oldValue = func(context.Context) (*WorkflowStepExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowStepExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowStepExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowStepExecution entities.
func (m *WorkflowStepExecutionMutation) SetID(id object.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowStepExecutionMutation) ID() (id object.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowStepExecutionMutation) IDs(ctx context.Context) ([]object.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []object.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowStepExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowStepExecutionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowStepExecutionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowStepExecutionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowStepExecutionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowStepExecutionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowStepExecutionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflowstepexecution.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowStepExecutionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflowstepexecution.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowStepExecutionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflowstepexecution.FieldDescription)
}

// SetLabels sets the "labels" field.
func (m *WorkflowStepExecutionMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *WorkflowStepExecutionMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *WorkflowStepExecutionMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[workflowstepexecution.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *WorkflowStepExecutionMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[workflowstepexecution.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *WorkflowStepExecutionMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, workflowstepexecution.FieldLabels)
}

// SetAnnotations sets the "annotations" field.
func (m *WorkflowStepExecutionMutation) SetAnnotations(value map[string]string) {
	m.annotations = &value
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *WorkflowStepExecutionMutation) Annotations() (r map[string]string, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldAnnotations(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *WorkflowStepExecutionMutation) ClearAnnotations() {
	m.annotations = nil
	m.clearedFields[workflowstepexecution.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *WorkflowStepExecutionMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[workflowstepexecution.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *WorkflowStepExecutionMutation) ResetAnnotations() {
	m.annotations = nil
	delete(m.clearedFields, workflowstepexecution.FieldAnnotations)
}

// SetCreateTime sets the "create_time" field.
func (m *WorkflowStepExecutionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkflowStepExecutionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkflowStepExecutionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkflowStepExecutionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkflowStepExecutionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkflowStepExecutionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowStepExecutionMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowStepExecutionMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *WorkflowStepExecutionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[workflowstepexecution.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *WorkflowStepExecutionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[workflowstepexecution.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowStepExecutionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, workflowstepexecution.FieldStatus)
}

// SetWorkflowStepID sets the "workflow_step_id" field.
func (m *WorkflowStepExecutionMutation) SetWorkflowStepID(o object.ID) {
	m.workflow_step_id = &o
}

// WorkflowStepID returns the value of the "workflow_step_id" field in the mutation.
func (m *WorkflowStepExecutionMutation) WorkflowStepID() (r object.ID, exists bool) {
	v := m.workflow_step_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowStepID returns the old "workflow_step_id" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldWorkflowStepID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowStepID: %w", err)
	}
	return oldValue.WorkflowStepID, nil
}

// ResetWorkflowStepID resets all changes to the "workflow_step_id" field.
func (m *WorkflowStepExecutionMutation) ResetWorkflowStepID() {
	m.workflow_step_id = nil
}

// SetWorkflowExecutionID sets the "workflow_execution_id" field.
func (m *WorkflowStepExecutionMutation) SetWorkflowExecutionID(o object.ID) {
	m.workflow_execution_id = &o
}

// WorkflowExecutionID returns the value of the "workflow_execution_id" field in the mutation.
func (m *WorkflowStepExecutionMutation) WorkflowExecutionID() (r object.ID, exists bool) {
	v := m.workflow_execution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowExecutionID returns the old "workflow_execution_id" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldWorkflowExecutionID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowExecutionID: %w", err)
	}
	return oldValue.WorkflowExecutionID, nil
}

// ResetWorkflowExecutionID resets all changes to the "workflow_execution_id" field.
func (m *WorkflowStepExecutionMutation) ResetWorkflowExecutionID() {
	m.workflow_execution_id = nil
}

// SetWorkflowStageExecutionID sets the "workflow_stage_execution_id" field.
func (m *WorkflowStepExecutionMutation) SetWorkflowStageExecutionID(o object.ID) {
	m.stage_execution = &o
}

// WorkflowStageExecutionID returns the value of the "workflow_stage_execution_id" field in the mutation.
func (m *WorkflowStepExecutionMutation) WorkflowStageExecutionID() (r object.ID, exists bool) {
	v := m.stage_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowStageExecutionID returns the old "workflow_stage_execution_id" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldWorkflowStageExecutionID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowStageExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowStageExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowStageExecutionID: %w", err)
	}
	return oldValue.WorkflowStageExecutionID, nil
}

// ResetWorkflowStageExecutionID resets all changes to the "workflow_stage_execution_id" field.
func (m *WorkflowStepExecutionMutation) ResetWorkflowStageExecutionID() {
	m.stage_execution = nil
}

// SetProjectID sets the "project_id" field.
func (m *WorkflowStepExecutionMutation) SetProjectID(o object.ID) {
	m.project = &o
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *WorkflowStepExecutionMutation) ProjectID() (r object.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldProjectID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *WorkflowStepExecutionMutation) ResetProjectID() {
	m.project = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowStepExecutionMutation) SetWorkflowID(o object.ID) {
	m.workflow_id = &o
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowStepExecutionMutation) WorkflowID() (r object.ID, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldWorkflowID(ctx context.Context) (v object.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowStepExecutionMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetType sets the "type" field.
func (m *WorkflowStepExecutionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkflowStepExecutionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WorkflowStepExecutionMutation) ResetType() {
	m._type = nil
}

// SetAttributes sets the "attributes" field.
func (m *WorkflowStepExecutionMutation) SetAttributes(value map[string]any) {
	m.attributes = &value
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *WorkflowStepExecutionMutation) Attributes() (r map[string]any, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldAttributes(ctx context.Context) (v map[string]any, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *WorkflowStepExecutionMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[workflowstepexecution.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *WorkflowStepExecutionMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[workflowstepexecution.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *WorkflowStepExecutionMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, workflowstepexecution.FieldAttributes)
}

// SetTimes sets the "times" field.
func (m *WorkflowStepExecutionMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the value of the "times" field in the mutation.
func (m *WorkflowStepExecutionMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old "times" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to the "times" field.
func (m *WorkflowStepExecutionMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the "times" field in this mutation.
func (m *WorkflowStepExecutionMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes resets all changes to the "times" field.
func (m *WorkflowStepExecutionMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetExecuteTime sets the "execute_time" field.
func (m *WorkflowStepExecutionMutation) SetExecuteTime(t time.Time) {
	m.execute_time = &t
}

// ExecuteTime returns the value of the "execute_time" field in the mutation.
func (m *WorkflowStepExecutionMutation) ExecuteTime() (r time.Time, exists bool) {
	v := m.execute_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExecuteTime returns the old "execute_time" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldExecuteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecuteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecuteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecuteTime: %w", err)
	}
	return oldValue.ExecuteTime, nil
}

// ClearExecuteTime clears the value of the "execute_time" field.
func (m *WorkflowStepExecutionMutation) ClearExecuteTime() {
	m.execute_time = nil
	m.clearedFields[workflowstepexecution.FieldExecuteTime] = struct{}{}
}

// ExecuteTimeCleared returns if the "execute_time" field was cleared in this mutation.
func (m *WorkflowStepExecutionMutation) ExecuteTimeCleared() bool {
	_, ok := m.clearedFields[workflowstepexecution.FieldExecuteTime]
	return ok
}

// ResetExecuteTime resets all changes to the "execute_time" field.
func (m *WorkflowStepExecutionMutation) ResetExecuteTime() {
	m.execute_time = nil
	delete(m.clearedFields, workflowstepexecution.FieldExecuteTime)
}

// SetDuration sets the "duration" field.
func (m *WorkflowStepExecutionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *WorkflowStepExecutionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *WorkflowStepExecutionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *WorkflowStepExecutionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *WorkflowStepExecutionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetRetryStrategy sets the "retryStrategy" field.
func (m *WorkflowStepExecutionMutation) SetRetryStrategy(ts *types.RetryStrategy) {
	m.retryStrategy = &ts
}

// RetryStrategy returns the value of the "retryStrategy" field in the mutation.
func (m *WorkflowStepExecutionMutation) RetryStrategy() (r *types.RetryStrategy, exists bool) {
	v := m.retryStrategy
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryStrategy returns the old "retryStrategy" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldRetryStrategy(ctx context.Context) (v *types.RetryStrategy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryStrategy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryStrategy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryStrategy: %w", err)
	}
	return oldValue.RetryStrategy, nil
}

// ClearRetryStrategy clears the value of the "retryStrategy" field.
func (m *WorkflowStepExecutionMutation) ClearRetryStrategy() {
	m.retryStrategy = nil
	m.clearedFields[workflowstepexecution.FieldRetryStrategy] = struct{}{}
}

// RetryStrategyCleared returns if the "retryStrategy" field was cleared in this mutation.
func (m *WorkflowStepExecutionMutation) RetryStrategyCleared() bool {
	_, ok := m.clearedFields[workflowstepexecution.FieldRetryStrategy]
	return ok
}

// ResetRetryStrategy resets all changes to the "retryStrategy" field.
func (m *WorkflowStepExecutionMutation) ResetRetryStrategy() {
	m.retryStrategy = nil
	delete(m.clearedFields, workflowstepexecution.FieldRetryStrategy)
}

// SetTimeout sets the "timeout" field.
func (m *WorkflowStepExecutionMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *WorkflowStepExecutionMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *WorkflowStepExecutionMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *WorkflowStepExecutionMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *WorkflowStepExecutionMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetOrder sets the "order" field.
func (m *WorkflowStepExecutionMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *WorkflowStepExecutionMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *WorkflowStepExecutionMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *WorkflowStepExecutionMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *WorkflowStepExecutionMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetRecord sets the "record" field.
func (m *WorkflowStepExecutionMutation) SetRecord(s string) {
	m.record = &s
}

// Record returns the value of the "record" field in the mutation.
func (m *WorkflowStepExecutionMutation) Record() (r string, exists bool) {
	v := m.record
	if v == nil {
		return
	}
	return *v, true
}

// OldRecord returns the old "record" field's value of the WorkflowStepExecution entity.
// If the WorkflowStepExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowStepExecutionMutation) OldRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecord: %w", err)
	}
	return oldValue.Record, nil
}

// ResetRecord resets all changes to the "record" field.
func (m *WorkflowStepExecutionMutation) ResetRecord() {
	m.record = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *WorkflowStepExecutionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *WorkflowStepExecutionMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WorkflowStepExecutionMutation) ProjectIDs() (ids []object.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *WorkflowStepExecutionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetStageExecutionID sets the "stage_execution" edge to the WorkflowStageExecution entity by id.
func (m *WorkflowStepExecutionMutation) SetStageExecutionID(id object.ID) {
	m.stage_execution = &id
}

// ClearStageExecution clears the "stage_execution" edge to the WorkflowStageExecution entity.
func (m *WorkflowStepExecutionMutation) ClearStageExecution() {
	m.clearedstage_execution = true
}

// StageExecutionCleared reports if the "stage_execution" edge to the WorkflowStageExecution entity was cleared.
func (m *WorkflowStepExecutionMutation) StageExecutionCleared() bool {
	return m.clearedstage_execution
}

// StageExecutionID returns the "stage_execution" edge ID in the mutation.
func (m *WorkflowStepExecutionMutation) StageExecutionID() (id object.ID, exists bool) {
	if m.stage_execution != nil {
		return *m.stage_execution, true
	}
	return
}

// StageExecutionIDs returns the "stage_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageExecutionID instead. It exists only for internal usage by the builders.
func (m *WorkflowStepExecutionMutation) StageExecutionIDs() (ids []object.ID) {
	if id := m.stage_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStageExecution resets all changes to the "stage_execution" edge.
func (m *WorkflowStepExecutionMutation) ResetStageExecution() {
	m.stage_execution = nil
	m.clearedstage_execution = false
}

// Where appends a list predicates to the WorkflowStepExecutionMutation builder.
func (m *WorkflowStepExecutionMutation) Where(ps ...predicate.WorkflowStepExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowStepExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowStepExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowStepExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowStepExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowStepExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowStepExecution).
func (m *WorkflowStepExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowStepExecutionMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.name != nil {
		fields = append(fields, workflowstepexecution.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflowstepexecution.FieldDescription)
	}
	if m.labels != nil {
		fields = append(fields, workflowstepexecution.FieldLabels)
	}
	if m.annotations != nil {
		fields = append(fields, workflowstepexecution.FieldAnnotations)
	}
	if m.create_time != nil {
		fields = append(fields, workflowstepexecution.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workflowstepexecution.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, workflowstepexecution.FieldStatus)
	}
	if m.workflow_step_id != nil {
		fields = append(fields, workflowstepexecution.FieldWorkflowStepID)
	}
	if m.workflow_execution_id != nil {
		fields = append(fields, workflowstepexecution.FieldWorkflowExecutionID)
	}
	if m.stage_execution != nil {
		fields = append(fields, workflowstepexecution.FieldWorkflowStageExecutionID)
	}
	if m.project != nil {
		fields = append(fields, workflowstepexecution.FieldProjectID)
	}
	if m.workflow_id != nil {
		fields = append(fields, workflowstepexecution.FieldWorkflowID)
	}
	if m._type != nil {
		fields = append(fields, workflowstepexecution.FieldType)
	}
	if m.attributes != nil {
		fields = append(fields, workflowstepexecution.FieldAttributes)
	}
	if m.times != nil {
		fields = append(fields, workflowstepexecution.FieldTimes)
	}
	if m.execute_time != nil {
		fields = append(fields, workflowstepexecution.FieldExecuteTime)
	}
	if m.duration != nil {
		fields = append(fields, workflowstepexecution.FieldDuration)
	}
	if m.retryStrategy != nil {
		fields = append(fields, workflowstepexecution.FieldRetryStrategy)
	}
	if m.timeout != nil {
		fields = append(fields, workflowstepexecution.FieldTimeout)
	}
	if m._order != nil {
		fields = append(fields, workflowstepexecution.FieldOrder)
	}
	if m.record != nil {
		fields = append(fields, workflowstepexecution.FieldRecord)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowStepExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowstepexecution.FieldName:
		return m.Name()
	case workflowstepexecution.FieldDescription:
		return m.Description()
	case workflowstepexecution.FieldLabels:
		return m.Labels()
	case workflowstepexecution.FieldAnnotations:
		return m.Annotations()
	case workflowstepexecution.FieldCreateTime:
		return m.CreateTime()
	case workflowstepexecution.FieldUpdateTime:
		return m.UpdateTime()
	case workflowstepexecution.FieldStatus:
		return m.Status()
	case workflowstepexecution.FieldWorkflowStepID:
		return m.WorkflowStepID()
	case workflowstepexecution.FieldWorkflowExecutionID:
		return m.WorkflowExecutionID()
	case workflowstepexecution.FieldWorkflowStageExecutionID:
		return m.WorkflowStageExecutionID()
	case workflowstepexecution.FieldProjectID:
		return m.ProjectID()
	case workflowstepexecution.FieldWorkflowID:
		return m.WorkflowID()
	case workflowstepexecution.FieldType:
		return m.GetType()
	case workflowstepexecution.FieldAttributes:
		return m.Attributes()
	case workflowstepexecution.FieldTimes:
		return m.Times()
	case workflowstepexecution.FieldExecuteTime:
		return m.ExecuteTime()
	case workflowstepexecution.FieldDuration:
		return m.Duration()
	case workflowstepexecution.FieldRetryStrategy:
		return m.RetryStrategy()
	case workflowstepexecution.FieldTimeout:
		return m.Timeout()
	case workflowstepexecution.FieldOrder:
		return m.Order()
	case workflowstepexecution.FieldRecord:
		return m.Record()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowStepExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowstepexecution.FieldName:
		return m.OldName(ctx)
	case workflowstepexecution.FieldDescription:
		return m.OldDescription(ctx)
	case workflowstepexecution.FieldLabels:
		return m.OldLabels(ctx)
	case workflowstepexecution.FieldAnnotations:
		return m.OldAnnotations(ctx)
	case workflowstepexecution.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workflowstepexecution.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workflowstepexecution.FieldStatus:
		return m.OldStatus(ctx)
	case workflowstepexecution.FieldWorkflowStepID:
		return m.OldWorkflowStepID(ctx)
	case workflowstepexecution.FieldWorkflowExecutionID:
		return m.OldWorkflowExecutionID(ctx)
	case workflowstepexecution.FieldWorkflowStageExecutionID:
		return m.OldWorkflowStageExecutionID(ctx)
	case workflowstepexecution.FieldProjectID:
		return m.OldProjectID(ctx)
	case workflowstepexecution.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflowstepexecution.FieldType:
		return m.OldType(ctx)
	case workflowstepexecution.FieldAttributes:
		return m.OldAttributes(ctx)
	case workflowstepexecution.FieldTimes:
		return m.OldTimes(ctx)
	case workflowstepexecution.FieldExecuteTime:
		return m.OldExecuteTime(ctx)
	case workflowstepexecution.FieldDuration:
		return m.OldDuration(ctx)
	case workflowstepexecution.FieldRetryStrategy:
		return m.OldRetryStrategy(ctx)
	case workflowstepexecution.FieldTimeout:
		return m.OldTimeout(ctx)
	case workflowstepexecution.FieldOrder:
		return m.OldOrder(ctx)
	case workflowstepexecution.FieldRecord:
		return m.OldRecord(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowStepExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowStepExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowstepexecution.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflowstepexecution.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflowstepexecution.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case workflowstepexecution.FieldAnnotations:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	case workflowstepexecution.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workflowstepexecution.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workflowstepexecution.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowstepexecution.FieldWorkflowStepID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowStepID(v)
		return nil
	case workflowstepexecution.FieldWorkflowExecutionID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowExecutionID(v)
		return nil
	case workflowstepexecution.FieldWorkflowStageExecutionID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowStageExecutionID(v)
		return nil
	case workflowstepexecution.FieldProjectID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case workflowstepexecution.FieldWorkflowID:
		v, ok := value.(object.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflowstepexecution.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case workflowstepexecution.FieldAttributes:
		v, ok := value.(map[string]any)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case workflowstepexecution.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case workflowstepexecution.FieldExecuteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecuteTime(v)
		return nil
	case workflowstepexecution.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case workflowstepexecution.FieldRetryStrategy:
		v, ok := value.(*types.RetryStrategy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryStrategy(v)
		return nil
	case workflowstepexecution.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case workflowstepexecution.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case workflowstepexecution.FieldRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecord(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowStepExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowStepExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addtimes != nil {
		fields = append(fields, workflowstepexecution.FieldTimes)
	}
	if m.addduration != nil {
		fields = append(fields, workflowstepexecution.FieldDuration)
	}
	if m.addtimeout != nil {
		fields = append(fields, workflowstepexecution.FieldTimeout)
	}
	if m.add_order != nil {
		fields = append(fields, workflowstepexecution.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowStepExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowstepexecution.FieldTimes:
		return m.AddedTimes()
	case workflowstepexecution.FieldDuration:
		return m.AddedDuration()
	case workflowstepexecution.FieldTimeout:
		return m.AddedTimeout()
	case workflowstepexecution.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowStepExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowstepexecution.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case workflowstepexecution.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case workflowstepexecution.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	case workflowstepexecution.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowStepExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowStepExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowstepexecution.FieldDescription) {
		fields = append(fields, workflowstepexecution.FieldDescription)
	}
	if m.FieldCleared(workflowstepexecution.FieldLabels) {
		fields = append(fields, workflowstepexecution.FieldLabels)
	}
	if m.FieldCleared(workflowstepexecution.FieldAnnotations) {
		fields = append(fields, workflowstepexecution.FieldAnnotations)
	}
	if m.FieldCleared(workflowstepexecution.FieldStatus) {
		fields = append(fields, workflowstepexecution.FieldStatus)
	}
	if m.FieldCleared(workflowstepexecution.FieldAttributes) {
		fields = append(fields, workflowstepexecution.FieldAttributes)
	}
	if m.FieldCleared(workflowstepexecution.FieldExecuteTime) {
		fields = append(fields, workflowstepexecution.FieldExecuteTime)
	}
	if m.FieldCleared(workflowstepexecution.FieldRetryStrategy) {
		fields = append(fields, workflowstepexecution.FieldRetryStrategy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowStepExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowStepExecutionMutation) ClearField(name string) error {
	switch name {
	case workflowstepexecution.FieldDescription:
		m.ClearDescription()
		return nil
	case workflowstepexecution.FieldLabels:
		m.ClearLabels()
		return nil
	case workflowstepexecution.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	case workflowstepexecution.FieldStatus:
		m.ClearStatus()
		return nil
	case workflowstepexecution.FieldAttributes:
		m.ClearAttributes()
		return nil
	case workflowstepexecution.FieldExecuteTime:
		m.ClearExecuteTime()
		return nil
	case workflowstepexecution.FieldRetryStrategy:
		m.ClearRetryStrategy()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStepExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowStepExecutionMutation) ResetField(name string) error {
	switch name {
	case workflowstepexecution.FieldName:
		m.ResetName()
		return nil
	case workflowstepexecution.FieldDescription:
		m.ResetDescription()
		return nil
	case workflowstepexecution.FieldLabels:
		m.ResetLabels()
		return nil
	case workflowstepexecution.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	case workflowstepexecution.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workflowstepexecution.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workflowstepexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowstepexecution.FieldWorkflowStepID:
		m.ResetWorkflowStepID()
		return nil
	case workflowstepexecution.FieldWorkflowExecutionID:
		m.ResetWorkflowExecutionID()
		return nil
	case workflowstepexecution.FieldWorkflowStageExecutionID:
		m.ResetWorkflowStageExecutionID()
		return nil
	case workflowstepexecution.FieldProjectID:
		m.ResetProjectID()
		return nil
	case workflowstepexecution.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflowstepexecution.FieldType:
		m.ResetType()
		return nil
	case workflowstepexecution.FieldAttributes:
		m.ResetAttributes()
		return nil
	case workflowstepexecution.FieldTimes:
		m.ResetTimes()
		return nil
	case workflowstepexecution.FieldExecuteTime:
		m.ResetExecuteTime()
		return nil
	case workflowstepexecution.FieldDuration:
		m.ResetDuration()
		return nil
	case workflowstepexecution.FieldRetryStrategy:
		m.ResetRetryStrategy()
		return nil
	case workflowstepexecution.FieldTimeout:
		m.ResetTimeout()
		return nil
	case workflowstepexecution.FieldOrder:
		m.ResetOrder()
		return nil
	case workflowstepexecution.FieldRecord:
		m.ResetRecord()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStepExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowStepExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, workflowstepexecution.EdgeProject)
	}
	if m.stage_execution != nil {
		edges = append(edges, workflowstepexecution.EdgeStageExecution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowStepExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowstepexecution.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case workflowstepexecution.EdgeStageExecution:
		if id := m.stage_execution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowStepExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowStepExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowStepExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, workflowstepexecution.EdgeProject)
	}
	if m.clearedstage_execution {
		edges = append(edges, workflowstepexecution.EdgeStageExecution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowStepExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowstepexecution.EdgeProject:
		return m.clearedproject
	case workflowstepexecution.EdgeStageExecution:
		return m.clearedstage_execution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowStepExecutionMutation) ClearEdge(name string) error {
	switch name {
	case workflowstepexecution.EdgeProject:
		m.ClearProject()
		return nil
	case workflowstepexecution.EdgeStageExecution:
		m.ClearStageExecution()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStepExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowStepExecutionMutation) ResetEdge(name string) error {
	switch name {
	case workflowstepexecution.EdgeProject:
		m.ResetProject()
		return nil
	case workflowstepexecution.EdgeStageExecution:
		m.ResetStageExecution()
		return nil
	}
	return fmt.Errorf("unknown WorkflowStepExecution edge %s", name)
}
