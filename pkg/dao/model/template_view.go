// SPDX-FileCopyrightText: 2023 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/seal-io/walrus/pkg/dao/model/predicate"
	"github.com/seal-io/walrus/pkg/dao/model/template"
	"github.com/seal-io/walrus/pkg/dao/types/object"
	"github.com/seal-io/walrus/pkg/dao/types/status"
)

// TemplateCreateInput holds the creation input of the Template entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type TemplateCreateInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Source of the template.
	Source string `path:"-" query:"-" json:"source"`
	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
}

// Model returns the Template entity for creating,
// after validating.
func (tci *TemplateCreateInput) Model() *Template {
	if tci == nil {
		return nil
	}

	_t := &Template{
		Source:      tci.Source,
		Name:        tci.Name,
		Description: tci.Description,
		Labels:      tci.Labels,
	}

	return _t
}

// Validate checks the TemplateCreateInput entity.
func (tci *TemplateCreateInput) Validate() error {
	if tci == nil {
		return errors.New("nil receiver")
	}

	return tci.ValidateWith(tci.inputConfig.Context, tci.inputConfig.Client, nil)
}

// ValidateWith checks the TemplateCreateInput entity with the given context and client set.
func (tci *TemplateCreateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if tci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// TemplateCreateInputs holds the creation input item of the Template entities.
type TemplateCreateInputsItem struct {
	// Source of the template.
	Source string `path:"-" query:"-" json:"source"`
	// Name holds the value of the "name" field.
	Name string `path:"-" query:"-" json:"name"`
	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
}

// ValidateWith checks the TemplateCreateInputsItem entity with the given context and client set.
func (tci *TemplateCreateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if tci == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// TemplateCreateInputs holds the creation input of the Template entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type TemplateCreateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*TemplateCreateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Template entities for creating,
// after validating.
func (tci *TemplateCreateInputs) Model() []*Template {
	if tci == nil || len(tci.Items) == 0 {
		return nil
	}

	_ts := make([]*Template, len(tci.Items))

	for i := range tci.Items {
		_t := &Template{
			Source:      tci.Items[i].Source,
			Name:        tci.Items[i].Name,
			Description: tci.Items[i].Description,
			Labels:      tci.Items[i].Labels,
		}

		_ts[i] = _t
	}

	return _ts
}

// Validate checks the TemplateCreateInputs entity .
func (tci *TemplateCreateInputs) Validate() error {
	if tci == nil {
		return errors.New("nil receiver")
	}

	return tci.ValidateWith(tci.inputConfig.Context, tci.inputConfig.Client, nil)
}

// ValidateWith checks the TemplateCreateInputs entity with the given context and client set.
func (tci *TemplateCreateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if tci == nil {
		return errors.New("nil receiver")
	}

	if len(tci.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	for i := range tci.Items {
		if tci.Items[i] == nil {
			continue
		}

		if err := tci.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// TemplateDeleteInput holds the deletion input of the Template entity,
// please tags with `path:",inline"` if embedding.
type TemplateDeleteInput struct {
	TemplateQueryInput `path:",inline"`
}

// TemplateDeleteInputs holds the deletion input item of the Template entities.
type TemplateDeleteInputsItem struct {
	// ID of the Template entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Template entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// TemplateDeleteInputs holds the deletion input of the Template entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type TemplateDeleteInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*TemplateDeleteInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Template entities for deleting,
// after validating.
func (tdi *TemplateDeleteInputs) Model() []*Template {
	if tdi == nil || len(tdi.Items) == 0 {
		return nil
	}

	_ts := make([]*Template, len(tdi.Items))
	for i := range tdi.Items {
		_ts[i] = &Template{
			ID: tdi.Items[i].ID,
		}
	}
	return _ts
}

// IDs returns the ID list of the Template entities for deleting,
// after validating.
func (tdi *TemplateDeleteInputs) IDs() []object.ID {
	if tdi == nil || len(tdi.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(tdi.Items))
	for i := range tdi.Items {
		ids[i] = tdi.Items[i].ID
	}
	return ids
}

// Validate checks the TemplateDeleteInputs entity.
func (tdi *TemplateDeleteInputs) Validate() error {
	if tdi == nil {
		return errors.New("nil receiver")
	}

	return tdi.ValidateWith(tdi.inputConfig.Context, tdi.inputConfig.Client, nil)
}

// ValidateWith checks the TemplateDeleteInputs entity with the given context and client set.
func (tdi *TemplateDeleteInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if tdi == nil {
		return errors.New("nil receiver")
	}

	if len(tdi.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Templates().Query()

	ids := make([]object.ID, 0, len(tdi.Items))
	ors := make([]predicate.Template, 0, len(tdi.Items))
	indexers := make(map[any][]int)

	for i := range tdi.Items {
		if tdi.Items[i] == nil {
			return errors.New("nil item")
		}

		if tdi.Items[i].ID != "" {
			ids = append(ids, tdi.Items[i].ID)
			ors = append(ors, template.ID(tdi.Items[i].ID))
			indexers[tdi.Items[i].ID] = append(indexers[tdi.Items[i].ID], i)
		} else if tdi.Items[i].Name != "" {
			ors = append(ors, template.And(
				template.Name(tdi.Items[i].Name)))
			indexerKey := fmt.Sprint("/", tdi.Items[i].Name)
			indexers[indexerKey] = append(indexers[indexerKey], i)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	p := template.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = template.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			template.FieldID,
			template.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		indexer := indexers[es[i].ID]
		if indexer == nil {
			indexerKey := fmt.Sprint("/", es[i].Name)
			indexer = indexers[indexerKey]
		}
		for _, j := range indexer {
			tdi.Items[j].ID = es[i].ID
			tdi.Items[j].Name = es[i].Name
		}
	}

	return nil
}

// TemplateQueryInput holds the query input of the Template entity,
// please tags with `path:",inline"` if embedding.
type TemplateQueryInput struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Refer holds the route path reference of the Template entity.
	Refer *object.Refer `path:"template,default=" query:"-" json:"-"`
	// ID of the Template entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Template entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`
}

// Model returns the Template entity for querying,
// after validating.
func (tqi *TemplateQueryInput) Model() *Template {
	if tqi == nil {
		return nil
	}

	return &Template{
		ID:   tqi.ID,
		Name: tqi.Name,
	}
}

// Validate checks the TemplateQueryInput entity.
func (tqi *TemplateQueryInput) Validate() error {
	if tqi == nil {
		return errors.New("nil receiver")
	}

	return tqi.ValidateWith(tqi.inputConfig.Context, tqi.inputConfig.Client, nil)
}

// ValidateWith checks the TemplateQueryInput entity with the given context and client set.
func (tqi *TemplateQueryInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if tqi == nil {
		return errors.New("nil receiver")
	}

	if tqi.Refer != nil && *tqi.Refer == "" {
		return fmt.Errorf("model: %s : %w", template.Label, ErrBlankResourceRefer)
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Templates().Query()

	if tqi.Refer != nil {
		if tqi.Refer.IsID() {
			q.Where(
				template.ID(tqi.Refer.ID()))
		} else if refers := tqi.Refer.Split(1); len(refers) == 1 {
			q.Where(
				template.Name(refers[0].String()))
		} else {
			return errors.New("invalid identify refer of template")
		}
	} else if tqi.ID != "" {
		q.Where(
			template.ID(tqi.ID))
	} else if tqi.Name != "" {
		q.Where(
			template.Name(tqi.Name))
	} else {
		return errors.New("invalid identify of template")
	}

	q.Select(
		template.FieldID,
		template.FieldName,
	)

	var e *Template
	{
		// Get cache from previous validation.
		queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
		ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
		if cv, existed := cache[ck]; !existed {
			var err error
			e, err = q.Only(ctx)
			if err != nil {
				return err
			}

			// Set cache for other validation.
			cache[ck] = e
		} else {
			e = cv.(*Template)
		}
	}

	tqi.ID = e.ID
	tqi.Name = e.Name
	return nil
}

// TemplateQueryInputs holds the query input of the Template entities,
// please tags with `path:",inline" query:",inline"` if embedding.
type TemplateQueryInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`
}

// Validate checks the TemplateQueryInputs entity.
func (tqi *TemplateQueryInputs) Validate() error {
	if tqi == nil {
		return errors.New("nil receiver")
	}

	return tqi.ValidateWith(tqi.inputConfig.Context, tqi.inputConfig.Client, nil)
}

// ValidateWith checks the TemplateQueryInputs entity with the given context and client set.
func (tqi *TemplateQueryInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if tqi == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// TemplateUpdateInput holds the modification input of the Template entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type TemplateUpdateInput struct {
	TemplateQueryInput `path:",inline" query:"-" json:"-"`

	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
}

// Model returns the Template entity for modifying,
// after validating.
func (tui *TemplateUpdateInput) Model() *Template {
	if tui == nil {
		return nil
	}

	_t := &Template{
		ID:          tui.ID,
		Name:        tui.Name,
		Description: tui.Description,
		Labels:      tui.Labels,
	}

	return _t
}

// Validate checks the TemplateUpdateInput entity.
func (tui *TemplateUpdateInput) Validate() error {
	if tui == nil {
		return errors.New("nil receiver")
	}

	return tui.ValidateWith(tui.inputConfig.Context, tui.inputConfig.Client, nil)
}

// ValidateWith checks the TemplateUpdateInput entity with the given context and client set.
func (tui *TemplateUpdateInput) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if cache == nil {
		cache = map[string]any{}
	}

	if err := tui.TemplateQueryInput.ValidateWith(ctx, cs, cache); err != nil {
		return err
	}

	return nil
}

// TemplateUpdateInputs holds the modification input item of the Template entities.
type TemplateUpdateInputsItem struct {
	// ID of the Template entity, tries to retrieve the entity with the following unique index parts if no ID provided.
	ID object.ID `path:"-" query:"-" json:"id,omitempty"`
	// Name of the Template entity, a part of the unique index.
	Name string `path:"-" query:"-" json:"name,omitempty"`

	// Description holds the value of the "description" field.
	Description string `path:"-" query:"-" json:"description,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels map[string]string `path:"-" query:"-" json:"labels,omitempty"`
}

// ValidateWith checks the TemplateUpdateInputsItem entity with the given context and client set.
func (tui *TemplateUpdateInputsItem) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if tui == nil {
		return errors.New("nil receiver")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	return nil
}

// TemplateUpdateInputs holds the modification input of the Template entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type TemplateUpdateInputs struct {
	inputConfig `path:"-" query:"-" json:"-"`

	// Items holds the entities to create, which MUST not be empty.
	Items []*TemplateUpdateInputsItem `path:"-" query:"-" json:"items"`
}

// Model returns the Template entities for modifying,
// after validating.
func (tui *TemplateUpdateInputs) Model() []*Template {
	if tui == nil || len(tui.Items) == 0 {
		return nil
	}

	_ts := make([]*Template, len(tui.Items))

	for i := range tui.Items {
		_t := &Template{
			ID:          tui.Items[i].ID,
			Name:        tui.Items[i].Name,
			Description: tui.Items[i].Description,
			Labels:      tui.Items[i].Labels,
		}

		_ts[i] = _t
	}

	return _ts
}

// IDs returns the ID list of the Template entities for modifying,
// after validating.
func (tui *TemplateUpdateInputs) IDs() []object.ID {
	if tui == nil || len(tui.Items) == 0 {
		return nil
	}

	ids := make([]object.ID, len(tui.Items))
	for i := range tui.Items {
		ids[i] = tui.Items[i].ID
	}
	return ids
}

// Validate checks the TemplateUpdateInputs entity.
func (tui *TemplateUpdateInputs) Validate() error {
	if tui == nil {
		return errors.New("nil receiver")
	}

	return tui.ValidateWith(tui.inputConfig.Context, tui.inputConfig.Client, nil)
}

// ValidateWith checks the TemplateUpdateInputs entity with the given context and client set.
func (tui *TemplateUpdateInputs) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
	if tui == nil {
		return errors.New("nil receiver")
	}

	if len(tui.Items) == 0 {
		return errors.New("empty items")
	}

	if cache == nil {
		cache = map[string]any{}
	}

	q := cs.Templates().Query()

	ids := make([]object.ID, 0, len(tui.Items))
	ors := make([]predicate.Template, 0, len(tui.Items))
	indexers := make(map[any][]int)

	for i := range tui.Items {
		if tui.Items[i] == nil {
			return errors.New("nil item")
		}

		if tui.Items[i].ID != "" {
			ids = append(ids, tui.Items[i].ID)
			ors = append(ors, template.ID(tui.Items[i].ID))
			indexers[tui.Items[i].ID] = append(indexers[tui.Items[i].ID], i)
		} else if tui.Items[i].Name != "" {
			ors = append(ors, template.And(
				template.Name(tui.Items[i].Name)))
			indexerKey := fmt.Sprint("/", tui.Items[i].Name)
			indexers[indexerKey] = append(indexers[indexerKey], i)
		} else {
			return errors.New("found item hasn't identify")
		}
	}

	p := template.IDIn(ids...)
	if len(ids) != cap(ids) {
		p = template.Or(ors...)
	}

	es, err := q.
		Where(p).
		Select(
			template.FieldID,
			template.FieldName,
		).
		All(ctx)
	if err != nil {
		return err
	}

	if len(es) != cap(ids) {
		return errors.New("found unrecognized item")
	}

	for i := range es {
		indexer := indexers[es[i].ID]
		if indexer == nil {
			indexerKey := fmt.Sprint("/", es[i].Name)
			indexer = indexers[indexerKey]
		}
		for _, j := range indexer {
			tui.Items[j].ID = es[i].ID
			tui.Items[j].Name = es[i].Name
		}
	}

	for i := range tui.Items {
		if err := tui.Items[i].ValidateWith(ctx, cs, cache); err != nil {
			return err
		}
	}

	return nil
}

// TemplateOutput holds the output of the Template entity.
type TemplateOutput struct {
	ID          object.ID         `json:"id,omitempty"`
	Name        string            `json:"name,omitempty"`
	Description string            `json:"description,omitempty"`
	Labels      map[string]string `json:"labels,omitempty"`
	CreateTime  *time.Time        `json:"createTime,omitempty"`
	UpdateTime  *time.Time        `json:"updateTime,omitempty"`
	Status      status.Status     `json:"status,omitempty"`
	Icon        string            `json:"icon,omitempty"`
	Source      string            `json:"source,omitempty"`

	Catalog *CatalogOutput `json:"catalog,omitempty"`
}

// View returns the output of Template entity.
func (_t *Template) View() *TemplateOutput {
	return ExposeTemplate(_t)
}

// View returns the output of Template entities.
func (_ts Templates) View() []*TemplateOutput {
	return ExposeTemplates(_ts)
}

// ExposeTemplate converts the Template to TemplateOutput.
func ExposeTemplate(_t *Template) *TemplateOutput {
	if _t == nil {
		return nil
	}

	to := &TemplateOutput{
		ID:          _t.ID,
		Name:        _t.Name,
		Description: _t.Description,
		Labels:      _t.Labels,
		CreateTime:  _t.CreateTime,
		UpdateTime:  _t.UpdateTime,
		Status:      _t.Status,
		Icon:        _t.Icon,
		Source:      _t.Source,
	}

	if _t.Edges.Catalog != nil {
		to.Catalog = ExposeCatalog(_t.Edges.Catalog)
	} else if _t.CatalogID != "" {
		to.Catalog = &CatalogOutput{
			ID: _t.CatalogID,
		}
	}
	return to
}

// ExposeTemplates converts the Template slice to TemplateOutput pointer slice.
func ExposeTemplates(_ts []*Template) []*TemplateOutput {
	if len(_ts) == 0 {
		return nil
	}

	tos := make([]*TemplateOutput, len(_ts))
	for i := range _ts {
		tos[i] = ExposeTemplate(_ts[i])
	}
	return tos
}
