{{/* gotype: entgo.io/ent/entc/gen.Type */}}

{{ define "view" }}

{{ template "header" $ }}

{{ with extend $ "Imports" $.SiblingImports }}
    {{ template "import" . }}
{{ end }}

{{- with $tmpls := matchTemplate "input/*" }}
    {{- range $tmpl := $tmpls }}
        {{ xtemplate $tmpl $ }}
    {{- end }}
{{- end }}

{{ xtemplate "output" $ }}

{{ end }}



{{- /* CreateInput */}}
{{ define "input/create" }}

{{ $input := getInput $ "Create" }}

{{ $singular := printf "%sCreateInput" $.Name }}
{{ $receiver := receiver $singular }}

// {{ $singular }} holds the creation input of the {{ $.Name }} entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type {{ $singular }} struct {
    inputConfig `path:"-" query:"-" json:"-"`

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        // {{ $en }} indicates to create {{ $.Name }} entity {{ if $e.Optional }}CAN{{ else }}MUST{{ end }} under the {{ $en }} route.
        {{ $en }} *{{ $e.Type.Name }}QueryInput `path:",inline" query:"-" json:"-"`
    {{- end }}

    {{ range $f := $input.Fields }}
        {{- $fn := $f.StructField }}
        {{- template "comment" $f }}
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `path:"-" query:"-" {{ getStructTag $f "json" "Create" }}`
    {{- end }}

    {{ range $e := $input.AdditionalEdges }}
        {{- $en := $e.StructField }}
        // {{ $en }} specifies full inserting the new {{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }} {{ if not $e.Unique }}entities{{ else }}entity{{ end }} of the {{ $.Name }} entity.
        {{ $en }} {{ if not $e.Unique }}[]{{ end }}*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}{{ if or $e.M2M $e.O2M }}CreateInput{{ else }}QueryInput{{ end }} `uri:"-" query:"-" {{ getStructTag $e "json" "Create" }}`
    {{- end }}
}

// Model returns the {{ $.Name }} entity for creating,
// after validating.
func ({{ $receiver }} *{{ $singular }}) Model() *{{ $.Name }} {
    if {{ $receiver }} == nil {
        return nil
    }

    {{ $modelReceiver := printf "_%s" $.Receiver -}}

    {{ $modelReceiver }} := &{{ $.Name }}{
        {{- range $f := $input.Fields }}
            {{- $fn := $f.StructField }}
            {{ $fn }}: {{ $receiver }}.{{ $fn }},
        {{- end }}
    }

    {{ range $f := $input.PrerequisiteFields }}
        {{- $fn := $f.StructField }}
        {{- $e := $f.Edge }}
        {{- $ef := $e.Field }}
        {{- $en := pascal (singular $e.Name) }}
        if {{ $receiver }}.{{ $en }} != nil {
            {{ $modelReceiver }}.{{ $fn }} = {{ if and $ef $ef.NillableValue }}&{{ end }}{{ $receiver }}.{{ $en }}.ID
        }
    {{- end }}

    {{ range $e := $input.AdditionalEdges }}
        {{- $en := $e.StructField }}
        {{- if not $e.Unique }}
            if {{ $receiver }}.{{ $en }} != nil {
                // Empty slice is used for clearing the edge.
                {{ $modelReceiver }}.Edges.{{ $en }} = make([]*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}, 0 , len({{ $receiver }}.{{ $en }}))
            }
            for j := range {{ $receiver }}.{{ $en }} {
                if {{ $receiver }}.{{ $en }}[j] == nil {
                    continue
                }
                {{ $modelReceiver }}.Edges.{{ $en }} = append({{ $modelReceiver }}.Edges.{{ $en }},
                    {{ $receiver }}.{{ $en }}[j].Model())
            }
        {{- else }}
            {{- $ef := $e.Field }}
            if {{ $receiver }}.{{ $en }} != nil {
            {{- if $ef }}
                {{ $modelReceiver }}.{{ $ef.StructField }} = {{ if $ef.NillableValue }}&{{ end }}{{ $receiver }}.{{ $en }}.ID
            {{- else }}
                {{ $modelReceiver }}.Edges.{{ $en }} = {{ $receiver }}.{{ $en }}.Model()
            {{- end }}
            }
        {{- end }}
    {{- end }}
    return {{ $modelReceiver }}
}

// Validate checks the {{ $singular }} entity.
func ({{ $receiver }} *{{ $singular }}) Validate() error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    return {{ $receiver }}.ValidateWith({{ $receiver }}.inputConfig.Context, {{ $receiver }}.inputConfig.Client, nil)
}

// ValidateWith checks the {{ $singular }} entity with the given context and client set.
func ({{ $receiver }} *{{ $singular }}) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    if cache == nil {
        cache = map[string]any{}
    }

    {{ $util := lower $.Name }}

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        {{- $f := $e.Field }}
        // Validate when creating under the {{ $en }} route.
        if {{ $receiver }}.{{ $en }} != nil {
            {{- $optional := $e.Optional }}
            {{- if $e.Through }}
                {{- range $te := $e.Through.Edges }} {{ if eq $e.Type $te.Type }} {{ $optional = $te.Optional }} {{ end }} {{ end }}
            {{- end }}
            if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                {{- if $optional }}
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                    }
                {{- else }}
                    return err
                {{- end }}
            }
        }
    {{- end }}

    {{ range $e := $input.AdditionalEdges }}
        {{ $en := $e.StructField }}
        {{- if not $e.Unique }}
            for i := range {{ $receiver }}.{{ $en }} {
                if {{ $receiver }}.{{ $en }}[i] == nil {
                    continue
                }
                
                if err := {{ $receiver }}.{{ $en }}[i].ValidateWith(ctx, cs, cache); err != nil {
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }}[i] = nil
                    }
                }
            }
        {{- else }}
            if {{ $receiver }}.{{ $en }} != nil {
                if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                    }
                }
            }
        {{- end }}
    {{- end }}

    return nil
}

{{ $plural := plural $singular }}
{{ $receiver = receiver $plural }}

// {{ $plural }} holds the creation input item of the {{ $.Name }} entities.
type {{ $plural }}Item struct {
    {{- range $f := $input.Fields }}
        {{- $fn := $f.StructField }}
        {{- template "comment" $f }}
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `path:"-" query:"-" {{ getStructTag $f "json" "Create" }}`
    {{- end }}

    {{ range $e := $input.AdditionalEdges }}
        {{- $en := $e.StructField }}
        // {{ $en }} specifies full inserting the new {{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }} {{ if not $e.Unique }}entities{{ else }}entity{{ end }}.
        {{ $en }} {{ if not $e.Unique }}[]{{ end }}*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}{{ if or $e.M2M $e.O2M }}CreateInput{{ else }}QueryInput{{ end }} `uri:"-" query:"-" {{ getStructTag $e "json" "Create" }}`
    {{- end }}
}

// ValidateWith checks the {{ $plural }}Item entity with the given context and client set.
func ({{ $receiver }} *{{ $plural }}Item) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    if cache == nil {
        cache = map[string]any{}
    }

    {{ range $e := $input.AdditionalEdges }}
        {{ $en := $e.StructField }}
        {{- if not $e.Unique }}
            for i := range {{ $receiver }}.{{ $en }} {
                if {{ $receiver }}.{{ $en }}[i] == nil {
                    continue
                }
                
                if err := {{ $receiver }}.{{ $en }}[i].ValidateWith(ctx, cs, cache); err != nil {
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }}[i] = nil
                    }
                }
            }
        {{- else }}
            if {{ $receiver }}.{{ $en }} != nil {
                if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                    }
                }
            }
        {{- end }}
    {{- end }}

    return nil
}

// {{ $plural }} holds the creation input of the {{ $.Name }} entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type {{ $plural }} struct {
    inputConfig `path:"-" query:"-" json:"-"`

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        // {{ $en }} indicates to create {{ $.Name }} entity {{ if $e.Optional }}CAN{{ else }}MUST{{ end }} under the {{ $en }} route.
        {{ $en }} *{{ $e.Type.Name }}QueryInput `path:",inline" query:"-" json:"-"`
    {{- end }}

    // Items holds the entities to create, which MUST not be empty.
    Items []*{{ $plural }}Item `path:"-" query:"-" json:"items"`
}

// Model returns the {{ $.Name }} entities for creating,
// after validating.
func ({{ $receiver }} *{{ $plural }}) Model() []*{{ $.Name }} {
    if {{ $receiver }} == nil || len({{ $receiver }}.Items) == 0 {
        return nil
    }

    {{ $modelsReceiver := printf "%ss" $modelReceiver }}

    {{ $modelsReceiver }} := make([]*{{ $.Name }}, len({{ $receiver }}.Items))

    for i := range {{ $receiver }}.Items {
        {{ $modelReceiver }} := &{{ $.Name }}{
            {{- range $f := $input.Fields }}
                {{- $fn := $f.StructField }}
                {{ $fn }}: {{ $receiver }}.Items[i].{{ $fn }},
            {{- end }}
        }

        {{ range $f := $input.PrerequisiteFields }}
            {{- $fn := $f.StructField }}
            {{- $e := $f.Edge }}
            {{- $ef := $e.Field }}
            {{- $en := pascal (singular $e.Name) }}
            if {{ $receiver }}.{{ $en }} != nil {
                {{ $modelReceiver }}.{{ $fn }} = {{ if and $ef $ef.NillableValue }}&{{ end }}{{ $receiver }}.{{ $en }}.ID
            }
        {{- end }}

        {{ range $e := $input.AdditionalEdges }}
            {{- $en := $e.StructField }}
            {{- if not $e.Unique }}
                if {{ $receiver }}.Items[i].{{ $en }} != nil {
                    // Empty slice is used for clearing the edge.
                    {{ $modelReceiver }}.Edges.{{ $en }} = make([]*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}, 0 , len({{ $receiver }}.Items[i].{{ $en }}))
                }
                for j := range {{ $receiver }}.Items[i].{{ $en }} {
                    if {{ $receiver }}.Items[i].{{ $en }}[j] == nil {
                        continue
                    }
                    {{ $modelReceiver }}.Edges.{{ $en }} = append({{ $modelReceiver }}.Edges.{{ $en }},
                        {{ $receiver }}.Items[i].{{ $en }}[j].Model())
                }
            {{- else }}
                {{- $ef := $e.Field }}
                if {{ $receiver }}.Items[i].{{ $en }} != nil {
                {{- if $ef }}
                    {{ $modelReceiver }}.{{ $ef.StructField }} = {{ if $ef.NillableValue }}&{{ end }}{{ $receiver }}.Items[i].{{ $en }}.ID
                {{- else }}
                    {{ $modelReceiver }}.Edges.{{ $en }} = {{ $receiver }}.Items[i].{{ $en }}.Model()
                {{- end }}
                }
            {{- end }}
        {{- end }}

        {{ $modelsReceiver }}[i] = {{ $modelReceiver }}
    }

    return {{ $modelsReceiver }}
}

// Validate checks the {{ $plural }} entity .
func ({{ $receiver }} *{{ $plural }}) Validate() error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    return {{ $receiver }}.ValidateWith({{ $receiver }}.inputConfig.Context, {{ $receiver }}.inputConfig.Client, nil)
}

// ValidateWith checks the {{ $plural }} entity with the given context and client set.
func ({{ $receiver }} *{{ $plural }}) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    if len({{ $receiver }}.Items) == 0 {
        return errors.New("empty items")
    }

    if cache == nil {
        cache = map[string]any{}
    }

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        // Validate when creating under the {{ $en }} route.
        if {{ $receiver }}.{{ $en }} != nil {
            if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                if !IsBlankResourceReferError(err) {
                    return err
                } else {
                    {{ $receiver }}.{{ $en }} = nil
                }
            }
        }
    {{- end }}

    for i := range {{ $receiver }}.Items {
        if {{ $receiver }}.Items[i] == nil {
            continue
        }

        if err := {{ $receiver }}.Items[i].ValidateWith(ctx, cs, cache); err != nil {
            return err
        }
    }

    return nil
}

{{ end }}



{{- /* DeleteInput */}}
{{ define "input/delete" }}

{{ $input := getInput $ "Delete" }}

{{ $singular := printf "%sDeleteInput" $.Name }}

// {{ $singular }} holds the deletion input of the {{ $.Name }} entity,
// please tags with `path:",inline"` if embedding.
type {{ $singular }} struct {
    {{ printf "%sQueryInput" $.Name }} `path:",inline"`
}

{{ $plural := plural $singular }}
{{ $receiver := receiver $plural }}

// {{ $plural }} holds the deletion input item of the {{ $.Name }} entities.
type {{ $plural }}Item struct {
    // ID of the {{ $.Name }} entity{{ if ne (len $input.IndexFields) 0 }}, tries to retrieve the entity with the following unique index parts if no ID provided{{ end }}.
    ID {{ $.ID.Type }} `path:"-" query:"-" json:"id{{ if ne (len $input.IndexFields) 0 }},omitempty{{ end }}"`
    {{- range $f := $input.IndexFields }}
        {{- $fn := $f.StructField }}
        // {{ $fn }} of the {{ $.Name }} entity, a part of the unique index.
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `path:"-" query:"-" json:"{{ camel $fn }},omitempty"`
    {{- end }}
}

// {{ $plural }} holds the deletion input of the {{ $.Name }} entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type {{ $plural }} struct {
    inputConfig `path:"-" query:"-" json:"-"`

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        // {{ $en }} indicates to delete {{ $.Name }} entity {{ if $e.Optional }}CAN{{ else }}MUST{{ end }} under the {{ $en }} route.
        {{ $en }} *{{ $e.Type.Name }}QueryInput `path:",inline" query:"-" json:"-"`
    {{- end }}

    // Items holds the entities to create, which MUST not be empty.
    Items []*{{ $plural }}Item `path:"-" query:"-" json:"items"`
}

// Model returns the {{ $.Name }} entities for deleting,
// after validating.
func ({{ $receiver }} *{{ $plural }}) Model() []*{{ $.Name }} {
    if {{ $receiver }} == nil || len({{ $receiver }}.Items) == 0 {
        return nil
    }

    {{ $modelsReceiver := printf "_%ss" ($.Receiver) }}

    {{ $modelsReceiver }} := make([]*{{ $.Name }}, len({{ $receiver }}.Items))
    for i := range {{ $receiver }}.Items {
        {{ $modelsReceiver }}[i] = &{{ $.Name }}{
            ID: {{ $receiver }}.Items[i].ID,
        }
    }
    return {{ $modelsReceiver }}
}

// IDs returns the ID list of the {{ $.Name }} entities for deleting,
// after validating.
func ({{ $receiver }} *{{ $plural }}) IDs() []{{ $.ID.Type }} {
    if {{ $receiver }} == nil || len({{ $receiver }}.Items) == 0 {
        return nil
    }

    ids := make([]{{ $.ID.Type }}, len({{ $receiver }}.Items))
    for i := range {{ $receiver }}.Items {
        ids[i] = {{ $receiver }}.Items[i].ID
    }
    return ids
}

// Validate checks the {{ $plural }} entity.
func ({{ $receiver }} *{{ $plural }}) Validate() error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    return {{ $receiver }}.ValidateWith({{ $receiver }}.inputConfig.Context, {{ $receiver }}.inputConfig.Client, nil)
}

// ValidateWith checks the {{ $plural }} entity with the given context and client set.
func ({{ $receiver }} *{{ $plural }}) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    if len({{ $receiver }}.Items) == 0 {
        return errors.New("empty items")
    }

    if cache == nil {
        cache = map[string]any{}
    }

    {{ $util := lower $.Name }}

    q := cs.{{ plural $.Name }}().Query()

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        {{- $f := $e.Field }}
        // Validate when deleting under the {{ $en }} route.
        if {{ $receiver }}.{{ $en }} != nil {
            {{- $optional := $e.Optional }}
            {{- if $e.Through }}
                {{- range $te := $e.Through.Edges }} {{ if eq $e.Type $te.Type }} {{ $optional = $te.Optional }} {{ end }} {{ end }}
            {{- end }}
            if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                {{- if $optional }}
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                        {{- if $f }}
                            q.Where(
                                {{ $util }}.{{ $f.StructField }}IsNil())
                        {{- else }}
                            q.Where(
                                predicate.{{ $.Name }}(sql.FieldIsNull({{ $util }}.{{ $en }}Column)))
                        {{- end }}
                    }
                {{- else }}
                    return err
                {{- end }}
            } else {
                {{- $ants := extractAnnotation $e }}{{ if $ants.ValidateContextFuncs }}ctx = valueContext(ctx, {{ join $ants.ValidateContextFuncs ", " }}){{ end }}
                {{- if and $f (not $e.M2M) }}
                    q.Where(
                        {{ $util }}.{{ $f.StructField }}({{ $receiver }}.{{ $en }}.ID))
                {{- else if and (not $f) (not $e.M2M) }}
                    q.Where(
                        predicate.{{ $.Name }}(sql.FieldEQ({{ $util }}.{{ $en }}Column, {{ $receiver }}.{{ $en }}.ID)))
                {{- else }}
                    q.Where(
                        {{ $util }}.Has{{ pascal $e.Name }}With({{ if $e.Through }}{{ lower $e.Through.Name }}.{{ $e.Type.Name }}ID{{ else }}{{ lower $e.Owner.Name }}.ID{{ end }}({{ $receiver }}.{{ $en }}.ID)))
                {{- end }}
            }
        {{- if $optional }}
        } else {
            {{- if $f }}
                q.Where(
                    {{ $util }}.{{ $f.StructField }}IsNil())
            {{- else }}
                q.Where(
                    predicate.{{ $.Name }}(sql.FieldIsNull({{ $util }}.{{ $en }}Column)))
            {{- end }}
        {{- end }}
        }
    {{ end }}

    ids := make([]{{ $.ID.Type }}, 0, len({{ $receiver }}.Items))

    {{- if gt (len $input.IndexFields) 0 }}
    ors := make([]predicate.{{ $.Name }}, 0, len({{ $receiver }}.Items))
    indexers := make(map[any][]int)
    {{- end }}

    for i := range {{ $receiver }}.Items {
        if {{ $receiver }}.Items[i] == nil {
            return errors.New("nil item")
        }

        {{ if and $.ID.Type (ge $.ID.Type.Type 9) }}
        if {{ $receiver }}.Items[i].ID != 0 {
        {{- else }}
        if {{ $receiver }}.Items[i].ID != "" {
        {{- end }}
            ids = append(ids, {{ $receiver }}.Items[i].ID)
        {{- if gt (len $input.IndexFields) 0 }}
            ors = append(ors, {{ $util }}.ID({{ $receiver }}.Items[i].ID))
            indexers[{{ $receiver }}.Items[i].ID] = append(indexers[{{ $receiver }}.Items[i].ID], i)
        } else if
        {{- $idx := 0 -}}
        {{- range $idx, $f := $input.IndexFields -}}
            {{- $fn := $f.StructField -}}
            {{- if gt $idx 0 -}} && {{- end -}}
            {{- if $f.NillableValue -}}
                ({{ $receiver }}.Items[i].{{ $fn }} != nil)
            {{- else if and $f.Type (ge $f.Type.Type 9) -}} {{- /* Numeric */}}
                ({{ $receiver }}.Items[i].{{ $fn }} != 0)
            {{- else if or $f.IsString $f.IsEnum -}}
                ({{ $receiver }}.Items[i].{{ $fn }} != "")
            {{- else if and $f.Type $f.Type.RType (ge $f.Type.RType.Kind 21) (le $f.Type.RType.Kind 23) -}} {{- /* Map, Pointer, Slice */}}
                ({{ $receiver }}.Items[i].{{ $fn }} != nil)
            {{- end -}}
        {{- end -}}
        {
            ors = append(ors, {{ $util }}.And(
                    {{- range $f := $input.IndexFields -}}
                        {{- $fn := $f.StructField }}
                        {{ $util }}.{{ $fn }}({{ $receiver }}.Items[i].{{ $fn }}),
                    {{- end -}}
                ))
            indexerKey := fmt.Sprint({{ range $f := $input.IndexFields }}"/",{{ $receiver }}.Items[i].{{ $f.StructField }},{{ end }})
            indexers[indexerKey] = append(indexers[indexerKey], i)
        {{- end }}
        } else {
            return errors.New("found item hasn't identify")
        }
    }

    {{ $ants := extractAnnotation $ }}{{ if $ants.ValidateContextFuncs }}ctx = valueContext(ctx, {{ join $ants.ValidateContextFuncs ", " }}){{ end }}

    {{ if gt (len $input.IndexFields) 0 }}
    p := {{ $util }}.IDIn(ids...)
    if len(ids) != cap(ids) {
        p = {{ $util }}.Or(ors...)
    }

    es, err := q.
        Where(p).
        Select(
            {{ $util }}.FieldID,
            {{- range $idx, $f := $input.IndexFields }}
                {{- $fn := $f.StructField }}
                {{ $util }}.Field{{ $fn }},
            {{- end }}
        ).
        All(ctx)
    if err != nil {
        return err
    }

    if len(es) != cap(ids) {
        return errors.New("found unrecognized item")
    }

    for i := range es {
        indexer := indexers[es[i].ID]
        if indexer == nil {
            indexerKey := fmt.Sprint({{ range $f := $input.IndexFields }}"/",{{ $receiver }}.Items[i].{{ $f.StructField }},{{ end }})
            indexer = indexers[indexerKey]
        }
        for _, j := range indexer {
            {{ $receiver }}.Items[j].ID = es[i].ID
            {{- range $idx, $f := $input.IndexFields -}}
                {{- $fn := $f.StructField }}
                {{ $receiver }}.Items[j].{{ $fn }} = es[i].{{ $fn }}
            {{- end }}
        }
    }
    {{- else }}
    if len(ids) != cap(ids) {
        return errors.New("found unrecognized item")
    }

    idsCnt, err := q.Where({{ $util }}.IDIn(ids...)).
        Count(ctx)
    if err != nil {
        return err
    }

    if idsCnt != cap(ids) {
        return errors.New("found unrecognized item")
    }
    {{- end }}

    return nil
}

{{ end }}



{{- /* QueryInput */}}
{{ define "input/query" }}

{{ $input := getInput $ "Query" }}

{{ $singular := printf "%sQueryInput" $.Name }}
{{ $receiver := receiver $singular }}

// {{ $singular }} holds the query input of the {{ $.Name }} entity,
// please tags with `path:",inline"` if embedding.
type {{ $singular }} struct {
    inputConfig `path:"-" query:"-" json:"-"`

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        // {{ $en }} indicates to query {{ $.Name }} entity {{ if $e.Optional }}CAN{{ else }}MUST{{ end }} under the {{ $en }} route.
        {{ $en }} *{{ $e.Type.Name }}QueryInput `path:",inline" query:"-" json:"{{ camel $en }}{{ if $e.Optional }},omitempty{{ end }}"`
    {{- end }}

    // Refer holds the route path reference of the {{ $.Name }} entity.
    Refer *object.Refer `path:"{{ lower $.Name }},default=" query:"-" json:"-"`
    // ID of the {{ $.Name }} entity{{ if ne (len $input.IndexFields) 0 }}, tries to retrieve the entity with the following unique index parts if no ID provided{{ end }}.
    ID {{ $.ID.Type }} `path:"-" query:"-" json:"id{{ if ne (len $input.IndexFields) 0 }},omitempty{{ end }}"`
    {{- range $f := $input.IndexFields }}
        {{- $fn := $f.StructField }}
        // {{ $fn }} of the {{ $.Name }} entity, a part of the unique index.
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `path:"-" query:"-" json:"{{ camel $fn }},omitempty"`
    {{- end }}
}

// Model returns the {{ $.Name }} entity for querying,
// after validating.
func ({{ $receiver }} *{{ $singular }}) Model() *{{ $.Name }} {
    if {{ $receiver }} == nil {
        return nil
    }

    return &{{ $.Name }}{
        ID: {{ $receiver }}.ID,
        {{- range $f := $input.IndexFields }}
            {{- $fn := $f.StructField }}
            {{ $fn }}: {{ $receiver }}.{{ $fn }},
        {{- end }}
    }
}

// Validate checks the {{ $singular }} entity.
func ({{ $receiver }} *{{ $singular }}) Validate() error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    return {{ $receiver }}.ValidateWith({{ $receiver }}.inputConfig.Context, {{ $receiver }}.inputConfig.Client, nil)
}

// ValidateWith checks the {{ $singular }} entity with the given context and client set.
func ({{ $receiver }} *{{ $singular }}) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    {{ $util := lower $.Name -}}

    if {{ $receiver }}.Refer != nil && *{{ $receiver }}.Refer == "" {
        return fmt.Errorf("model: %s : %w", {{ $util }}.Label, ErrBlankResourceRefer)
    }

    if cache == nil {
        cache = map[string]any{}
    }

    q := cs.{{ plural $.Name }}().Query()

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        {{- $f := $e.Field }}
        // Validate when querying under the {{ $en }} route.
        if {{ $receiver }}.{{ $en }} != nil {
            {{- $optional := $e.Optional }}
            {{- if $e.Through }}
                {{- range $te := $e.Through.Edges }} {{ if eq $e.Type $te.Type }} {{ $optional = $te.Optional }} {{ end }} {{ end }}
            {{- end }}
            if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                {{- if $optional }}
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                        {{- if $f }}
                            q.Where(
                                {{ $util }}.{{ $f.StructField }}IsNil())
                        {{- else }}
                            q.Where(
                                predicate.{{ $.Name }}(sql.FieldIsNull({{ $util }}.{{ $en }}Column)))
                        {{- end }}
                    }
                {{- else }}
                    return err
                {{- end }}
            } else {
                {{- $ants := extractAnnotation $e }}{{ if $ants.ValidateContextFuncs }}ctx = valueContext(ctx, {{ join $ants.ValidateContextFuncs ", " }}){{ end }}
                {{- if and $f (not $e.M2M) }}
                    q.Where(
                        {{ $util }}.{{ $f.StructField }}({{ $receiver }}.{{ $en }}.ID))
                {{- else if and (not $f) (not $e.M2M) }}
                    q.Where(
                        predicate.{{ $.Name }}(sql.FieldEQ({{ $util }}.{{ $en }}Column, {{ $receiver }}.{{ $en }}.ID)))
                {{- else }}
                    q.Where(
                        {{ $util }}.Has{{ pascal $e.Name }}With({{ if $e.Through }}{{ lower $e.Through.Name }}.{{ $e.Type.Name }}ID{{ else }}{{ lower $e.Owner.Name }}.ID{{ end }}({{ $receiver }}.{{ $en }}.ID)))
                {{- end }}
            }
        {{- if $optional }}
        } else {
            {{- if $f }}
                q.Where(
                    {{ $util }}.{{ $f.StructField }}IsNil())
            {{- else }}
                q.Where(
                    predicate.{{ $.Name }}(sql.FieldIsNull({{ $util }}.{{ $en }}Column)))
            {{- end }}
        {{- end }}
        }
    {{ end }}

    if {{ $receiver }}.Refer != nil {
    {{- if or $.ID.IsInt $.ID.IsInt64 }}
        if {{ $receiver }}.Refer.IsNumeric() {
            q.Where(
                {{ $util }}.ID({{ $receiver }}.Refer.{{ if $.ID.IsInt }}Int(){{ else }}Int64(){{ end }}))
    {{- else if eq $.ID.Type.Ident "object.ID" }}
        if {{ $receiver }}.Refer.IsID() {
            q.Where(
                {{ $util }}.ID({{ $receiver }}.Refer.ID()))
    {{- else if $.ID.IsString }}
        if {{ $receiver }}.Refer.IsString() {
            q.Where(
                {{ $util }}.ID({{ $receiver }}.Refer.String()))
    {{- else }}
        if {{ $receiver }}.Refer.IsID() {
            q.Where(
                {{ $util }}.ID({{ $receiver }}.Refer.ID()))
    {{- end }}
        {{- if gt (len $input.IndexFields) 0 }}
        } else if refers := {{ $receiver }}.Refer.Split({{ len $input.IndexFields }}); len(refers) == {{ len $input.IndexFields }} {
            q.Where(
                {{- range $idx, $f := $input.IndexFields }}
                    {{- $fn := $f.StructField }}
                    {{ $util }}.{{ $fn }}(refers[{{ $idx }}].
                    {{- if or $f.IsInt $f.IsInt64 -}}
                        {{ if $f.IsInt }}Int()),{{ else }} Int64()),{{ end }}
                    {{- else if $f.IsBool -}}
                        Bool()),
                    {{- else if $f.IsBytes -}}
                        Bytes()),
                    {{- else -}}
                        String()),
                    {{- end }}
                {{- end -}}
            )
        {{- end }}
        } else {
            return errors.New("invalid identify refer of {{ lower $.Name }}")
        }
    {{- if and $.ID.Type (ge $.ID.Type.Type 9) }}
    } else if {{ $receiver }}.ID != 0 {
    {{- else }}
    } else if {{ $receiver }}.ID != "" {
    {{- end }}
        q.Where(
            {{ $util }}.ID({{ $receiver }}.ID))
    {{- if gt (len $input.IndexFields) 0 }}
    } else if
    {{- $idx := 0 -}}
    {{- range $idx, $f := $input.IndexFields -}}
        {{- $fn := $f.StructField -}}
        {{- if gt $idx 0 -}} && {{- end -}}
        {{- if $f.NillableValue -}}
            ({{ $receiver }}.{{ $fn }} != nil)
        {{- else if and $f.Type (ge $f.Type.Type 9) -}} {{- /* Numeric */}}
            ({{ $receiver }}.{{ $fn }} != 0)
        {{- else if or $f.IsString $f.IsEnum -}}
            ({{ $receiver }}.{{ $fn }} != "")
        {{- else if and $f.Type $f.Type.RType (ge $f.Type.RType.Kind 21) (le $f.Type.RType.Kind 23) -}} {{- /* Map, Pointer, Slice */}}
            ({{ $receiver }}.{{ $fn }} != nil)
        {{- end -}}
    {{- end -}}
    {
        q.Where(
            {{- range $f := $input.IndexFields -}}
                {{- $fn := $f.StructField }}
                {{ $util }}.{{ $fn }}({{ $receiver }}.{{ $fn }}),
            {{- end -}}
        )
    {{- end }}
    } else {
        return errors.New("invalid identify of {{ lower $.Name }}")
    }

    {{ $ants := extractAnnotation $ }}{{ if $ants.ValidateContextFuncs }}ctx = valueContext(ctx, {{ join $ants.ValidateContextFuncs ", " }}){{ end }}

    q.Select(
        {{ $util }}.FieldID,
        {{- range $idx, $f := $input.IndexFields }}
            {{- $fn := $f.StructField }}
            {{ $util }}.Field{{ $fn }},
        {{- end }}
    )

    var e *{{ $.Name }}
    {
        // Get cache from previous validation.
        queryStmt, queryArgs := q.sqlQuery(setContextOp(ctx, q.ctx, "cache")).Query()
        ck := fmt.Sprintf("stmt=%v, args=%v", queryStmt, queryArgs)
        if cv, existed := cache[ck]; !existed {
            var err error
            e, err = q.Only(ctx)
            if err != nil {
                return err
            }

            // Set cache for other validation.
            cache[ck] = e
        } else {
            e = cv.(*{{ $.Name }})
        }
    }

    {{ $receiver }}.ID = e.ID
    {{- range $idx, $f := $input.IndexFields }}
        {{- $fn := $f.StructField }}
        {{ $receiver }}.{{ $fn }} = e.{{ $fn }}
    {{- end }}
    return nil
}

{{ $plural := plural $singular }}
{{ $receiver = receiver $plural }}

// {{ $plural }} holds the query input of the {{ $.Name }} entities,
// please tags with `path:",inline" query:",inline"` if embedding.
type {{ $plural }} struct {
    inputConfig `path:"-" query:"-" json:"-"`

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        // {{ $en }} indicates to query {{ $.Name }} entity {{ if $e.Optional }}CAN{{ else }}MUST{{ end }} under the {{ $en }} route.
        {{ $en }} *{{ $e.Type.Name }}QueryInput `path:",inline" query:"-" json:"-"`
    {{- end }}

    {{ range $f := $input.Fields }}
        {{- $fn := $f.StructField }}
        {{- template "comment" $f }}
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `path:"-" query:"{{ camel $fn }},omitempty" json:"-"`
    {{- end }}
}

// Validate checks the {{ $plural }} entity.
func ({{ $receiver }} *{{ $plural }}) Validate() error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    return {{ $receiver }}.ValidateWith({{ $receiver }}.inputConfig.Context, {{ $receiver }}.inputConfig.Client, nil)
}

// ValidateWith checks the {{ $plural }} entity with the given context and client set.
func ({{ $receiver }} *{{ $plural }}) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    if cache == nil {
        cache = map[string]any{}
    }

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        // Validate when querying under the {{ $en }} route.
        if {{ $receiver }}.{{ $en }} != nil {
            {{- $optional := $e.Optional }}
            {{- if $e.Through }}
                {{- range $te := $e.Through.Edges }} {{ if eq $e.Type $te.Type }} {{ $optional = $te.Optional }} {{ end }} {{ end }}
            {{- end }}
            if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                {{- if $optional }}
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                    }
                {{- else }}
                    return err
                {{- end }}
            }
        }
    {{ end }}
    return nil
}

{{ end }}



{{- /* UpdateInput */}}
{{ define "input/update" }}

{{ $input := getInput $ "Update" }}

{{ $singular := printf "%sUpdateInput" $.Name }}
{{ $receiver := receiver $singular }}

// {{ $singular }} holds the modification input of the {{ $.Name }} entity,
// please tags with `path:",inline" json:",inline"` if embedding.
type {{ $singular }} struct {
    {{ printf "%sQueryInput" $.Name }} `path:",inline" query:"-" json:"-"`

    {{ range $f := $input.Fields }}
        {{- $fn := $f.StructField }}
        {{- template "comment" $f }}
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `path:"-" query:"-" json:"{{ camel $fn }},omitempty"`
    {{- end }}

    {{ range $e := $input.AdditionalEdges }}
        {{- $en := $e.StructField }}
        // {{ $en }} indicates replacing the stale {{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }} {{ if not $e.Unique }}entities{{ else }}entity{{ end }}.
        {{ $en }} {{ if not $e.Unique }}[]{{ end }}*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}{{ if or $e.M2M $e.O2M }}CreateInput{{ else }}QueryInput{{ end }} `uri:"-" query:"-" {{ getStructTag $e "json" "Update" }}`
    {{- end }}
}

// Model returns the {{ $.Name }} entity for modifying,
// after validating.
func ({{ $receiver }} *{{ $singular }}) Model() *{{ $.Name }} {
    if {{ $receiver }} == nil {
        return nil
    }

    {{ $modelReceiver := printf "_%s" $.Receiver -}}

    {{ $modelReceiver }} := &{{ $.Name }}{
        ID: {{ $receiver }}.ID,
        {{- range $f := $input.IndexFields }}
            {{- $fn := $f.StructField }}
            {{ $fn }}: {{ $receiver }}.{{ $fn }},
        {{- end }}
        {{- range $f := $input.FieldsWithoutIndexing }}
            {{- $fn := $f.StructField }}
            {{ $fn }}: {{ $receiver }}.{{ $fn }},
        {{- end }}
    }

    {{ range $f := $input.PrerequisiteFields }}
        {{- $fn := $f.StructField }}
        {{- $e := $f.Edge }}
        {{- $en := pascal (singular $e.Name) }}
        if {{ $receiver }}.{{ $en }} != nil {
            {{ $modelReceiver }}.{{ $fn }} = {{ $receiver }}.{{ $en }}.ID
        }
    {{- end }}

    {{ range $e := $input.AdditionalEdges }}
        {{- $en := $e.StructField }}
        {{- if not $e.Unique }}
            if {{ $receiver }}.{{ $en }} != nil {
                // Empty slice is used for clearing the edge.
                {{ $modelReceiver }}.Edges.{{ $en }} = make([]*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}, 0 , len({{ $receiver }}.{{ $en }}))
            }
            for j := range {{ $receiver }}.{{ $en }} {
                if {{ $receiver }}.{{ $en }}[j] == nil {
                    continue
                }
                {{ $modelReceiver }}.Edges.{{ $en }} = append({{ $modelReceiver }}.Edges.{{ $en }},
                    {{ $receiver }}.{{ $en }}[j].Model())
            }
        {{- else }}
            {{- $ef := $e.Field }}
            if {{ $receiver }}.{{ $en }} != nil {
            {{- if $ef }}
                {{ $modelReceiver }}.{{ $ef.StructField }} = {{ if $ef.NillableValue }}&{{ end }}{{ $receiver }}.{{ $en }}.ID
            {{- else }}
                {{ $modelReceiver }}.Edges.{{ $en }} = {{ $receiver }}.{{ $en }}.Model()
            {{- end }}
            }
        {{- end }}
    {{- end }}
    return {{ $modelReceiver }}
}

// Validate checks the {{ $singular }} entity.
func ({{ $receiver }} *{{ $singular }}) Validate() error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    return {{ $receiver }}.ValidateWith({{ $receiver }}.inputConfig.Context, {{ $receiver }}.inputConfig.Client, nil)
}

// ValidateWith checks the {{ $singular }} entity with the given context and client set.
func ({{ $receiver }} *{{ $singular }}) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if cache == nil {
        cache = map[string]any{}
    }

    if err := {{ $receiver }}.{{ printf "%sQueryInput" $.Name }}.ValidateWith(ctx, cs, cache); err != nil {
        return err
    }

    {{ range $e := $input.AdditionalEdges }}
        {{ $en := $e.StructField }}
        {{- if not $e.Unique }}
            for i := range {{ $receiver }}.{{ $en }} {
                if {{ $receiver }}.{{ $en }}[i] == nil {
                    continue
                }

                if err := {{ $receiver }}.{{ $en }}[i].ValidateWith(ctx, cs, cache); err != nil {
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }}[i] = nil
                    }
                }
            }
        {{- else }}
            if {{ $receiver }}.{{ $en }} != nil {
                if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                    }
                }
            }
        {{- end }}
    {{- end }}


    return nil
}

{{ $plural := plural $singular }}
{{ $receiver = receiver $plural }}

// {{ $plural }} holds the modification input item of the {{ $.Name }} entities.
type {{ $plural }}Item struct {
    // ID of the {{ $.Name }} entity{{ if ne (len $input.IndexFields) 0 }}, tries to retrieve the entity with the following unique index parts if no ID provided{{ end }}.
    ID {{ $.ID.Type }} `path:"-" query:"-" json:"id{{ if ne (len $input.IndexFields) 0 }},omitempty{{ end }}"`
    {{- range $f := $input.IndexFields }}
        {{- $fn := $f.StructField }}
        // {{ $fn }} of the {{ $.Name }} entity, a part of the unique index.
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `path:"-" query:"-" json:"{{ camel $fn }},omitempty"`
    {{- end }}

    {{ range $f := $input.FieldsWithoutIndexing }}
        {{- $fn := $f.StructField }}
        {{- template "comment" $f }}
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `path:"-" query:"-" {{ getStructTag $f "json" "Update" }}`
    {{- end }}

    {{ range $e := $input.AdditionalEdges }}
        {{- $en := $e.StructField }}
        // {{ $en }} indicates replacing the stale {{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }} {{ if not $e.Unique }}entities{{ else }}entity{{ end }}.
        {{ $en }} {{ if not $e.Unique }}[]{{ end }}*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}{{ if or $e.M2M $e.O2M }}CreateInput{{ else }}QueryInput{{ end }} `uri:"-" query:"-" {{ getStructTag $e "json" "Update" }}`
    {{- end }}
}

// ValidateWith checks the {{ $plural }}Item entity with the given context and client set.
func ({{ $receiver }} *{{ $plural }}Item) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    if cache == nil {
        cache = map[string]any{}
    }

    {{ range $e := $input.AdditionalEdges }}
        {{ $en := $e.StructField }}
        {{- if not $e.Unique }}
            for i := range {{ $receiver }}.{{ $en }} {
                if {{ $receiver }}.{{ $en }}[i] == nil {
                    continue
                }

                if err := {{ $receiver }}.{{ $en }}[i].ValidateWith(ctx, cs, cache); err != nil {
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }}[i] = nil
                    }
                }
            }
        {{- else }}
            if {{ $receiver }}.{{ $en }} != nil {
                if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                    }
                }
            }
        {{- end }}
    {{- end }}

    return nil
}

// {{ $plural }} holds the modification input of the {{ $.Name }} entities,
// please tags with `path:",inline" json:",inline"` if embedding.
type {{ $plural }} struct {
    inputConfig `path:"-" query:"-" json:"-"`

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        // {{ $en }} indicates to update {{ $.Name }} entity {{ if $e.Optional }}CAN{{ else }}MUST{{ end }} under the {{ $en }} route.
        {{ $en }} *{{ $e.Type.Name }}QueryInput `path:",inline" query:"-" json:"-"`
    {{- end }}

    // Items holds the entities to create, which MUST not be empty.
    Items []*{{ $plural }}Item `path:"-" query:"-" json:"items"`
}

// Model returns the {{ $.Name }} entities for modifying,
// after validating.
func ({{ $receiver }} *{{ $plural }}) Model() []*{{ $.Name }} {
    if {{ $receiver }} == nil || len({{ $receiver }}.Items) == 0 {
        return nil
    }

    {{ $modelsReceiver := printf "%ss" $modelReceiver }}

    {{ $modelsReceiver }} := make([]*{{ $.Name }}, len({{ $receiver }}.Items))

    for i := range {{ $receiver }}.Items {
        {{ $modelReceiver }} := &{{ $.Name }}{
            ID: {{ $receiver }}.Items[i].ID,
            {{- range $f := $input.IndexFields }}
                {{- $fn := $f.StructField }}
                {{ $fn }}: {{ $receiver }}.Items[i].{{ $fn }},
            {{- end }}
            {{- range $f := $input.FieldsWithoutIndexing }}
                {{- $fn := $f.StructField }}
                {{ $fn }}: {{ $receiver }}.Items[i].{{ $fn }},
            {{- end }}
        }

        {{ range $f := $input.PrerequisiteFields }}
            {{- $fn := $f.StructField }}
            {{- $e := $f.Edge }}
            {{- $en := pascal (singular $e.Name) }}
            if {{ $receiver }}.{{ $en }} != nil {
                {{ $modelReceiver }}.{{ $fn }} = {{ $receiver }}.{{ $en }}.ID
            }
        {{- end }}

        {{ range $e := $input.AdditionalEdges }}
            {{- $en := $e.StructField }}
            {{- if not $e.Unique }}
                if {{ $receiver }}.Items[i].{{ $en }} != nil {
                    // Empty slice is used for clearing the edge.
                    {{ $modelReceiver }}.Edges.{{ $en }} = make([]*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}, 0 , len({{ $receiver }}.Items[i].{{ $en }}))
                }
                for j := range {{ $receiver }}.Items[i].{{ $en }} {
                    if {{ $receiver }}.Items[i].{{ $en }}[j] == nil {
                        continue
                    }
                    {{ $modelReceiver }}.Edges.{{ $en }} = append({{ $modelReceiver }}.Edges.{{ $en }},
                        {{ $receiver }}.Items[i].{{ $en }}[j].Model())
                }
            {{- else }}
                {{- $ef := $e.Field }}
                if {{ $receiver }}.Items[i].{{ $en }} != nil {
                {{- if $ef }}
                    {{ $modelReceiver }}.{{ $ef.StructField }} = {{ if $ef.NillableValue }}&{{ end }}{{ $receiver }}.Items[i].{{ $en }}.ID
                {{- else }}
                    {{ $modelReceiver }}.Edges.{{ $en }} = {{ $receiver }}.Items[i].{{ $en }}.Model()
                {{- end }}
                }
            {{- end }}
        {{- end }}

        {{ $modelsReceiver }}[i] = {{ $modelReceiver }}
    }

    return {{ $modelsReceiver }}
}

// IDs returns the ID list of the {{ $.Name }} entities for modifying,
// after validating.
func ({{ $receiver }} *{{ $plural }}) IDs() []{{ $.ID.Type }} {
    if {{ $receiver }} == nil || len({{ $receiver }}.Items) == 0 {
        return nil
    }

    ids := make([]{{ $.ID.Type }}, len({{ $receiver }}.Items))
    for i := range {{ $receiver }}.Items {
        ids[i] = {{ $receiver }}.Items[i].ID
    }
    return ids
}

// Validate checks the {{ $plural }} entity.
func ({{ $receiver }} *{{ $plural }}) Validate() error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    return {{ $receiver }}.ValidateWith({{ $receiver }}.inputConfig.Context, {{ $receiver }}.inputConfig.Client, nil)
}

// ValidateWith checks the {{ $plural }} entity with the given context and client set.
func ({{ $receiver }} *{{ $plural }}) ValidateWith(ctx context.Context, cs ClientSet, cache map[string]any) error {
    if {{ $receiver }} == nil {
        return errors.New("nil receiver")
    }

    if len({{ $receiver }}.Items) == 0 {
        return errors.New("empty items")
    }

    if cache == nil {
        cache = map[string]any{}
    }

    {{ $util := lower $.Name -}}

    q := cs.{{ plural $.Name }}().Query()

    {{ range $e := $input.PrerequisiteEdges }}
        {{- $en := pascal (singular $e.Name) }}
        {{- $f := $e.Field }}
        // Validate when updating under the {{ $en }} route.
        if {{ $receiver }}.{{ $en }} != nil {
            {{- $optional := $e.Optional }}
            {{- if $e.Through }}
                {{- range $te := $e.Through.Edges }} {{ if eq $e.Type $te.Type }} {{ $optional = $te.Optional }} {{ end }} {{ end }}
            {{- end }}
            if err := {{ $receiver }}.{{ $en }}.ValidateWith(ctx, cs, cache); err != nil {
                {{- if $optional }}
                    if !IsBlankResourceReferError(err) {
                        return err
                    } else {
                        {{ $receiver }}.{{ $en }} = nil
                        {{- if $f }}
                            q.Where(
                                {{ $util }}.{{ $f.StructField }}IsNil())
                        {{- else }}
                            q.Where(
                                predicate.{{ $.Name }}(sql.FieldIsNull({{ $util }}.{{ $en }}Column)))
                        {{- end }}
                    }
                {{- else }}
                    return err
                {{- end }}
            } else {
                {{- $ants := extractAnnotation $e }}{{ if $ants.ValidateContextFuncs }}ctx = valueContext(ctx, {{ join $ants.ValidateContextFuncs ", " }}){{ end }}
                {{- if and $f (not $e.M2M) }}
                    q.Where(
                        {{ $util }}.{{ $f.StructField }}({{ $receiver }}.{{ $en }}.ID))
                {{- else if and (not $f) (not $e.M2M) }}
                    q.Where(
                        predicate.{{ $.Name }}(sql.FieldEQ({{ $util }}.{{ $en }}Column, {{ $receiver }}.{{ $en }}.ID)))
                {{- else }}
                    q.Where(
                        {{ $util }}.Has{{ pascal $e.Name }}With({{ if $e.Through }}{{ lower $e.Through.Name }}.{{ $e.Type.Name }}ID{{ else }}{{ lower $e.Owner.Name }}.ID{{ end }}({{ $receiver }}.{{ $en }}.ID)))
                {{- end }}
            }
        {{- if $optional }}
        } else {
            {{- if $f }}
                q.Where(
                    {{ $util }}.{{ $f.StructField }}IsNil())
            {{- else }}
                q.Where(
                    predicate.{{ $.Name }}(sql.FieldIsNull({{ $util }}.{{ $en }}Column)))
            {{- end }}
        {{- end }}
        }
    {{ end }}

    ids := make([]{{ $.ID.Type }}, 0, len({{ $receiver }}.Items))

    {{- if gt (len $input.IndexFields) 0 }}
    ors := make([]predicate.{{ $.Name }}, 0, len({{ $receiver }}.Items))
    indexers := make(map[any][]int)
    {{- end }}

    for i := range {{ $receiver }}.Items {
        if {{ $receiver }}.Items[i] == nil {
            return errors.New("nil item")
        }

        {{ if and $.ID.Type (ge $.ID.Type.Type 9) }}
        if {{ $receiver }}.Items[i].ID != 0 {
        {{- else }}
        if {{ $receiver }}.Items[i].ID != "" {
        {{- end }}
            ids = append(ids, {{ $receiver }}.Items[i].ID)
        {{- if gt (len $input.IndexFields) 0 }}
            ors = append(ors, {{ $util }}.ID({{ $receiver }}.Items[i].ID))
            indexers[{{ $receiver }}.Items[i].ID] = append(indexers[{{ $receiver }}.Items[i].ID], i)
        } else if
        {{- $idx := 0 -}}
        {{- range $idx, $f := $input.IndexFields -}}
            {{- $fn := $f.StructField -}}
            {{- if gt $idx 0 -}} && {{- end -}}
            {{- if $f.NillableValue -}}
                ({{ $receiver }}.Items[i].{{ $fn }} != nil)
            {{- else if and $f.Type (ge $f.Type.Type 9) -}} {{- /* Numeric */}}
                ({{ $receiver }}.Items[i].{{ $fn }} != 0)
            {{- else if or $f.IsString $f.IsEnum -}}
                ({{ $receiver }}.Items[i].{{ $fn }} != "")
            {{- else if and $f.Type $f.Type.RType (ge $f.Type.RType.Kind 21) (le $f.Type.RType.Kind 23) -}} {{- /* Map, Pointer, Slice */}}
                ({{ $receiver }}.Items[i].{{ $fn }} != nil)
            {{- end -}}
        {{- end -}}
        {
            ors = append(ors, {{ $util }}.And(
                    {{- range $f := $input.IndexFields -}}
                        {{- $fn := $f.StructField }}
                        {{ $util }}.{{ $fn }}({{ $receiver }}.Items[i].{{ $fn }}),
                    {{- end -}}
                ))
            indexerKey := fmt.Sprint({{ range $f := $input.IndexFields }}"/",{{ $receiver }}.Items[i].{{ $f.StructField }},{{ end }})
            indexers[indexerKey] = append(indexers[indexerKey], i)
        {{- end }}
        } else {
            return errors.New("found item hasn't identify")
        }
    }

    {{ $ants := extractAnnotation $ }}{{ if $ants.ValidateContextFuncs }}ctx = valueContext(ctx, {{ join $ants.ValidateContextFuncs ", " }}){{ end }}

    {{ if gt (len $input.IndexFields) 0 }}
    p := {{ $util }}.IDIn(ids...)
    if len(ids) != cap(ids) {
        p = {{ $util }}.Or(ors...)
    }

    es, err := q.
        Where(p).
        Select(
            {{ $util }}.FieldID,
            {{- range $idx, $f := $input.IndexFields }}
                {{- $fn := $f.StructField }}
                {{ $util }}.Field{{ $fn }},
            {{- end }}
        ).
        All(ctx)
    if err != nil {
        return err
    }

    if len(es) != cap(ids) {
        return errors.New("found unrecognized item")
    }

    for i := range es {
        indexer := indexers[es[i].ID]
        if indexer == nil {
            indexerKey := fmt.Sprint({{ range $f := $input.IndexFields }}"/",{{ $receiver }}.Items[i].{{ $f.StructField }},{{ end }})
            indexer = indexers[indexerKey]
        }
        for _, j := range indexer {
            {{ $receiver }}.Items[j].ID = es[i].ID
            {{- range $idx, $f := $input.IndexFields }}
                {{- $fn := $f.StructField }}
                {{ $receiver }}.Items[j].{{ $fn }} = es[i].{{ $fn }}
            {{- end }}
        }
    }
    {{- else }}
    if len(ids) != cap(ids) {
        return errors.New("found unrecognized item")
    }

    idsCnt, err := q.Where({{ $util }}.IDIn(ids...)).
        Count(ctx)
    if err != nil {
        return err
    }

    if idsCnt != cap(ids) {
        return errors.New("found unrecognized item")
    }
    {{- end }}

    for i := range {{ $receiver }}.Items {
        if err := {{ $receiver }}.Items[i].ValidateWith(ctx, cs, cache); err != nil {
            return err
        }
    }

    return nil
}

{{ end }}



{{- /* Output */}}
{{ define "output" }}

{{ $output := getOutput $ }}

{{ $singular := printf "%sOutput" $.Name }}
{{ $receiver := receiver $singular }}

// {{ $singular }} holds the output of the {{ $.Name }} entity.
type {{ $singular }} struct {
    ID {{ $.ID.Type }} `json:"id,omitempty"`
    {{- range $f := $output.Fields }}
        {{- $fn := $f.StructField }}
        {{ $fn }} {{ if $f.NillableValue }}*{{ end }}{{ $f.Type }} `{{ getStructTag $f "json" "Output" }}`
    {{- end }}

    {{ range $e := $output.Edges }}
        {{- $en := pascal $e.Name }}
        {{ $en }} {{ if not $e.Unique }}[]{{ end }}*{{ if $e.Through }}{{ $e.Through.Name }}{{ else }}{{ $e.Type.Name }}{{ end }}Output `{{ getStructTag $e "json" "Output" }}`
    {{- end }}
}

{{- $modelReceiver := printf "_%s" $.Receiver  }}

// View returns the output of {{ $.Name }} entity.
func ({{ $modelReceiver }} *{{ $.Name }}) View() *{{ $singular }} {
    return Expose{{ $.Name }}({{ $modelReceiver }})
}

{{- $modelsReceiver := printf "%ss" $modelReceiver }}

// View returns the output of {{ $.Name }} entities.
func ({{ $modelsReceiver }} {{ plural $.Name }}) View() []*{{ $singular }} {
    return Expose{{ plural $.Name }}({{ $modelsReceiver }})
}

// Expose{{ $.Name }} converts the {{ $.Name }} to {{ $singular }}.
func Expose{{ $.Name }}({{ $modelReceiver }} *{{ $.Name }}) *{{ $singular }} {
    if {{ $modelReceiver }} == nil {
        return nil
    }

    {{ $receiver }} := &{{ $singular }}{
        ID: {{ $modelReceiver }}.ID,
        {{- range $f := $output.Fields }}
            {{- $fn := $f.StructField }}
            {{ $fn }}: {{ $modelReceiver }}.{{ $fn }},
        {{- end }}
    }

    {{ range $e := $output.Edges }}
        {{- $en := pascal $e.Name }}
        {{- $etns := pascal $e.Type.Name }}
        {{- $etnp := pascal (plural $e.Type.Name) }}
        {{- if $e.Through }}
            {{- $etns = pascal $e.Through.Name }}
            {{- $etnp = pascal (plural $e.Through.Name) }}
        {{- end }}
        {{- $ef := $e.Field }}
        if {{ $modelReceiver }}.Edges.{{ $en }} != nil {
            {{ $receiver }}.{{ $en }} = Expose{{ if not $e.Unique }}{{ $etnp }}{{ else }}{{ $etns }}{{ end }}({{ $modelReceiver }}.Edges.{{ $en }})
        {{- if $ef }}
        } else if {{ $modelReceiver }}.{{ $ef.StructField }} != {{ if $ef.NillableValue }}nil{{ else if or $ef.IsInt $ef.IsInt64 }}0{{ else }}""{{ end }} {
            {{ $receiver }}.{{ $en }} = &{{ $etns }}Output{
                ID: {{ if $ef.NillableValue }}*{{ end }}{{ $modelReceiver }}.{{ $ef.StructField }},
            }
        {{- end }}
        }
    {{- end }}
    return {{ $receiver }}
}

// Expose{{ plural $.Name }} converts the {{ $.Name }} slice to {{ $singular }} pointer slice.
func Expose{{ plural $.Name }}({{ $modelsReceiver }} []*{{ $.Name }}) []*{{ $singular }} {
    if len({{ $modelsReceiver }}) == 0 {
        return nil
    }

    {{ $receiver }}s := make([]*{{ $singular }}, len({{ $modelsReceiver }}))
    for i := range {{ $modelsReceiver }} {
        {{ $receiver }}s[i] = Expose{{ $.Name }}({{ $modelsReceiver }}[i])
    }
    return {{ $receiver }}s
}

{{ end }}
