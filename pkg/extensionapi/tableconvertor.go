package extensionapi

import (
	"context"
	"fmt"
	"net/http"
	"slices"

	apiext "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	apiexttableconvertor "k8s.io/apiextensions-apiserver/pkg/registry/customresource/tableconvertor"
	kerrors "k8s.io/apimachinery/pkg/api/errors"
	kmeta "k8s.io/apimachinery/pkg/api/meta"
	metatable "k8s.io/apimachinery/pkg/api/meta/table"
	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apiserver/pkg/registry/rest"
)

var swaggerMetadataDescriptions = meta.ObjectMeta{}.SwaggerDoc()

type (
	// JSONPathTableColumnDefinition is a definition of a column in a table that is populated.
	//
	// Must provide a JSONPath to extract the value from the custom resource.
	JSONPathTableColumnDefinition struct {
		meta.TableColumnDefinition

		// JSONPath is a simple JSON path (i.e. with array notation) which is evaluated against
		// each custom resource to produce the value for this column.
		JSONPath string
	}
	_JSONPathTableColumnInternalDefinition = apiext.CustomResourceColumnDefinition
)

// NewJSONPathTableConvertor creates a new table convertor that uses JSONPath to extract values from custom resources.
//
// It relies on apiexttableconvertor.New to create the table convertor.
func NewJSONPathTableConvertor(definitions ...JSONPathTableColumnDefinition) (rest.TableConvertor, error) {
	defs := make([]_JSONPathTableColumnInternalDefinition, 0, len(definitions)+1)

	agePriority := int32(0)
	for i := range definitions {
		switch {
		case definitions[i].Name == "":
			return nil, fmt.Errorf("column definition must have a non-empty name")
		case definitions[i].JSONPath == "":
			return nil, fmt.Errorf("column definition %q must have a non-empty JSONPath", definitions[i].Name)
		case definitions[i].Priority < 0:
			return nil, fmt.Errorf("column definition %q must have a non-negative priority", definitions[i].Name)
		}

		desc := definitions[i].Description
		if desc == "" {
			// NB(thxCode): Avoid the default description generated by apiexttableconvertor.New.
			desc = "Description to " + definitions[i].Name
		}

		defs = append(defs, _JSONPathTableColumnInternalDefinition{
			Name:        definitions[i].Name,
			Description: desc,
			Type:        definitions[i].Type,
			Format:      definitions[i].Format,
			JSONPath:    definitions[i].JSONPath,
			Priority:    definitions[i].Priority,
		})
		if definitions[i].Priority > agePriority {
			agePriority = definitions[i].Priority
		}
	}

	defs = append(defs, _JSONPathTableColumnInternalDefinition{
		Name:        "Age",
		Description: swaggerMetadataDescriptions["creationTimestamp"],
		Type:        "date",
		JSONPath:    ".metadata.creationTimestamp",
		Priority:    agePriority + 1,
	})

	defs = slices.CompactFunc(defs, func(a, b _JSONPathTableColumnInternalDefinition) bool {
		return a.Name == b.Name
	})

	return apiexttableconvertor.New(defs)
}

type _DefaultTableColumnDefinition struct{}

// NewDefaultTableConvertor creates a default convertor.
//
// It borrows from k8s.io/apiserver/pkg/registry/rest.NewDefaultTableConvertor,
// but modify the latest column name.
func NewDefaultTableConvertor() rest.TableConvertor {
	return _DefaultTableColumnDefinition{}
}

func (c _DefaultTableColumnDefinition) ConvertToTable(ctx context.Context, object, tableOptions runtime.Object) (*meta.Table, error) {
	var table meta.Table
	fn := func(obj runtime.Object) error {
		m, err := kmeta.Accessor(obj)
		if err != nil {
			return &kerrors.StatusError{
				ErrStatus: meta.Status{
					Status:  meta.StatusFailure,
					Code:    http.StatusNotAcceptable,
					Reason:  meta.StatusReasonNotAcceptable,
					Message: fmt.Sprintf("do not support being converted to a Table: %v", err),
				},
			}
		}
		table.Rows = append(table.Rows, meta.TableRow{
			Cells: []any{
				m.GetName(),
				metatable.ConvertToHumanReadableDateType(m.GetCreationTimestamp()),
			},
			Object: runtime.RawExtension{
				Object: obj,
			},
		})
		return nil
	}

	switch {
	case kmeta.IsListType(object):
		if err := kmeta.EachListItem(object, fn); err != nil {
			return nil, err
		}
	default:
		if err := fn(object); err != nil {
			return nil, err
		}
	}

	if m, err := kmeta.ListAccessor(object); err == nil {
		table.ResourceVersion = m.GetResourceVersion()
		table.Continue = m.GetContinue()
		table.RemainingItemCount = m.GetRemainingItemCount()
	} else {
		if m, err := kmeta.CommonAccessor(object); err == nil {
			table.ResourceVersion = m.GetResourceVersion()
		}
	}
	if opt, ok := tableOptions.(*meta.TableOptions); !ok || !opt.NoHeaders {
		table.ColumnDefinitions = []meta.TableColumnDefinition{
			{
				Name:        "Name",
				Description: swaggerMetadataDescriptions["name"],
				Type:        "string",
				Format:      "name",
			},
			{
				Name:        "Age",
				Description: swaggerMetadataDescriptions["creationTimestamp"],
				Type:        "date",
			},
		}
	}

	return &table, nil
}
