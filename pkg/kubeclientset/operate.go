package kubeclientset

import (
	"context"
	"errors"
	"fmt"
	"reflect"

	"github.com/seal-io/utils/json"
	kerrors "k8s.io/apimachinery/pkg/api/errors"
	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/utils/ptr"
	ctrlcli "sigs.k8s.io/controller-runtime/pkg/client"
)

type (
	// MetaObject is the interface for the object with metadata.
	MetaObject = ctrlcli.Object

	// AlignWithFn is a function to compare the actual object with the expected object,
	// and returns aligned object if the actual object is no the same with the expected object.
	AlignWithFn[T MetaObject] func(actualCopied T) (aligned T, skip bool, err error)

	// CompareWithFn is a function to compare the actual object with the expected object,
	// and returns true if the actual object is the same with the expected object.
	CompareWithFn[T MetaObject] func(actualCopied T) (skip bool)
)

type (
	ApplyClient[T MetaObject] interface {
		Create(ctx context.Context, obj T, opts meta.CreateOptions) (T, error)
		Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts meta.PatchOptions, subresources ...string) (T, error)
		Get(ctx context.Context, name string, opts meta.GetOptions) (T, error)
	}

	_ApplyOptions struct {
		meta.ApplyOptions
		StatusOnly bool
	}

	ApplyOption func(*_ApplyOptions)
)

// WithApplyMetaOptions sets the apply options.
func WithApplyMetaOptions(opts meta.ApplyOptions) ApplyOption {
	return func(ao *_ApplyOptions) {
		ao.ApplyOptions = opts
	}
}

// ApplyStatusOnly patches the status if the resource exists.
func ApplyStatusOnly() ApplyOption {
	return func(ao *_ApplyOptions) {
		ao.StatusOnly = true
	}
}

// Apply is similar to the clientset Apply function generated by applyconfiguration-gen,
// but no need to convert the raw object to the applyconfiguration object.
//
// Apply will create the resource if it does not exist,
// otherwise, it will patch the resource.
//
// Apply only patched the status if ApplyStatusOnly provided.
func Apply[T MetaObject](ctx context.Context, cli ApplyClient[T], expected T, opts ...ApplyOption) (T, error) {
	if reflect.ValueOf(expected).IsZero() {
		return expected, errors.New("expected is nil")
	}

	var ao _ApplyOptions
	for i := range opts {
		opts[i](&ao)
	}

	var (
		name   = expected.GetName()
		err    = errors.New("resource name may not be empty")
		actual T
	)

	if name != "" {
		actual, err = cli.Get(ctx, name, meta.GetOptions{
			ResourceVersion: "0",
		})
		if err != nil && !kerrors.IsNotFound(err) {
			return actual, err
		}
	}

	switch {
	case err != nil && ao.StatusOnly:
		// Patching subresource only supports for existing resource.
		return actual, err
	case err != nil || actual.GetDeletionTimestamp() != nil:
		// Create if not found or deleting.
		actual, err = cli.Create(ctx, expected, meta.CreateOptions{
			DryRun: ao.DryRun,
		})
		if err != nil {
			if !kerrors.IsAlreadyExists(err) {
				return actual, err
			}
			// Retry if already existed.
			return Apply(ctx, cli, expected, opts...)
		}
		// Return directly if new created.
		return actual, nil
	}

	data, err := json.Marshal(expected)
	if err != nil {
		return actual, fmt.Errorf("json marshal %q: %w", name, err)
	}

	var subres []string
	if ao.StatusOnly {
		subres = []string{"status"}
	}
	return cli.Patch(ctx, name, types.ApplyPatchType, data, ao.ToPatchOptions(), subres...)
}

// ApplyWithCtrlClient is similar to Apply, but uses the ctrl client.
//
// ApplyWithCtrlClient doesn't support ApplyStatusOnly.
func ApplyWithCtrlClient[T MetaObject](ctx context.Context, cli ctrlcli.Client, expected T, opts ...ApplyOption) (T, error) {
	if reflect.ValueOf(expected).IsZero() {
		return expected, errors.New("expected is nil")
	}

	var ao _ApplyOptions
	for i := range opts {
		opts[i](&ao)
	}

	if ao.StatusOnly {
		return expected, errors.New("status only is not supported by ctrl client")
	}

	var (
		name   = expected.GetName()
		err    = errors.New("resource name may not be empty")
		actual = expected.DeepCopyObject().(T)
	)

	if name != "" {
		err = cli.Get(ctx, ctrlcli.ObjectKeyFromObject(expected), actual)
		if err != nil && !kerrors.IsNotFound(err) {
			return actual, err
		}
	}

	if err != nil || actual.GetDeletionTimestamp() != nil {
		// Create if not found or deleting.
		err = cli.Create(ctx, actual, &ctrlcli.CreateOptions{
			DryRun: ao.DryRun,
		})
		if err != nil {
			if !kerrors.IsAlreadyExists(err) {
				return actual, err
			}
			// Retry if already existed.
			return ApplyWithCtrlClient(ctx, cli, expected, opts...)
		}
		// Return directly if new created.
		return actual, nil
	}

	err = cli.Patch(ctx, expected, ctrlcli.Apply, &ctrlcli.PatchOptions{
		DryRun:       ao.DryRun,
		Force:        ptr.To(ao.Force),
		FieldManager: ao.FieldManager,
		Raw:          ptr.To(ao.ApplyOptions.ToPatchOptions()),
	})
	return expected, err
}

type (
	CreateClient[T MetaObject] interface {
		Create(ctx context.Context, obj T, opts meta.CreateOptions) (T, error)
		Update(ctx context.Context, obj T, opts meta.UpdateOptions) (T, error)
		Get(ctx context.Context, name string, opts meta.GetOptions) (T, error)
		Delete(ctx context.Context, name string, opts meta.DeleteOptions) error
	}

	_CreateOptions[T MetaObject] struct {
		meta.CreateOptions
		UpdateAlignFunc     AlignWithFn[T]
		RecreateCompareFunc CompareWithFn[T]
	}

	CreateOption[T MetaObject] func(*_CreateOptions[T])
)

// WithCreateMetaOptions sets the create options.
func WithCreateMetaOptions[T MetaObject](opts meta.CreateOptions) CreateOption[T] {
	return func(co *_CreateOptions[T]) {
		co.CreateOptions = opts
	}
}

// CreateOrUpdate with the align function to update the resource if existed.
//
// CreateOrUpdate is conflict to CreateOrRecreate, if both provided,
// CreateOrUpdate will be used.
func CreateOrUpdate[T MetaObject](fn AlignWithFn[T]) CreateOption[T] {
	return func(co *_CreateOptions[T]) {
		co.UpdateAlignFunc = fn
	}
}

// CreateOrRecreate with the compare function to recreate the resource if different.
//
// CreateOrRecreate is conflict to CreateOrUpdate, if both provided,
// CreateOrUpdate will be used.
func CreateOrRecreate[T MetaObject](fn CompareWithFn[T]) CreateOption[T] {
	return func(co *_CreateOptions[T]) {
		co.RecreateCompareFunc = fn
	}
}

// Create is similar to Apply, will create the resource if it does not exist.
//
// Create updates the resource if CreateOrUpdate provided,
// or recreate the resource if CreateOrRecreate provided.
// Select one from CreateOrUpdate and CreateOrRecreate, if both provided,
// CreateOrUpdate will be used.
func Create[T MetaObject](ctx context.Context, cli CreateClient[T], expected T, opts ...CreateOption[T]) (T, error) {
	if reflect.ValueOf(expected).IsZero() {
		return expected, errors.New("expected is nil")
	}

	var co _CreateOptions[T]
	for i := range opts {
		opts[i](&co)
	}

	var (
		name   = expected.GetName()
		err    = errors.New("resource name may not be empty")
		actual T
	)

	if name != "" {
		actual, err = cli.Get(ctx, name, meta.GetOptions{
			ResourceVersion: "0",
		})
		if err != nil && !kerrors.IsNotFound(err) {
			return actual, err
		}
	}

	// Create if not found or deleting.
	if err != nil || actual.GetDeletionTimestamp() != nil {
		actual, err = cli.Create(ctx, expected, meta.CreateOptions{
			DryRun: co.DryRun,
		})
		if err != nil {
			if !kerrors.IsAlreadyExists(err) {
				return actual, err
			}
			// Retry if already existed.
			return Create(ctx, cli, expected, opts...)
		}
		// Return directly if new created.
		return actual, nil
	}

	switch {
	case co.UpdateAlignFunc != nil:
		var (
			copied T
			skip   bool
		)
		copied, skip, err = co.UpdateAlignFunc(actual.DeepCopyObject().(T))
		if err != nil {
			return actual, err
		}
		if skip {
			return actual, nil
		}

		// Copy resource version for update.
		//
		// And keep the original labels, annotations, finalizers, and owner references if they are not set.
		// If you want to clean the above fields, please set them to empty in the expected object.
		copiedOm, actualOm := copied, actual
		copiedOm.SetResourceVersion(actualOm.GetResourceVersion())
		if copiedOm.GetLabels() == nil {
			copiedOm.SetLabels(actualOm.GetLabels())
		}
		if copiedOm.GetAnnotations() == nil {
			copiedOm.SetAnnotations(actualOm.GetAnnotations())
		}
		if copiedOm.GetFinalizers() == nil {
			copiedOm.SetFinalizers(actualOm.GetFinalizers())
		}
		if copiedOm.GetOwnerReferences() == nil {
			copiedOm.SetOwnerReferences(actualOm.GetOwnerReferences())
		}

		updated, err := cli.Update(ctx, copied, meta.UpdateOptions{
			DryRun: co.DryRun,
		})
		if err == nil || !kerrors.IsConflict(err) || !kerrors.IsNotAcceptable(err) {
			return updated, err
		}

		// Retry if conflicted.
		return Create(ctx, cli, expected, opts...)
	case co.RecreateCompareFunc != nil:
		skip := co.RecreateCompareFunc(actual.DeepCopyObject().(T))
		if skip {
			return actual, nil
		}

		err = cli.Delete(ctx, name, meta.DeleteOptions{
			DryRun:            co.DryRun,
			PropagationPolicy: ptr.To(meta.DeletePropagationForeground),
		})
		if err != nil && !kerrors.IsNotFound(err) {
			return actual, err
		}

		// Recreate.
		return Create(ctx, cli, expected, opts...)
	}

	return actual, nil
}

// CreateWithCtrlClient is similar to Create, but uses the ctrl client.
func CreateWithCtrlClient[T MetaObject](ctx context.Context, cli ctrlcli.Client, expected T, opts ...CreateOption[T]) (T, error) {
	if reflect.ValueOf(expected).IsZero() {
		return expected, errors.New("expected is nil")
	}

	var co _CreateOptions[T]
	for i := range opts {
		opts[i](&co)
	}

	var (
		name   = expected.GetName()
		err    = errors.New("resource name may not be empty")
		actual = expected.DeepCopyObject().(T)
	)

	if name != "" {
		err = cli.Get(ctx, ctrlcli.ObjectKeyFromObject(expected), actual)
		if err != nil && !kerrors.IsNotFound(err) {
			return actual, err
		}
	}

	// Create if not found or deleting.
	if err != nil || actual.GetDeletionTimestamp() != nil {
		err = cli.Create(ctx, expected, &ctrlcli.CreateOptions{
			DryRun:       co.DryRun,
			FieldManager: co.FieldManager,
			Raw:          ptr.To(co.CreateOptions),
		})
		if err != nil {
			if !kerrors.IsAlreadyExists(err) {
				return actual, err
			}
			// Retry if already existed.
			return CreateWithCtrlClient(ctx, cli, expected, opts...)
		}
		// Return directly if new created.
		return actual, nil
	}

	switch {
	case co.UpdateAlignFunc != nil:
		var (
			copied T
			skip   bool
		)
		copied, skip, err = co.UpdateAlignFunc(actual.DeepCopyObject().(T))
		if err != nil {
			return actual, err
		}
		if skip {
			return actual, nil
		}

		// Copy resource version for update.
		//
		// And keep the original labels, annotations, finalizers, and owner references if they are not set.
		// If you want to clean the above fields, please set them to empty in the expected object.
		copiedOm, actualOm := copied, actual
		copiedOm.SetResourceVersion(actualOm.GetResourceVersion())
		if copiedOm.GetLabels() == nil {
			copiedOm.SetLabels(actualOm.GetLabels())
		}
		if copiedOm.GetAnnotations() == nil {
			copiedOm.SetAnnotations(actualOm.GetAnnotations())
		}
		if copiedOm.GetFinalizers() == nil {
			copiedOm.SetFinalizers(actualOm.GetFinalizers())
		}
		if copiedOm.GetOwnerReferences() == nil {
			copiedOm.SetOwnerReferences(actualOm.GetOwnerReferences())
		}

		err = cli.Update(ctx, copied, &ctrlcli.UpdateOptions{
			DryRun: co.DryRun,
			Raw:    &meta.UpdateOptions{DryRun: co.DryRun},
		})
		if err == nil || !kerrors.IsConflict(err) || !kerrors.IsNotAcceptable(err) {
			return copied, err
		}

		// Retry if conflicted.
		return CreateWithCtrlClient(ctx, cli, expected, opts...)
	case co.RecreateCompareFunc != nil:
		skip := co.RecreateCompareFunc(actual.DeepCopyObject().(T))
		if skip {
			return actual, nil
		}

		err = cli.Delete(ctx, expected, &ctrlcli.DeleteOptions{
			DryRun:            co.DryRun,
			PropagationPolicy: ptr.To(meta.DeletePropagationForeground),
		})
		if err != nil && !kerrors.IsNotFound(err) {
			return actual, err
		}

		// Recreate.
		return CreateWithCtrlClient(ctx, cli, expected, opts...)
	}

	return actual, nil
}

type (
	UpdateClient[T MetaObject] interface {
		Create(ctx context.Context, obj T, opts meta.CreateOptions) (T, error)
		Update(ctx context.Context, obj T, opts meta.UpdateOptions) (T, error)
		Get(ctx context.Context, name string, opts meta.GetOptions) (T, error)
	}

	_UpdateOptions[T MetaObject] struct {
		meta.UpdateOptions
		AlignFunc          AlignWithFn[T]
		CreateIfNotExisted bool
	}

	UpdateOption[T MetaObject] func(*_UpdateOptions[T])
)

// WithUpdateMetaOptions sets the update options.
func WithUpdateMetaOptions[T MetaObject](opts meta.UpdateOptions) UpdateOption[T] {
	return func(uo *_UpdateOptions[T]) {
		uo.UpdateOptions = opts
	}
}

// UpdateAfterAlign with the align function to update the resource.
func UpdateAfterAlign[T MetaObject](fn AlignWithFn[T]) UpdateOption[T] {
	return func(uo *_UpdateOptions[T]) {
		uo.AlignFunc = fn
	}
}

// UpdateOrCreate will create the resource if it does not exist.
func UpdateOrCreate[T MetaObject]() UpdateOption[T] {
	return func(uo *_UpdateOptions[T]) {
		uo.CreateIfNotExisted = true
	}
}

// Update will update the resource if it exists,
// and returns the updated resource.
//
// Update returns error if the resource is not found or updating failed.
//
// Update will retry if the resource is updating conflicted when AlignWithFn is provided.
func Update[T MetaObject](ctx context.Context, cli UpdateClient[T], expected T, opts ...UpdateOption[T]) (T, error) {
	if reflect.ValueOf(expected).IsZero() {
		return expected, errors.New("expected is nil")
	}

	var uo _UpdateOptions[T]
	for i := range opts {
		opts[i](&uo)
	}

	name := expected.GetName()
	if name == "" {
		return expected, errors.New("resource name may not be empty")
	}

	actual, err := cli.Get(ctx, name, meta.GetOptions{
		ResourceVersion: "0",
	})
	if err != nil {
		if kerrors.IsNotFound(err) && uo.CreateIfNotExisted {
			return cli.Create(ctx, expected, meta.CreateOptions{
				DryRun: uo.DryRun,
			})
		}
		return actual, err
	}

	var copied T
	if uo.AlignFunc != nil {
		var skip bool
		copied, skip, err = uo.AlignFunc(actual.DeepCopyObject().(T))
		if err != nil {
			return actual, err
		}
		if skip {
			return actual, nil
		}
	} else {
		copied = expected.DeepCopyObject().(T)
		// Copy resource version for update.
		//
		// And keep the original labels, annotations, finalizers, and owner references if they are not set.
		// If you want to clean the above fields, please set them to empty in the expected object.
		copiedOm, actualOm := copied, actual
		copiedOm.SetResourceVersion(actualOm.GetResourceVersion())
		if copiedOm.GetLabels() == nil {
			copiedOm.SetLabels(actualOm.GetLabels())
		}
		if copiedOm.GetAnnotations() == nil {
			copiedOm.SetAnnotations(actualOm.GetAnnotations())
		}
		if copiedOm.GetFinalizers() == nil {
			copiedOm.SetFinalizers(actualOm.GetFinalizers())
		}
		if copiedOm.GetOwnerReferences() == nil {
			copiedOm.SetOwnerReferences(actualOm.GetOwnerReferences())
		}
	}

	updated, err := cli.Update(ctx, copied, meta.UpdateOptions{
		DryRun: uo.DryRun,
	})
	if err != nil {
		if !kerrors.IsConflict(err) && !kerrors.IsNotAcceptable(err) {
			return actual, err
		}

		// Retry if conflicted when align function is provided.
		if uo.AlignFunc != nil {
			return Update(ctx, cli, expected, opts...)
		}
	}

	return updated, err
}

// UpdateWithCtrlClient is similar to Update, but uses the ctrl client.
func UpdateWithCtrlClient[T MetaObject](ctx context.Context, cli ctrlcli.Client, expected T, opts ...UpdateOption[T]) (T, error) {
	if reflect.ValueOf(expected).IsZero() {
		return expected, errors.New("expected is nil")
	}

	var uo _UpdateOptions[T]
	for i := range opts {
		opts[i](&uo)
	}

	name := expected.GetName()
	if name == "" {
		return expected, errors.New("resource name may not be empty")
	}

	actual := expected.DeepCopyObject().(T)
	err := cli.Get(ctx, ctrlcli.ObjectKeyFromObject(expected), actual)
	if err != nil {
		if kerrors.IsNotFound(err) && uo.CreateIfNotExisted {
			return expected, cli.Create(ctx, expected, &ctrlcli.CreateOptions{
				DryRun:       uo.DryRun,
				FieldManager: uo.FieldManager,
			})
		}
		return actual, err
	}

	var copied T
	if uo.AlignFunc != nil {
		var skip bool
		copied, skip, err = uo.AlignFunc(actual.DeepCopyObject().(T))
		if err != nil {
			return actual, err
		}
		if skip {
			return actual, nil
		}
	} else {
		copied = expected.DeepCopyObject().(T)
		// Copy resource version for update.
		//
		// And keep the original labels, annotations, finalizers, and owner references if they are not set.
		// If you want to clean the above fields, please set them to empty in the expected object.
		copiedOm, actualOm := copied, actual
		copiedOm.SetResourceVersion(actualOm.GetResourceVersion())
		if copiedOm.GetLabels() == nil {
			copiedOm.SetLabels(actualOm.GetLabels())
		}
		if copiedOm.GetAnnotations() == nil {
			copiedOm.SetAnnotations(actualOm.GetAnnotations())
		}
		if copiedOm.GetFinalizers() == nil {
			copiedOm.SetFinalizers(actualOm.GetFinalizers())
		}
		if copiedOm.GetOwnerReferences() == nil {
			copiedOm.SetOwnerReferences(actualOm.GetOwnerReferences())
		}
	}

	updated := copied
	err = cli.Update(ctx, updated, &ctrlcli.UpdateOptions{
		DryRun:       uo.DryRun,
		FieldManager: uo.FieldManager,
		Raw:          ptr.To(uo.UpdateOptions),
	})
	if err != nil {
		if !kerrors.IsConflict(err) && !kerrors.IsNotAcceptable(err) {
			return actual, err
		}

		// Retry if conflicted when align function is provided.
		if uo.AlignFunc != nil {
			return UpdateWithCtrlClient(ctx, cli, expected, opts...)
		}
	}

	return updated, err
}

type (
	DeleteClient interface {
		Delete(ctx context.Context, name string, opts meta.DeleteOptions) error
	}

	_DeleteOptions struct {
		meta.DeleteOptions
	}

	DeleteOption func(*_DeleteOptions)
)

// WithDeleteMetaOptions sets the delete options.
func WithDeleteMetaOptions(opts meta.DeleteOptions) DeleteOption {
	return func(do *_DeleteOptions) {
		do.DeleteOptions = opts
	}
}

// Delete will delete the resource if it exists.
//
// Delete doesn't return error if the resource is not found.
func Delete(ctx context.Context, cli DeleteClient, expected MetaObject, opts ...DeleteOption) error {
	if reflect.ValueOf(expected).IsZero() {
		return errors.New("expected is nil")
	}

	name := expected.GetName()
	if name == "" {
		return errors.New("resource name may not be empty")
	}

	var do _DeleteOptions
	for i := range opts {
		opts[i](&do)
	}

	err := cli.Delete(ctx, name, do.DeleteOptions)
	if err != nil && !kerrors.IsNotFound(err) {
		return err
	}

	return nil
}

// DeleteWithCtrlClient is similar to Delete, but uses the ctrl client.
func DeleteWithCtrlClient(ctx context.Context, cli ctrlcli.Client, expected MetaObject, opts ...DeleteOption) error {
	if reflect.ValueOf(expected).IsZero() {
		return errors.New("expected is nil")
	}

	name := expected.GetName()
	if name == "" {
		return errors.New("resource name may not be empty")
	}

	var do _DeleteOptions
	for i := range opts {
		opts[i](&do)
	}

	err := cli.Delete(ctx, expected, &ctrlcli.DeleteOptions{
		GracePeriodSeconds: do.GracePeriodSeconds,
		Preconditions:      do.Preconditions,
		PropagationPolicy:  do.PropagationPolicy,
		DryRun:             do.DryRun,
		Raw:                ptr.To(do.DeleteOptions),
	})
	if err != nil && !kerrors.IsNotFound(err) {
		return err
	}

	return nil
}
