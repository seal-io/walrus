//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.
package webhook_gen

import (
	v1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/utils/ptr"
)

func GetWebhookConfigurations(np string, c v1.WebhookClientConfig) (*v1.ValidatingWebhookConfiguration, *v1.MutatingWebhookConfiguration) {
	vwc := GetValidatingWebhookConfiguration(np+"-validation", c)
	mwc := GetMutatingWebhookConfiguration(np+"-mutation", c)
	return vwc, mwc
}

func GetValidatingWebhookConfiguration(n string, c v1.WebhookClientConfig) *v1.ValidatingWebhookConfiguration {
	return &v1.ValidatingWebhookConfiguration{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "admissionregistration.k8s.io/v1",
			Kind:       "ValidatingWebhookConfiguration",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: n,
		},
		Webhooks: []v1.ValidatingWebhook{
			vwh_webhook_gen_generators_testdata_webhook_gen_DummyReconciler(c),
		},
	}
}

func GetMutatingWebhookConfiguration(n string, c v1.WebhookClientConfig) *v1.MutatingWebhookConfiguration {
	return &v1.MutatingWebhookConfiguration{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "admissionregistration.k8s.io/v1",
			Kind:       "MutatingWebhookConfiguration",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: n,
		},
		Webhooks: []v1.MutatingWebhook{
			mwh_webhook_gen_generators_testdata_webhook_gen_DummyReconciler(c),
		},
	}
}

func (*DummyReconciler) ValidatePath() string {
	return "/validate-samplecontroller-seal-io-v1-dummy"
}

func vwh_webhook_gen_generators_testdata_webhook_gen_DummyReconciler(c v1.WebhookClientConfig) v1.ValidatingWebhook {
	path := "/validate-samplecontroller-seal-io-v1-dummy"

	cc := c.DeepCopy()
	if cc.Service != nil {
		cc.Service.Path = &path
	} else if c.URL != nil {
		cc.URL = ptr.To(*c.URL + path)
	}

	return v1.ValidatingWebhook{
		Name:         "validate.samplecontroller.seal.io.v1.dummy",
		ClientConfig: *cc,
		Rules: []v1.RuleWithOperations{
			{
				Rule: v1.Rule{
					APIGroups: []string{
						"samplecontroller.seal.io",
					},
					APIVersions: []string{
						"v1",
					},
					Resources: []string{
						"dummies",
					},
					Scope: ptr.To[v1.ScopeType]("*"),
				},
				Operations: []v1.OperationType{
					"CREATE",
					"UPDATE",
					"DELETE",
				},
			},
		},
		FailurePolicy: ptr.To[v1.FailurePolicyType]("Fail"),
		MatchPolicy:   ptr.To[v1.MatchPolicyType]("Equivalent"),
		NamespaceSelector: ptr.To(metav1.LabelSelector{
			MatchExpressions: []metav1.LabelSelectorRequirement{
				{
					Key:      "walrus.seal.io/operate",
					Operator: metav1.LabelSelectorOperator("Exists"),
				},
			},
		}),
		ObjectSelector: ptr.To(metav1.LabelSelector{
			MatchLabels: map[string]string{
				"label": "value",
			},
		}),
		SideEffects:    ptr.To[v1.SideEffectClass]("None"),
		TimeoutSeconds: ptr.To[int32](10),
		AdmissionReviewVersions: []string{
			"v1",
		},
		MatchConditions: []v1.MatchCondition{
			{
				Name:       "test",
				Expression: "self.b > 0",
			},
		},
	}
}

func (*DummyReconciler) DefaultPath() string {
	return "/mutate-samplecontroller-seal-io-v1-dummy"
}

func mwh_webhook_gen_generators_testdata_webhook_gen_DummyReconciler(c v1.WebhookClientConfig) v1.MutatingWebhook {
	path := "/mutate-samplecontroller-seal-io-v1-dummy"

	cc := c.DeepCopy()
	if cc.Service != nil {
		cc.Service.Path = &path
	} else if c.URL != nil {
		cc.URL = ptr.To(*c.URL + path)
	}

	return v1.MutatingWebhook{
		Name:         "mutate.samplecontroller.seal.io.v1.dummy",
		ClientConfig: *cc,
		Rules: []v1.RuleWithOperations{
			{
				Rule: v1.Rule{
					APIGroups: []string{
						"samplecontroller.seal.io",
					},
					APIVersions: []string{
						"v1",
					},
					Resources: []string{
						"dummies",
					},
					Scope: ptr.To[v1.ScopeType]("*"),
				},
			},
		},
		FailurePolicy: ptr.To[v1.FailurePolicyType]("Fail"),
		MatchPolicy:   ptr.To[v1.MatchPolicyType]("Equivalent"),
		NamespaceSelector: ptr.To(metav1.LabelSelector{
			MatchExpressions: []metav1.LabelSelectorRequirement{
				{
					Key:      "walrus.seal.io/operate",
					Operator: metav1.LabelSelectorOperator("Exists"),
				},
			},
		}),
		ObjectSelector: ptr.To(metav1.LabelSelector{
			MatchLabels: map[string]string{
				"label": "value",
			},
		}),
		SideEffects:    ptr.To[v1.SideEffectClass]("None"),
		TimeoutSeconds: ptr.To[int32](10),
		AdmissionReviewVersions: []string{
			"v1",
		},
		ReinvocationPolicy: ptr.To[v1.ReinvocationPolicyType]("Never"),
	}
}
