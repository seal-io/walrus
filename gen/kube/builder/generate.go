package builder

import (
	"context"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"slices"
	"strings"

	apireggenargs "github.com/seal-io/code-generator/cmd/apireg-gen/args"
	apireggen "github.com/seal-io/code-generator/cmd/apireg-gen/generators"
	crdgenargs "github.com/seal-io/code-generator/cmd/crd-gen/args"
	crdgen "github.com/seal-io/code-generator/cmd/crd-gen/generators"
	webhookgenargs "github.com/seal-io/code-generator/cmd/webhook-gen/args"
	webhookgen "github.com/seal-io/code-generator/cmd/webhook-gen/generators"
	"github.com/seal-io/utils/osx"
	"github.com/seal-io/utils/pools/gopool"
	"github.com/seal-io/utils/stringx"
	applygenargs "k8s.io/code-generator/cmd/applyconfiguration-gen/args"
	applygen "k8s.io/code-generator/cmd/applyconfiguration-gen/generators"
	clientgenargs "k8s.io/code-generator/cmd/client-gen/args"
	clientgen "k8s.io/code-generator/cmd/client-gen/generators"
	clientgentypes "k8s.io/code-generator/cmd/client-gen/types"
	protobufgen "k8s.io/code-generator/cmd/go-to-protobuf/protobuf"
	informergenargs "k8s.io/code-generator/cmd/informer-gen/args"
	informergen "k8s.io/code-generator/cmd/informer-gen/generators"
	listergenargs "k8s.io/code-generator/cmd/lister-gen/args"
	listergen "k8s.io/code-generator/cmd/lister-gen/generators"
	registergen "k8s.io/code-generator/cmd/register-gen/generators"
	"k8s.io/gengo/args"
	deepcopygen "k8s.io/gengo/examples/deepcopy-gen/generators"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/types"
	openapigenargs "k8s.io/kube-openapi/cmd/openapi-gen/args"
	openapigen "k8s.io/kube-openapi/pkg/generators"
	"k8s.io/utils/ptr"

	_ "embed"
)

func Generate(c Config) error {
	tempHeaderFile := osx.TempFile("")
	defer func() { _ = os.Remove(tempHeaderFile) }()
	_ = os.WriteFile(tempHeaderFile, stringx.ToBytes(ptr.To(stringx.Join("\n\n", c.Header, generatedHeader, ""))), 0o600)

	internalAPIs := append(slices.Clone(c.APIs), c.ExtensionAPIs...)

	// Execute deepcopy-gen.
	{
		deepcopyGen := args.GeneratorArgs{
			InputDirs:          slices.Clone(internalAPIs),
			OutputBase:         c.ProjectDir,
			OutputFileBaseName: "zz_generated.deepcopy",
			GoHeaderFilePath:   tempHeaderFile,
			GeneratedBuildTag:  "ignore_autogenerated",
			CustomArgs:         &deepcopygen.CustomArgs{},
		}
		if err := deepcopyGen.Execute(
			deepcopygen.NameSystems(),
			deepcopygen.DefaultNameSystem(),
			align(c.Project, deepcopygen.Packages)); err != nil {
			return fmt.Errorf("execute deepcopy-gen: %w", err)
		}
	}

	// Execute register-gen.
	{
		registerGen := args.GeneratorArgs{
			InputDirs:          slices.Clone(internalAPIs),
			OutputBase:         c.ProjectDir,
			OutputFileBaseName: "zz_generated.register",
			GoHeaderFilePath:   tempHeaderFile,
			GeneratedBuildTag:  "ignore_autogenerated",
		}
		if err := registerGen.Execute(
			registergen.NameSystems(),
			registergen.DefaultNameSystem(),
			align(c.Project, registergen.Packages)); err != nil {
			return fmt.Errorf("execute register-gen: %w", err)
		}
	}

	// Execute go-to-protobuf.
	{
		protoGenAPIMachineryPackages := []string{
			"-k8s.io/apimachinery/pkg/api/resource",
			"-k8s.io/apimachinery/pkg/types",
			"-k8s.io/apimachinery/pkg/util/intstr",
			"-k8s.io/apimachinery/pkg/runtime/schema",
			"-k8s.io/apimachinery/pkg/runtime",
			"-k8s.io/apimachinery/pkg/apis/meta/v1/unstructured",
			"-k8s.io/apimachinery/pkg/apis/meta/v1",
		}
		protoGenDropEmbeddedFields := []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.TypeMeta",
		}

		protocGen := protobufgen.Generator{
			Common:               args.GeneratorArgs{GoHeaderFilePath: tempHeaderFile},
			TrimPathPrefix:       c.Project,
			Packages:             strings.Join(internalAPIs, ","),
			ProtoImport:          c.ProtoImports,
			APIMachineryPackages: strings.Join(protoGenAPIMachineryPackages, ","),
			DropEmbeddedFields:   strings.Join(protoGenDropEmbeddedFields, ","),
		}
		protobufgen.Run(&protocGen)
	}

	// Execute crd-gen/apireg-gen/openapi-gen/webhook-gen.
	gp := gopool.GroupWithContextIn(context.Background())

	gp.Go(func(ctx context.Context) error {
		crdGen := args.GeneratorArgs{
			InputDirs:          slices.Clone(c.APIs),
			OutputBase:         c.ProjectDir,
			OutputFileBaseName: "zz_generated.crds",
			GoHeaderFilePath:   tempHeaderFile,
			GeneratedBuildTag:  "ignore_autogenerated",
			CustomArgs:         &crdgenargs.CustomArgs{},
		}

		if err := crdGen.Execute(
			crdgen.NameSystems(),
			crdgen.DefaultNameSystem(),
			align(c.Project, crdgen.Packages)); err != nil {
			return fmt.Errorf("execute crd-gen: %w", err)
		}

		return nil
	})

	gp.Go(func(ctx context.Context) error {
		// Execute apireg-gen.
		apiRegGen := args.GeneratorArgs{
			InputDirs:          slices.Clone(c.ExtensionAPIs),
			OutputBase:         c.ProjectDir,
			OutputFileBaseName: "zz_generated.apiservice",
			GoHeaderFilePath:   tempHeaderFile,
			GeneratedBuildTag:  "ignore_autogenerated",
			CustomArgs:         &apireggenargs.CustomArgs{},
		}

		if err := apiRegGen.Execute(
			apireggen.NameSystems(),
			apireggen.DefaultNameSystem(),
			align(c.Project, apireggen.Packages)); err != nil {
			return fmt.Errorf("execute apireg-gen: %w", err)
		}

		// Execute openapi-gen.
		openapiGen := args.GeneratorArgs{
			InputDirs: append(slices.Clone(internalAPIs),
				"k8s.io/apimachinery/pkg/api/resource",
				"k8s.io/apimachinery/pkg/version",
				"k8s.io/apimachinery/pkg/runtime",
				"k8s.io/apimachinery/pkg/apis/meta/v1"),
			OutputBase:         c.ProjectDir,
			OutputPackagePath:  path.Join(c.Project, "pkg", "apis"),
			OutputFileBaseName: "zz_generated.openapi",
			GoHeaderFilePath:   tempHeaderFile,
			GeneratedBuildTag:  "ignore_autogenerated",
			CustomArgs: &openapigenargs.CustomArgs{
				ReportFilename: filepath.Join(c.ProjectDir, "pkg", "apis", "zz_generated.openapi.violation_exceptions"),
			},
		}

		if err := openapiGen.Execute(
			openapigen.NameSystems(),
			openapigen.DefaultNameSystem(),
			align(c.Project, openapigen.Packages)); err != nil {
			return fmt.Errorf("execute openapi-gen: %w", err)
		}

		return nil
	})

	gp.Go(func(ctx context.Context) error {
		webhookGen := args.GeneratorArgs{
			InputDirs:          slices.Clone(c.Webhooks),
			OutputBase:         c.ProjectDir,
			OutputFileBaseName: "zz_generated.webhooks",
			GoHeaderFilePath:   tempHeaderFile,
			GeneratedBuildTag:  "ignore_autogenerated",
			CustomArgs:         &webhookgenargs.CustomArgs{},
		}

		if err := webhookGen.Execute(
			webhookgen.NameSystems(),
			webhookgen.DefaultNameSystem(),
			align(c.Project, webhookgen.Packages)); err != nil {
			return fmt.Errorf("execute webhook-gen: %w", err)
		}

		return nil
	})

	err := gp.Wait()
	if err != nil {
		return err
	}

	// Execute applyconfiguration-gen/client-gen/lister-gen/informer-gen.
	_ = os.RemoveAll(path.Join(c.ProjectDir, "pkg", "clients"))

	// Execute applyconfiguration-gen.
	applyConfigExternal := map[types.Name]string{ // nolint:lll
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "TypeMeta"}:                 "k8s.io/client-go/applyconfigurations/meta/v1",
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "ObjectMeta"}:               "k8s.io/client-go/applyconfigurations/meta/v1",
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "OwnerReference"}:           "k8s.io/client-go/applyconfigurations/meta/v1",
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "Condition"}:                "k8s.io/client-go/applyconfigurations/meta/v1",
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "DeleteOptions"}:            "k8s.io/client-go/applyconfigurations/meta/v1",
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "LabelSelector"}:            "k8s.io/client-go/applyconfigurations/meta/v1",
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "LabelSelectorRequirement"}: "k8s.io/client-go/applyconfigurations/meta/v1",
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "ManagedFieldsEntry"}:       "k8s.io/client-go/applyconfigurations/meta/v1",
		{Package: "k8s.io/apimachinery/pkg/apis/meta/v1", Name: "Preconditions"}:            "k8s.io/client-go/applyconfigurations/meta/v1",
	}

	applyConfigPkg := path.Join(c.Project, "pkg", "clients", "applyconfiguration")
	applyConfigGen := args.GeneratorArgs{
		InputDirs:         append(slices.Clone(internalAPIs), c.ExternalAPIs...),
		OutputBase:        c.ProjectDir,
		OutputPackagePath: applyConfigPkg,
		GoHeaderFilePath:  tempHeaderFile,
		GeneratedBuildTag: "ignore_autogenerated",
		CustomArgs: &applygenargs.CustomArgs{
			ExternalApplyConfigurations: applyConfigExternal,
		},
	}

	if err := applyConfigGen.Execute(
		applygen.NameSystems(),
		applygen.DefaultNameSystem(),
		align(c.Project, applygen.Packages)); err != nil {
		return fmt.Errorf("execute applyconfiguration-gen: %w", err)
	}

	// Execute client-gen.
	clientsetGrpVers := make([]clientgentypes.GroupVersions, 0, len(internalAPIs)+len(c.ExternalAPIs))
	for _, grpVerPkg := range append(slices.Clone(internalAPIs), c.ExternalAPIs...) {
		gn := path.Base(path.Dir(grpVerPkg))
		vn := path.Base(grpVerPkg)
		grpVer := clientgentypes.GroupVersions{
			PackageName: gn,
			Group:       clientgentypes.Group(gn),
			Versions: []clientgentypes.PackageVersion{
				{
					Package: grpVerPkg,
					Version: clientgentypes.Version(vn),
				},
			},
		}
		clientsetGrpVers = append(clientsetGrpVers, grpVer)
	}

	clientsetPkg := path.Join(c.Project, "pkg", "clients", "clientset")
	clientsetGen := args.GeneratorArgs{
		InputDirs:         append(slices.Clone(internalAPIs), c.ExternalAPIs...),
		OutputBase:        c.ProjectDir,
		OutputPackagePath: path.Dir(clientsetPkg),
		GoHeaderFilePath:  tempHeaderFile,
		GeneratedBuildTag: "ignore_autogenerated",
		CustomArgs: &clientgenargs.CustomArgs{
			Groups:                    clientsetGrpVers,
			ClientsetName:             path.Base(clientsetPkg),
			ClientsetAPIPath:          "/apis",
			ClientsetOnly:             false,
			FakeClient:                true,
			ApplyConfigurationPackage: applyConfigPkg,
		},
	}

	if err := clientsetGen.Execute(
		clientgen.NameSystems(c.PluralExceptions),
		clientgen.DefaultNameSystem(),
		align(c.Project, clientgen.Packages)); err != nil {
		return fmt.Errorf("execute client-gen: %w", err)
	}

	// Execute lister-gen.
	listerPkg := path.Join(c.Project, "pkg", "clients", "listers")
	listerGen := args.GeneratorArgs{
		InputDirs:         append(slices.Clone(internalAPIs), c.ExternalAPIs...),
		OutputBase:        c.ProjectDir,
		OutputPackagePath: listerPkg,
		GoHeaderFilePath:  tempHeaderFile,
		GeneratedBuildTag: "ignore_autogenerated",
		CustomArgs:        &listergenargs.CustomArgs{},
	}

	if err := listerGen.Execute(
		listergen.NameSystems(c.PluralExceptions),
		listergen.DefaultNameSystem(),
		align(c.Project, listergen.Packages)); err != nil {
		return fmt.Errorf("execute lister-gen: %w", err)
	}

	// Execute informer-gen.
	informerPkg := path.Join(c.Project, "pkg", "clients", "informers")
	informerGen := args.GeneratorArgs{
		InputDirs:         append(slices.Clone(internalAPIs), c.ExternalAPIs...),
		OutputBase:        c.ProjectDir,
		OutputPackagePath: informerPkg,
		GoHeaderFilePath:  tempHeaderFile,
		GeneratedBuildTag: "ignore_autogenerated",
		CustomArgs: &informergenargs.CustomArgs{
			VersionedClientSetPackage: clientsetPkg,
			ListersPackage:            listerPkg,
			SingleDirectory:           true,
		},
	}

	if err := informerGen.Execute(
		informergen.NameSystems(c.PluralExceptions),
		informergen.DefaultNameSystem(),
		align(c.Project, informergen.Packages)); err != nil {
		return fmt.Errorf("execute informer-gen: %w", err)
	}

	return nil
}

type pkgsFunc func(ctx *generator.Context, args *args.GeneratorArgs) generator.Packages

func align(p string, f pkgsFunc) pkgsFunc {
	return func(ctx *generator.Context, args *args.GeneratorArgs) generator.Packages {
		pkgs := f(ctx, args)

		for i := range pkgs {
			pkg, ok := pkgs[i].(*generator.DefaultPackage)
			if !ok {
				continue
			}

			pkg.PackagePath = strings.TrimPrefix(pkg.PackagePath, p+"/")
			pkgs[i] = pkg
		}

		return pkgs
	}
}
